var e=Object.defineProperty;import{g as t,r as n,a as r}from"./phaser-fBFBqv5x.js";function s(e,t){for(var n=0;n<t.length;n++){const r=t[n];if("string"!=typeof r&&!Array.isArray(r))for(const t in r)if("default"!==t&&!(t in e)){const n=Object.getOwnPropertyDescriptor(r,t);n&&Object.defineProperty(e,t,n.get?n:{enumerable:!0,get:()=>r[t]})}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const n of e)if("childList"===n.type)for(const e of n.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();var a,i,o,l,u={exports:{}},c={},h=(i||(i=1,u.exports=function(){if(a)return c;a=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function n(t,n,r){var s=null;if(void 0!==r&&(s=""+r),void 0!==n.key&&(s=""+n.key),"key"in n)for(var a in r={},n)"key"!==a&&(r[a]=n[a]);else r=n;return n=r.ref,{$$typeof:e,type:t,key:s,ref:void 0!==n?n:null,props:r}}return c.Fragment=t,c.jsx=n,c.jsxs=n,c}()),u.exports),d={exports:{}},p={};function f(){if(o)return p;o=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),a=Symbol.for("react.consumer"),i=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),d=Symbol.iterator,f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function b(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}function y(){}function x(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=b.prototype;var v=x.prototype=new y;v.constructor=x,g(v,b.prototype),v.isPureReactComponent=!0;var w=Array.isArray,k={H:null,A:null,T:null,S:null,V:null},S=Object.prototype.hasOwnProperty;function I(t,n,r,s,a,i){return r=i.ref,{$$typeof:e,type:t,key:n,ref:void 0!==r?r:null,props:i}}function C(t){return"object"==typeof t&&null!==t&&t.$$typeof===e}var T=/\/+/g;function N(e,t){return"object"==typeof e&&null!==e&&null!=e.key?(n=""+e.key,r={"=":"=0",":":"=2"},"$"+n.replace(/[=:]/g,(function(e){return r[e]}))):t.toString(36);var n,r}function E(){}function $(n,r,s,a,i){var o=typeof n;"undefined"!==o&&"boolean"!==o||(n=null);var l,u,c=!1;if(null===n)c=!0;else switch(o){case"bigint":case"string":case"number":c=!0;break;case"object":switch(n.$$typeof){case e:case t:c=!0;break;case h:return $((c=n._init)(n._payload),r,s,a,i)}}if(c)return i=i(n),c=""===a?"."+N(n,0):a,w(i)?(s="",null!=c&&(s=c.replace(T,"$&/")+"/"),$(i,r,s,"",(function(e){return e}))):null!=i&&(C(i)&&(l=i,u=s+(null==i.key||n&&n.key===i.key?"":(""+i.key).replace(T,"$&/")+"/")+c,i=I(l.type,u,void 0,0,0,l.props)),r.push(i)),1;c=0;var p,f=""===a?".":a+":";if(w(n))for(var g=0;g<n.length;g++)c+=$(a=n[g],r,s,o=f+N(a,g),i);else if("function"==typeof(g=null===(p=n)||"object"!=typeof p?null:"function"==typeof(p=d&&p[d]||p["@@iterator"])?p:null))for(n=g.call(n),g=0;!(a=n.next()).done;)c+=$(a=a.value,r,s,o=f+N(a,g++),i);else if("object"===o){if("function"==typeof n.then)return $(function(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch("string"==typeof e.status?e.then(E,E):(e.status="pending",e.then((function(t){"pending"===e.status&&(e.status="fulfilled",e.value=t)}),(function(t){"pending"===e.status&&(e.status="rejected",e.reason=t)}))),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}(n),r,s,a,i);throw r=String(n),Error("Objects are not valid as a React child (found: "+("[object Object]"===r?"object with keys {"+Object.keys(n).join(", ")+"}":r)+"). If you meant to render a collection of children, use an array instead.")}return c}function R(e,t,n){if(null==e)return e;var r=[],s=0;return $(e,r,"","",(function(e){return t.call(n,e,s++)})),r}function A(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var _="function"==typeof reportError?reportError:function(e){if("object"==typeof window&&"function"==typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"==typeof e&&null!==e&&"string"==typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"==typeof process&&"function"==typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function O(){}return p.Children={map:R,forEach:function(e,t,n){R(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return R(e,(function(){t++})),t},toArray:function(e){return R(e,(function(e){return e}))||[]},only:function(e){if(!C(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},p.Component=b,p.Fragment=n,p.Profiler=s,p.PureComponent=x,p.StrictMode=r,p.Suspense=u,p.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=k,p.__COMPILER_RUNTIME={__proto__:null,c:function(e){return k.H.useMemoCache(e)}},p.cache=function(e){return function(){return e.apply(null,arguments)}},p.cloneElement=function(e,t,n){if(null==e)throw Error("The argument must be a React element, but you passed "+e+".");var r=g({},e.props),s=e.key;if(null!=t)for(a in t.ref,void 0!==t.key&&(s=""+t.key),t)!S.call(t,a)||"key"===a||"__self"===a||"__source"===a||"ref"===a&&void 0===t.ref||(r[a]=t[a]);var a=arguments.length-2;if(1===a)r.children=n;else if(1<a){for(var i=Array(a),o=0;o<a;o++)i[o]=arguments[o+2];r.children=i}return I(e.type,s,void 0,0,0,r)},p.createContext=function(e){return(e={$$typeof:i,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider=e,e.Consumer={$$typeof:a,_context:e},e},p.createElement=function(e,t,n){var r,s={},a=null;if(null!=t)for(r in void 0!==t.key&&(a=""+t.key),t)S.call(t,r)&&"key"!==r&&"__self"!==r&&"__source"!==r&&(s[r]=t[r]);var i=arguments.length-2;if(1===i)s.children=n;else if(1<i){for(var o=Array(i),l=0;l<i;l++)o[l]=arguments[l+2];s.children=o}if(e&&e.defaultProps)for(r in i=e.defaultProps)void 0===s[r]&&(s[r]=i[r]);return I(e,a,void 0,0,0,s)},p.createRef=function(){return{current:null}},p.forwardRef=function(e){return{$$typeof:l,render:e}},p.isValidElement=C,p.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:A}},p.memo=function(e,t){return{$$typeof:c,type:e,compare:void 0===t?null:t}},p.startTransition=function(e){var t=k.T,n={};k.T=n;try{var r=e(),s=k.S;null!==s&&s(n,r),"object"==typeof r&&null!==r&&"function"==typeof r.then&&r.then(O,_)}catch(a){_(a)}finally{k.T=t}},p.unstable_useCacheRefresh=function(){return k.H.useCacheRefresh()},p.use=function(e){return k.H.use(e)},p.useActionState=function(e,t,n){return k.H.useActionState(e,t,n)},p.useCallback=function(e,t){return k.H.useCallback(e,t)},p.useContext=function(e){return k.H.useContext(e)},p.useDebugValue=function(){},p.useDeferredValue=function(e,t){return k.H.useDeferredValue(e,t)},p.useEffect=function(e,t,n){var r=k.H;if("function"==typeof n)throw Error("useEffect CRUD overload is not enabled in this build of React.");return r.useEffect(e,t)},p.useId=function(){return k.H.useId()},p.useImperativeHandle=function(e,t,n){return k.H.useImperativeHandle(e,t,n)},p.useInsertionEffect=function(e,t){return k.H.useInsertionEffect(e,t)},p.useLayoutEffect=function(e,t){return k.H.useLayoutEffect(e,t)},p.useMemo=function(e,t){return k.H.useMemo(e,t)},p.useOptimistic=function(e,t){return k.H.useOptimistic(e,t)},p.useReducer=function(e,t,n){return k.H.useReducer(e,t,n)},p.useRef=function(e){return k.H.useRef(e)},p.useState=function(e){return k.H.useState(e)},p.useSyncExternalStore=function(e,t,n){return k.H.useSyncExternalStore(e,t,n)},p.useTransition=function(){return k.H.useTransition()},p.version="19.1.0",p}function g(){return l||(l=1,d.exports=f()),d.exports}var m=g();const b=t(m);var y,x,v={exports:{}},w={},k={exports:{}},S={};var I,C,T,N,E={exports:{}},$={};const R=t((N||(N=1,function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),v.exports=function(){if(T)return w;T=1;var e=(x||(x=1,k.exports=(y||(y=1,function(e){function t(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,a=e[r];if(!(0<s(a,t)))break e;e[r]=t,e[n]=a,n=r}}function n(e){return 0===e.length?null:e[0]}function r(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,a=e.length,i=a>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>s(l,n))u<a&&0>s(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<a&&0>s(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function s(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if(e.unstable_now=void 0,"object"==typeof performance&&"function"==typeof performance.now){var a=performance;e.unstable_now=function(){return a.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],u=[],c=1,h=null,d=3,p=!1,f=!1,g=!1,m=!1,b="function"==typeof setTimeout?setTimeout:null,y="function"==typeof clearTimeout?clearTimeout:null,x="undefined"!=typeof setImmediate?setImmediate:null;function v(e){for(var s=n(u);null!==s;){if(null===s.callback)r(u);else{if(!(s.startTime<=e))break;r(u),s.sortIndex=s.expirationTime,t(l,s)}s=n(u)}}function w(e){if(g=!1,v(e),!f)if(null!==n(l))f=!0,S||(S=!0,k());else{var t=n(u);null!==t&&A(w,t.startTime-e)}}var k,S=!1,I=-1,C=5,T=-1;function N(){return!(!m&&e.unstable_now()-T<C)}function E(){if(m=!1,S){var t=e.unstable_now();T=t;var s=!0;try{e:{f=!1,g&&(g=!1,y(I),I=-1),p=!0;var a=d;try{t:{for(v(t),h=n(l);null!==h&&!(h.expirationTime>t&&N());){var i=h.callback;if("function"==typeof i){h.callback=null,d=h.priorityLevel;var o=i(h.expirationTime<=t);if(t=e.unstable_now(),"function"==typeof o){h.callback=o,v(t),s=!0;break t}h===n(l)&&r(l),v(t)}else r(l);h=n(l)}if(null!==h)s=!0;else{var c=n(u);null!==c&&A(w,c.startTime-t),s=!1}}break e}finally{h=null,d=a,p=!1}s=void 0}}finally{s?k():S=!1}}}if("function"==typeof x)k=function(){x(E)};else if("undefined"!=typeof MessageChannel){var $=new MessageChannel,R=$.port2;$.port1.onmessage=E,k=function(){R.postMessage(null)}}else k=function(){b(E,0)};function A(t,n){I=b((function(){t(e.unstable_now())}),n)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(e){e.callback=null},e.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):C=0<e?Math.floor(1e3/e):5},e.unstable_getCurrentPriorityLevel=function(){return d},e.unstable_next=function(e){switch(d){case 1:case 2:case 3:var t=3;break;default:t=d}var n=d;d=t;try{return e()}finally{d=n}},e.unstable_requestPaint=function(){m=!0},e.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=d;d=e;try{return t()}finally{d=n}},e.unstable_scheduleCallback=function(r,s,a){var i=e.unstable_now();switch(a="object"==typeof a&&null!==a&&"number"==typeof(a=a.delay)&&0<a?i+a:i,r){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return r={id:c++,callback:s,priorityLevel:r,startTime:a,expirationTime:o=a+o,sortIndex:-1},a>i?(r.sortIndex=a,t(u,r),null===n(l)&&r===n(u)&&(g?(y(I),I=-1):g=!0,A(w,a-i))):(r.sortIndex=o,t(l,r),f||p||(f=!0,S||(S=!0,k()))),r},e.unstable_shouldYield=N,e.unstable_wrapCallback=function(e){var t=d;return function(){var n=d;d=t;try{return e.apply(this,arguments)}finally{d=n}}}}(S)),S)),k.exports),t=g(),n=(C||(C=1,function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),E.exports=function(){if(I)return $;I=1;var e=g();function t(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function n(){}var r={d:{f:n,r:function(){throw Error(t(522))},D:n,C:n,L:n,m:n,X:n,S:n,M:n},p:0,findDOMNode:null},s=Symbol.for("react.portal"),a=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function i(e,t){return"font"===e?"":"string"==typeof t?"use-credentials"===t?t:"":void 0}return $.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=r,$.createPortal=function(e,n){var r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType)throw Error(t(299));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:s,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,n,null,r)},$.flushSync=function(e){var t=a.T,n=r.p;try{if(a.T=null,r.p=2,e)return e()}finally{a.T=t,r.p=n,r.d.f()}},$.preconnect=function(e,t){"string"==typeof e&&(t=t?"string"==typeof(t=t.crossOrigin)?"use-credentials"===t?t:"":void 0:null,r.d.C(e,t))},$.prefetchDNS=function(e){"string"==typeof e&&r.d.D(e)},$.preinit=function(e,t){if("string"==typeof e&&t&&"string"==typeof t.as){var n=t.as,s=i(n,t.crossOrigin),a="string"==typeof t.integrity?t.integrity:void 0,o="string"==typeof t.fetchPriority?t.fetchPriority:void 0;"style"===n?r.d.S(e,"string"==typeof t.precedence?t.precedence:void 0,{crossOrigin:s,integrity:a,fetchPriority:o}):"script"===n&&r.d.X(e,{crossOrigin:s,integrity:a,fetchPriority:o,nonce:"string"==typeof t.nonce?t.nonce:void 0})}},$.preinitModule=function(e,t){if("string"==typeof e)if("object"==typeof t&&null!==t){if(null==t.as||"script"===t.as){var n=i(t.as,t.crossOrigin);r.d.M(e,{crossOrigin:n,integrity:"string"==typeof t.integrity?t.integrity:void 0,nonce:"string"==typeof t.nonce?t.nonce:void 0})}}else null==t&&r.d.M(e)},$.preload=function(e,t){if("string"==typeof e&&"object"==typeof t&&null!==t&&"string"==typeof t.as){var n=t.as,s=i(n,t.crossOrigin);r.d.L(e,n,{crossOrigin:s,integrity:"string"==typeof t.integrity?t.integrity:void 0,nonce:"string"==typeof t.nonce?t.nonce:void 0,type:"string"==typeof t.type?t.type:void 0,fetchPriority:"string"==typeof t.fetchPriority?t.fetchPriority:void 0,referrerPolicy:"string"==typeof t.referrerPolicy?t.referrerPolicy:void 0,imageSrcSet:"string"==typeof t.imageSrcSet?t.imageSrcSet:void 0,imageSizes:"string"==typeof t.imageSizes?t.imageSizes:void 0,media:"string"==typeof t.media?t.media:void 0})}},$.preloadModule=function(e,t){if("string"==typeof e)if(t){var n=i(t.as,t.crossOrigin);r.d.m(e,{as:"string"==typeof t.as&&"script"!==t.as?t.as:void 0,crossOrigin:n,integrity:"string"==typeof t.integrity?t.integrity:void 0})}else r.d.m(e)},$.requestFormReset=function(e){r.d.r(e)},$.unstable_batchedUpdates=function(e,t){return e(t)},$.useFormState=function(e,t,n){return a.H.useFormState(e,t,n)},$.useFormStatus=function(){return a.H.useHostTransitionStatus()},$.version="19.1.0",$}()),E.exports);function r(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function s(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function a(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{!!(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function i(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&null!==(e=e.alternate)&&(t=e.memoizedState),null!==t)return t.dehydrated}return null}function o(e){if(a(e)!==e)throw Error(r(188))}function l(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e;for(e=e.child;null!==e;){if(null!==(t=l(e)))return t;e=e.sibling}return null}var u=Object.assign,c=Symbol.for("react.element"),h=Symbol.for("react.transitional.element"),d=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),f=Symbol.for("react.strict_mode"),m=Symbol.for("react.profiler"),b=Symbol.for("react.provider"),v=Symbol.for("react.consumer"),N=Symbol.for("react.context"),R=Symbol.for("react.forward_ref"),A=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),O=Symbol.for("react.memo"),D=Symbol.for("react.lazy"),F=Symbol.for("react.activity"),L=Symbol.for("react.memo_cache_sentinel"),z=Symbol.iterator;function M(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=z&&e[z]||e["@@iterator"])?e:null}var P=Symbol.for("react.client.reference");function B(e){if(null==e)return null;if("function"==typeof e)return e.$$typeof===P?null:e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case p:return"Fragment";case m:return"Profiler";case f:return"StrictMode";case A:return"Suspense";case _:return"SuspenseList";case F:return"Activity"}if("object"==typeof e)switch(e.$$typeof){case d:return"Portal";case N:return(e.displayName||"Context")+".Provider";case v:return(e._context.displayName||"Context")+".Consumer";case R:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case O:return null!==(t=e.displayName||null)?t:B(e.type)||"Memo";case D:t=e._payload,e=e._init;try{return B(e(t))}catch(n){}}return null}var U=Array.isArray,W=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,V=n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,G={pending:!1,data:null,method:null,action:null},H=[],j=-1;function q(e){return{current:e}}function K(e){0>j||(e.current=H[j],H[j]=null,j--)}function X(e,t){j++,H[j]=e.current,e.current=t}var Y=q(null),Q=q(null),J=q(null),Z=q(null);function ee(e,t){switch(X(J,t),X(Q,e),X(Y,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?dh(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)e=ph(t=dh(t),e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}K(Y),X(Y,e)}function te(){K(Y),K(Q),K(J)}function ne(e){null!==e.memoizedState&&X(Z,e);var t=Y.current,n=ph(t,e.type);t!==n&&(X(Q,e),X(Y,n))}function re(e){Q.current===e&&(K(Y),K(Q)),Z.current===e&&(K(Z),nd._currentValue=G)}var se=Object.prototype.hasOwnProperty,ae=e.unstable_scheduleCallback,ie=e.unstable_cancelCallback,oe=e.unstable_shouldYield,le=e.unstable_requestPaint,ue=e.unstable_now,ce=e.unstable_getCurrentPriorityLevel,he=e.unstable_ImmediatePriority,de=e.unstable_UserBlockingPriority,pe=e.unstable_NormalPriority,fe=e.unstable_LowPriority,ge=e.unstable_IdlePriority,me=e.log,be=e.unstable_setDisableYieldValue,ye=null,xe=null;function ve(e){if("function"==typeof me&&be(e),xe&&"function"==typeof xe.setStrictMode)try{xe.setStrictMode(ye,e)}catch(t){}}var we=Math.clz32?Math.clz32:function(e){return 0==(e>>>=0)?32:31-(ke(e)/Se|0)|0},ke=Math.log,Se=Math.LN2,Ie=256,Ce=4194304;function Te(e){var t=42&e;if(0!==t)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194048&e;case 4194304:case 8388608:case 16777216:case 33554432:return 62914560&e;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function Ne(e,t,n){var r=e.pendingLanes;if(0===r)return 0;var s=0,a=e.suspendedLanes,i=e.pingedLanes;e=e.warmLanes;var o=134217727&r;return 0!==o?0!=(r=o&~a)?s=Te(r):0!=(i&=o)?s=Te(i):n||0!=(n=o&~e)&&(s=Te(n)):0!=(o=r&~a)?s=Te(o):0!==i?s=Te(i):n||0!=(n=r&~e)&&(s=Te(n)),0===s?0:0===t||t===s||t&a||!((a=s&-s)>=(n=t&-t)||32===a&&4194048&n)?s:t}function Ee(e,t){return!(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)}function $e(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function Re(){var e=Ie;return!(4194048&(Ie<<=1))&&(Ie=256),e}function Ae(){var e=Ce;return!(62914560&(Ce<<=1))&&(Ce=4194304),e}function _e(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Oe(e,t){e.pendingLanes|=t,268435456!==t&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function De(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var r=31-we(t);e.entangledLanes|=t,e.entanglements[r]=1073741824|e.entanglements[r]|4194090&n}function Fe(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-we(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}function Le(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function ze(e){return 2<(e&=-e)?8<e?134217727&e?32:268435456:8:2}function Me(){var e=V.p;return 0!==e?e:void 0===(e=window.event)?32:bd(e.type)}var Pe=Math.random().toString(36).slice(2),Be="__reactFiber$"+Pe,Ue="__reactProps$"+Pe,We="__reactContainer$"+Pe,Ve="__reactEvents$"+Pe,Ge="__reactListeners$"+Pe,He="__reactHandles$"+Pe,je="__reactResources$"+Pe,qe="__reactMarker$"+Pe;function Ke(e){delete e[Be],delete e[Ue],delete e[Ve],delete e[Ge],delete e[He]}function Xe(e){var t=e[Be];if(t)return t;for(var n=e.parentNode;n;){if(t=n[We]||n[Be]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=Nh(e);null!==e;){if(n=e[Be])return n;e=Nh(e)}return t}n=(e=n).parentNode}return null}function Ye(e){if(e=e[Be]||e[We]){var t=e.tag;if(5===t||6===t||13===t||26===t||27===t||3===t)return e}return null}function Qe(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e.stateNode;throw Error(r(33))}function Je(e){var t=e[je];return t||(t=e[je]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function Ze(e){e[qe]=!0}var et=new Set,tt={};function nt(e,t){rt(e,t),rt(e+"Capture",t)}function rt(e,t){for(tt[e]=t,e=0;e<t.length;e++)et.add(t[e])}var st,at,it=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),ot={},lt={};function ut(e,t,n){if(s=t,se.call(lt,s)||!se.call(ot,s)&&(it.test(s)?lt[s]=!0:(ot[s]=!0,0)))if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":return void e.removeAttribute(t);case"boolean":var r=t.toLowerCase().slice(0,5);if("data-"!==r&&"aria-"!==r)return void e.removeAttribute(t)}e.setAttribute(t,""+n)}var s}function ct(e,t,n){if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(t)}e.setAttribute(t,""+n)}}function ht(e,t,n,r){if(null===r)e.removeAttribute(n);else{switch(typeof r){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(n)}e.setAttributeNS(t,n,""+r)}}function dt(e){if(void 0===st)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);st=t&&t[1]||"",at=-1<n.stack.indexOf("\n    at")?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return"\n"+st+e+at}var pt=!1;function ft(e,t){if(!e||pt)return"";pt=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var r={DetermineComponentFrameRoot:function(){try{if(t){var n=function(){throw Error()};if(Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(s){var r=s}Reflect.construct(e,[],n)}else{try{n.call()}catch(a){r=a}e.call(n.prototype)}}else{try{throw Error()}catch(i){r=i}(n=e())&&"function"==typeof n.catch&&n.catch((function(){}))}}catch(o){if(o&&r&&"string"==typeof o.stack)return[o.stack,r.stack]}return[null,null]}};r.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var s=Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot,"name");s&&s.configurable&&Object.defineProperty(r.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var a=r.DetermineComponentFrameRoot(),i=a[0],o=a[1];if(i&&o){var l=i.split("\n"),u=o.split("\n");for(s=r=0;r<l.length&&!l[r].includes("DetermineComponentFrameRoot");)r++;for(;s<u.length&&!u[s].includes("DetermineComponentFrameRoot");)s++;if(r===l.length||s===u.length)for(r=l.length-1,s=u.length-1;1<=r&&0<=s&&l[r]!==u[s];)s--;for(;1<=r&&0<=s;r--,s--)if(l[r]!==u[s]){if(1!==r||1!==s)do{if(r--,0>--s||l[r]!==u[s]){var c="\n"+l[r].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=r&&0<=s);break}}}finally{pt=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?dt(n):""}function gt(e){switch(e.tag){case 26:case 27:case 5:return dt(e.type);case 16:return dt("Lazy");case 13:return dt("Suspense");case 19:return dt("SuspenseList");case 0:case 15:return ft(e.type,!1);case 11:return ft(e.type.render,!1);case 1:return ft(e.type,!0);case 31:return dt("Activity");default:return""}}function mt(e){try{var t="";do{t+=gt(e),e=e.return}while(e);return t}catch(n){return"\nError generating stack: "+n.message+"\n"+n.stack}}function bt(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function yt(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function xt(e){e._valueTracker||(e._valueTracker=function(e){var t=yt(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){r=""+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function vt(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=yt(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function wt(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}var kt=/[\n"\\]/g;function St(e){return e.replace(kt,(function(e){return"\\"+e.charCodeAt(0).toString(16)+" "}))}function It(e,t,n,r,s,a,i,o){e.name="",null!=i&&"function"!=typeof i&&"symbol"!=typeof i&&"boolean"!=typeof i?e.type=i:e.removeAttribute("type"),null!=t?"number"===i?(0===t&&""===e.value||e.value!=t)&&(e.value=""+bt(t)):e.value!==""+bt(t)&&(e.value=""+bt(t)):"submit"!==i&&"reset"!==i||e.removeAttribute("value"),null!=t?Tt(e,i,bt(t)):null!=n?Tt(e,i,bt(n)):null!=r&&e.removeAttribute("value"),null==s&&null!=a&&(e.defaultChecked=!!a),null!=s&&(e.checked=s&&"function"!=typeof s&&"symbol"!=typeof s),null!=o&&"function"!=typeof o&&"symbol"!=typeof o&&"boolean"!=typeof o?e.name=""+bt(o):e.removeAttribute("name")}function Ct(e,t,n,r,s,a,i,o){if(null!=a&&"function"!=typeof a&&"symbol"!=typeof a&&"boolean"!=typeof a&&(e.type=a),null!=t||null!=n){if(("submit"===a||"reset"===a)&&null==t)return;n=null!=n?""+bt(n):"",t=null!=t?""+bt(t):n,o||t===e.value||(e.value=t),e.defaultValue=t}r="function"!=typeof(r=null!=r?r:s)&&"symbol"!=typeof r&&!!r,e.checked=o?e.checked:!!r,e.defaultChecked=!!r,null!=i&&"function"!=typeof i&&"symbol"!=typeof i&&"boolean"!=typeof i&&(e.name=i)}function Tt(e,t,n){"number"===t&&wt(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function Nt(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+bt(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(r&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function Et(e,t,n){null==t||((t=""+bt(t))!==e.value&&(e.value=t),null!=n)?e.defaultValue=null!=n?""+bt(n):"":e.defaultValue!==t&&(e.defaultValue=t)}function $t(e,t,n,s){if(null==t){if(null!=s){if(null!=n)throw Error(r(92));if(U(s)){if(1<s.length)throw Error(r(93));s=s[0]}n=s}null==n&&(n=""),t=n}n=bt(t),e.defaultValue=n,(s=e.textContent)===n&&""!==s&&null!==s&&(e.value=s)}function Rt(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var At=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function _t(e,t,n){var r=0===t.indexOf("--");null==n||"boolean"==typeof n||""===n?r?e.setProperty(t,""):"float"===t?e.cssFloat="":e[t]="":r?e.setProperty(t,n):"number"!=typeof n||0===n||At.has(t)?"float"===t?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function Ot(e,t,n){if(null!=t&&"object"!=typeof t)throw Error(r(62));if(e=e.style,null!=n){for(var s in n)!n.hasOwnProperty(s)||null!=t&&t.hasOwnProperty(s)||(0===s.indexOf("--")?e.setProperty(s,""):"float"===s?e.cssFloat="":e[s]="");for(var a in t)s=t[a],t.hasOwnProperty(a)&&n[a]!==s&&_t(e,a,s)}else for(var i in t)t.hasOwnProperty(i)&&_t(e,i,t[i])}function Dt(e){if(-1===e.indexOf("-"))return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Ft=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Lt=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function zt(e){return Lt.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var Mt=null;function Pt(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Bt=null,Ut=null;function Wt(e){var t=Ye(e);if(t&&(e=t.stateNode)){var n=e[Ue]||null;e:switch(e=t.stateNode,t.type){case"input":if(It(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+St(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var s=n[t];if(s!==e&&s.form===e.form){var a=s[Ue]||null;if(!a)throw Error(r(90));It(s,a.value,a.defaultValue,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name)}}for(t=0;t<n.length;t++)(s=n[t]).form===e.form&&vt(s)}break e;case"textarea":Et(e,n.value,n.defaultValue);break e;case"select":null!=(t=n.value)&&Nt(e,!!n.multiple,t,!1)}}}var Vt=!1;function Gt(e,t,n){if(Vt)return e(t,n);Vt=!0;try{return e(t)}finally{if(Vt=!1,(null!==Bt||null!==Ut)&&(Xu(),Bt&&(t=Bt,e=Ut,Ut=Bt=null,Wt(t),e)))for(t=0;t<e.length;t++)Wt(e[t])}}function Ht(e,t){var n=e.stateNode;if(null===n)return null;var s=n[Ue]||null;if(null===s)return null;n=s[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(s=!s.disabled)||(s=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!s;break e;default:e=!1}if(e)return null;if(n&&"function"!=typeof n)throw Error(r(231,t,typeof n));return n}var jt=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),qt=!1;if(jt)try{var Kt={};Object.defineProperty(Kt,"passive",{get:function(){qt=!0}}),window.addEventListener("test",Kt,Kt),window.removeEventListener("test",Kt,Kt)}catch(Ud){qt=!1}var Xt=null,Yt=null,Qt=null;function Jt(){if(Qt)return Qt;var e,t,n=Yt,r=n.length,s="value"in Xt?Xt.value:Xt.textContent,a=s.length;for(e=0;e<r&&n[e]===s[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===s[a-t];t++);return Qt=s.slice(e,1<t?1-t:void 0)}function Zt(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function en(){return!0}function tn(){return!1}function nn(e){function t(t,n,r,s,a){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=s,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?en:tn,this.isPropagationStopped=tn,this}return u(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=en)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=en)},persist:function(){},isPersistent:en}),t}var rn,sn,an,on={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},ln=nn(on),un=u({},on,{view:0,detail:0}),cn=nn(un),hn=u({},un,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:kn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==an&&(an&&"mousemove"===e.type?(rn=e.screenX-an.screenX,sn=e.screenY-an.screenY):sn=rn=0,an=e),rn)},movementY:function(e){return"movementY"in e?e.movementY:sn}}),dn=nn(hn),pn=nn(u({},hn,{dataTransfer:0})),fn=nn(u({},un,{relatedTarget:0})),gn=nn(u({},on,{animationName:0,elapsedTime:0,pseudoElement:0})),mn=nn(u({},on,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}})),bn=nn(u({},on,{data:0})),yn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},xn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},vn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function wn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=vn[e])&&!!t[e]}function kn(){return wn}var Sn=nn(u({},un,{key:function(e){if(e.key){var t=yn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=Zt(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?xn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:kn,charCode:function(e){return"keypress"===e.type?Zt(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?Zt(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}})),In=nn(u({},hn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Cn=nn(u({},un,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:kn})),Tn=nn(u({},on,{propertyName:0,elapsedTime:0,pseudoElement:0})),Nn=nn(u({},hn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0})),En=nn(u({},on,{newState:0,oldState:0})),$n=[9,13,27,32],Rn=jt&&"CompositionEvent"in window,An=null;jt&&"documentMode"in document&&(An=document.documentMode);var _n=jt&&"TextEvent"in window&&!An,On=jt&&(!Rn||An&&8<An&&11>=An),Dn=String.fromCharCode(32),Fn=!1;function Ln(e,t){switch(e){case"keyup":return-1!==$n.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function zn(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var Mn=!1,Pn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Bn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Pn[e.type]:"textarea"===t}function Un(e,t,n,r){Bt?Ut?Ut.push(r):Ut=[r]:Bt=r,0<(t=Jc(t,"onChange")).length&&(n=new ln("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Wn=null,Vn=null;function Gn(e){Gc(e,0)}function Hn(e){if(vt(Qe(e)))return e}function jn(e,t){if("change"===e)return t}var qn=!1;if(jt){var Kn;if(jt){var Xn="oninput"in document;if(!Xn){var Yn=document.createElement("div");Yn.setAttribute("oninput","return;"),Xn="function"==typeof Yn.oninput}Kn=Xn}else Kn=!1;qn=Kn&&(!document.documentMode||9<document.documentMode)}function Qn(){Wn&&(Wn.detachEvent("onpropertychange",Jn),Vn=Wn=null)}function Jn(e){if("value"===e.propertyName&&Hn(Vn)){var t=[];Un(t,Vn,e,Pt(e)),Gt(Gn,t)}}function Zn(e,t,n){"focusin"===e?(Qn(),Vn=n,(Wn=t).attachEvent("onpropertychange",Jn)):"focusout"===e&&Qn()}function er(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Hn(Vn)}function tr(e,t){if("click"===e)return Hn(t)}function nr(e,t){if("input"===e||"change"===e)return Hn(t)}var rr="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t};function sr(e,t){if(rr(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!se.call(t,s)||!rr(e[s],t[s]))return!1}return!0}function ar(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ir(e,t){var n,r=ar(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ar(r)}}function or(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?or(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function lr(e){for(var t=wt((e=null!=e&&null!=e.ownerDocument&&null!=e.ownerDocument.defaultView?e.ownerDocument.defaultView:window).document);t instanceof e.HTMLIFrameElement;){try{var n="string"==typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=wt((e=t.contentWindow).document)}return t}function ur(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var cr=jt&&"documentMode"in document&&11>=document.documentMode,hr=null,dr=null,pr=null,fr=!1;function gr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;fr||null==hr||hr!==wt(r)||(r="selectionStart"in(r=hr)&&ur(r)?{start:r.selectionStart,end:r.selectionEnd}:{anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},pr&&sr(pr,r)||(pr=r,0<(r=Jc(dr,"onSelect")).length&&(t=new ln("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=hr)))}function mr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var br={animationend:mr("Animation","AnimationEnd"),animationiteration:mr("Animation","AnimationIteration"),animationstart:mr("Animation","AnimationStart"),transitionrun:mr("Transition","TransitionRun"),transitionstart:mr("Transition","TransitionStart"),transitioncancel:mr("Transition","TransitionCancel"),transitionend:mr("Transition","TransitionEnd")},yr={},xr={};function vr(e){if(yr[e])return yr[e];if(!br[e])return e;var t,n=br[e];for(t in n)if(n.hasOwnProperty(t)&&t in xr)return yr[e]=n[t];return e}jt&&(xr=document.createElement("div").style,"AnimationEvent"in window||(delete br.animationend.animation,delete br.animationiteration.animation,delete br.animationstart.animation),"TransitionEvent"in window||delete br.transitionend.transition);var wr=vr("animationend"),kr=vr("animationiteration"),Sr=vr("animationstart"),Ir=vr("transitionrun"),Cr=vr("transitionstart"),Tr=vr("transitioncancel"),Nr=vr("transitionend"),Er=new Map,$r="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Rr(e,t){Er.set(e,t),nt(t,[e])}$r.push("scrollEnd");var Ar=new WeakMap;function _r(e,t){if("object"==typeof e&&null!==e){var n=Ar.get(e);return void 0!==n?n:(t={value:e,source:t,stack:mt(t)},Ar.set(e,t),t)}return{value:e,source:t,stack:mt(t)}}var Or=[],Dr=0,Fr=0;function Lr(){for(var e=Dr,t=Fr=Dr=0;t<e;){var n=Or[t];Or[t++]=null;var r=Or[t];Or[t++]=null;var s=Or[t];Or[t++]=null;var a=Or[t];if(Or[t++]=null,null!==r&&null!==s){var i=r.pending;null===i?s.next=s:(s.next=i.next,i.next=s),r.pending=s}0!==a&&Br(n,s,a)}}function zr(e,t,n,r){Or[Dr++]=e,Or[Dr++]=t,Or[Dr++]=n,Or[Dr++]=r,Fr|=r,e.lanes|=r,null!==(e=e.alternate)&&(e.lanes|=r)}function Mr(e,t,n,r){return zr(e,t,n,r),Ur(e)}function Pr(e,t){return zr(e,null,null,t),Ur(e)}function Br(e,t,n){e.lanes|=n;var r=e.alternate;null!==r&&(r.lanes|=n);for(var s=!1,a=e.return;null!==a;)a.childLanes|=n,null!==(r=a.alternate)&&(r.childLanes|=n),22===a.tag&&(null===(e=a.stateNode)||1&e._visibility||(s=!0)),e=a,a=a.return;return 3===e.tag?(a=e.stateNode,s&&null!==t&&(s=31-we(n),null===(r=(e=a.hiddenUpdates)[s])?e[s]=[t]:r.push(t),t.lane=536870912|n),a):null}function Ur(e){if(50<Bu)throw Bu=0,Uu=null,Error(r(185));for(var t=e.return;null!==t;)t=(e=t).return;return 3===e.tag?e.stateNode:null}var Wr={};function Vr(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Gr(e,t,n,r){return new Vr(e,t,n,r)}function Hr(e){return!(!(e=e.prototype)||!e.isReactComponent)}function jr(e,t){var n=e.alternate;return null===n?((n=Gr(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=65011712&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function qr(e,t){e.flags&=65011714;var n=e.alternate;return null===n?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function Kr(e,t,n,s,a,i){var o=0;if(s=e,"function"==typeof e)Hr(e)&&(o=1);else if("string"==typeof e)o=function(e,t,n){if(1===n||null!=t.itemProp)return!1;switch(e){case"meta":case"title":return!0;case"style":if("string"!=typeof t.precedence||"string"!=typeof t.href||""===t.href)break;return!0;case"link":if("string"!=typeof t.rel||"string"!=typeof t.href||""===t.href||t.onLoad||t.onError)break;return"stylesheet"!==t.rel||(e=t.disabled,"string"==typeof t.precedence&&null==e);case"script":if(t.async&&"function"!=typeof t.async&&"symbol"!=typeof t.async&&!t.onLoad&&!t.onError&&t.src&&"string"==typeof t.src)return!0}return!1}(e,n,Y.current)?26:"html"===e||"head"===e||"body"===e?27:5;else e:switch(e){case F:return(e=Gr(31,n,t,a)).elementType=F,e.lanes=i,e;case p:return Xr(n.children,a,i,t);case f:o=8,a|=24;break;case m:return(e=Gr(12,n,t,2|a)).elementType=m,e.lanes=i,e;case A:return(e=Gr(13,n,t,a)).elementType=A,e.lanes=i,e;case _:return(e=Gr(19,n,t,a)).elementType=_,e.lanes=i,e;default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case b:case N:o=10;break e;case v:o=9;break e;case R:o=11;break e;case O:o=14;break e;case D:o=16,s=null;break e}o=29,n=Error(r(130,null===e?"null":typeof e,"")),s=null}return(t=Gr(o,n,t,a)).elementType=e,t.type=s,t.lanes=i,t}function Xr(e,t,n,r){return(e=Gr(7,e,r,t)).lanes=n,e}function Yr(e,t,n){return(e=Gr(6,e,null,t)).lanes=n,e}function Qr(e,t,n){return(t=Gr(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var Jr=[],Zr=0,es=null,ts=0,ns=[],rs=0,ss=null,as=1,is="";function os(e,t){Jr[Zr++]=ts,Jr[Zr++]=es,es=e,ts=t}function ls(e,t,n){ns[rs++]=as,ns[rs++]=is,ns[rs++]=ss,ss=e;var r=as;e=is;var s=32-we(r)-1;r&=~(1<<s),n+=1;var a=32-we(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,as=1<<32-we(t)+s|n<<s|r,is=a+e}else as=1<<a|n<<s|r,is=e}function us(e){null!==e.return&&(os(e,1),ls(e,1,0))}function cs(e){for(;e===es;)es=Jr[--Zr],Jr[Zr]=null,ts=Jr[--Zr],Jr[Zr]=null;for(;e===ss;)ss=ns[--rs],ns[rs]=null,is=ns[--rs],ns[rs]=null,as=ns[--rs],ns[rs]=null}var hs=null,ds=null,ps=!1,fs=null,gs=!1,ms=Error(r(519));function bs(e){throw Ss(_r(Error(r(418,"")),e)),ms}function ys(e){var t=e.stateNode,n=e.type,r=e.memoizedProps;switch(t[Be]=e,t[Ue]=r,n){case"dialog":Hc("cancel",t),Hc("close",t);break;case"iframe":case"object":case"embed":Hc("load",t);break;case"video":case"audio":for(n=0;n<Wc.length;n++)Hc(Wc[n],t);break;case"source":Hc("error",t);break;case"img":case"image":case"link":Hc("error",t),Hc("load",t);break;case"details":Hc("toggle",t);break;case"input":Hc("invalid",t),Ct(t,r.value,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name,!0),xt(t);break;case"select":Hc("invalid",t);break;case"textarea":Hc("invalid",t),$t(t,r.value,r.defaultValue,r.children),xt(t)}"string"!=typeof(n=r.children)&&"number"!=typeof n&&"bigint"!=typeof n||t.textContent===""+n||!0===r.suppressHydrationWarning||sh(t.textContent,n)?(null!=r.popover&&(Hc("beforetoggle",t),Hc("toggle",t)),null!=r.onScroll&&Hc("scroll",t),null!=r.onScrollEnd&&Hc("scrollend",t),null!=r.onClick&&(t.onclick=ah),t=!0):t=!1,t||bs(e)}function xs(e){for(hs=e.return;hs;)switch(hs.tag){case 5:case 13:return void(gs=!1);case 27:case 3:return void(gs=!0);default:hs=hs.return}}function vs(e){if(e!==hs)return!1;if(!ps)return xs(e),ps=!0,!1;var t,n=e.tag;if((t=3!==n&&27!==n)&&((t=5===n)&&(t=!("form"!==(t=e.type)&&"button"!==t)||fh(e.type,e.memoizedProps)),t=!t),t&&ds&&bs(e),xs(e),13===n){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(r(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType)if("/$"===(t=e.data)){if(0===n){ds=Ch(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++;e=e.nextSibling}ds=null}}else 27===n?(n=ds,wh(e.type)?(e=Th,Th=null,ds=e):ds=n):ds=hs?Ch(e.stateNode.nextSibling):null;return!0}function ws(){ds=hs=null,ps=!1}function ks(){var e=fs;return null!==e&&(null===Nu?Nu=e:Nu.push.apply(Nu,e),fs=null),e}function Ss(e){null===fs?fs=[e]:fs.push(e)}var Is=q(null),Cs=null,Ts=null;function Ns(e,t,n){X(Is,t._currentValue),t._currentValue=n}function Es(e){e._currentValue=Is.current,K(Is)}function $s(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Rs(e,t,n,s){var a=e.child;for(null!==a&&(a.return=e);null!==a;){var i=a.dependencies;if(null!==i){var o=a.child;i=i.firstContext;e:for(;null!==i;){var l=i;i=a;for(var u=0;u<t.length;u++)if(l.context===t[u]){i.lanes|=n,null!==(l=i.alternate)&&(l.lanes|=n),$s(i.return,n,e),s||(o=null);break e}i=l.next}}else if(18===a.tag){if(null===(o=a.return))throw Error(r(341));o.lanes|=n,null!==(i=o.alternate)&&(i.lanes|=n),$s(o,n,e),o=null}else o=a.child;if(null!==o)o.return=a;else for(o=a;null!==o;){if(o===e){o=null;break}if(null!==(a=o.sibling)){a.return=o.return,o=a;break}o=o.return}a=o}}function As(e,t,n,s){e=null;for(var a=t,i=!1;null!==a;){if(!i)if(524288&a.flags)i=!0;else if(262144&a.flags)break;if(10===a.tag){var o=a.alternate;if(null===o)throw Error(r(387));if(null!==(o=o.memoizedProps)){var l=a.type;rr(a.pendingProps.value,o.value)||(null!==e?e.push(l):e=[l])}}else if(a===Z.current){if(null===(o=a.alternate))throw Error(r(387));o.memoizedState.memoizedState!==a.memoizedState.memoizedState&&(null!==e?e.push(nd):e=[nd])}a=a.return}null!==e&&Rs(t,e,n,s),t.flags|=262144}function _s(e){for(e=e.firstContext;null!==e;){if(!rr(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function Os(e){Cs=e,Ts=null,null!==(e=e.dependencies)&&(e.firstContext=null)}function Ds(e){return Ls(Cs,e)}function Fs(e,t){return null===Cs&&Os(e),Ls(e,t)}function Ls(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},null===Ts){if(null===e)throw Error(r(308));Ts=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else Ts=Ts.next=t;return n}var zs="undefined"!=typeof AbortController?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(t,n){e.push(n)}};this.abort=function(){t.aborted=!0,e.forEach((function(e){return e()}))}},Ms=e.unstable_scheduleCallback,Ps=e.unstable_NormalPriority,Bs={$$typeof:N,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Us(){return{controller:new zs,data:new Map,refCount:0}}function Ws(e){e.refCount--,0===e.refCount&&Ms(Ps,(function(){e.controller.abort()}))}var Vs=null,Gs=0,Hs=0,js=null;function qs(){if(0==--Gs&&null!==Vs){null!==js&&(js.status="fulfilled");var e=Vs;Vs=null,Hs=0,js=null;for(var t=0;t<e.length;t++)(0,e[t])()}}var Ks=W.S;W.S=function(e,t){"object"==typeof t&&null!==t&&"function"==typeof t.then&&function(e,t){if(null===Vs){var n=Vs=[];Gs=0,Hs=zc(),js={status:"pending",value:void 0,then:function(e){n.push(e)}}}Gs++,t.then(qs,qs)}(0,t),null!==Ks&&Ks(e,t)};var Xs=q(null);function Ys(){var e=Xs.current;return null!==e?e:hu.pooledCache}function Qs(e,t){X(Xs,null===t?Xs.current:t.pool)}function Js(){var e=Ys();return null===e?null:{parent:Bs._currentValue,pool:e}}var Zs=Error(r(460)),ea=Error(r(474)),ta=Error(r(542)),na={then:function(){}};function ra(e){return"fulfilled"===(e=e.status)||"rejected"===e}function sa(){}function aa(e,t,n){switch(void 0===(n=e[n])?e.push(t):n!==t&&(t.then(sa,sa),t=n),t.status){case"fulfilled":return t.value;case"rejected":throw la(e=t.reason),e;default:if("string"==typeof t.status)t.then(sa,sa);else{if(null!==(e=hu)&&100<e.shellSuspendCounter)throw Error(r(482));(e=t).status="pending",e.then((function(e){if("pending"===t.status){var n=t;n.status="fulfilled",n.value=e}}),(function(e){if("pending"===t.status){var n=t;n.status="rejected",n.reason=e}}))}switch(t.status){case"fulfilled":return t.value;case"rejected":throw la(e=t.reason),e}throw ia=t,Zs}}var ia=null;function oa(){if(null===ia)throw Error(r(459));var e=ia;return ia=null,e}function la(e){if(e===Zs||e===ta)throw Error(r(483))}var ua=!1;function ca(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ha(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function da(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function pa(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,2&cu){var s=r.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),r.pending=t,t=Ur(e),Br(e,null,n),t}return zr(e,r,t,n),Ur(e)}function fa(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,4194048&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Fe(e,n)}}function ga(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var s=null,a=null;if(null!==(n=n.firstBaseUpdate)){do{var i={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};null===a?s=a=i:a=a.next=i,n=n.next}while(null!==n);null===a?s=a=t:a=a.next=t}else s=a=t;return n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,callbacks:r.callbacks},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var ma=!1;function ba(){if(ma&&null!==js)throw js}function ya(e,t,n,r){ma=!1;var s=e.updateQueue;ua=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var l=o,c=l.next;l.next=null,null===i?a=c:i.next=c,i=l;var h=e.alternate;null!==h&&(o=(h=h.updateQueue).lastBaseUpdate)!==i&&(null===o?h.firstBaseUpdate=c:o.next=c,h.lastBaseUpdate=l)}if(null!==a){var d=s.baseState;for(i=0,h=c=l=null,o=a;;){var p=-536870913&o.lane,f=p!==o.lane;if(f?(pu&p)===p:(r&p)===p){0!==p&&p===Hs&&(ma=!0),null!==h&&(h=h.next={lane:0,tag:o.tag,payload:o.payload,callback:null,next:null});e:{var g=e,m=o;p=t;var b=n;switch(m.tag){case 1:if("function"==typeof(g=m.payload)){d=g.call(b,d,p);break e}d=g;break e;case 3:g.flags=-65537&g.flags|128;case 0:if(null==(p="function"==typeof(g=m.payload)?g.call(b,d,p):g))break e;d=u({},d,p);break e;case 2:ua=!0}}null!==(p=o.callback)&&(e.flags|=64,f&&(e.flags|=8192),null===(f=s.callbacks)?s.callbacks=[p]:f.push(p))}else f={lane:p,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===h?(c=h=f,l=d):h=h.next=f,i|=p;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(f=o).next,f.next=null,s.lastBaseUpdate=f,s.shared.pending=null}}null===h&&(l=d),s.baseState=l,s.firstBaseUpdate=c,s.lastBaseUpdate=h,null===a&&(s.shared.lanes=0),wu|=i,e.lanes=i,e.memoizedState=d}}function xa(e,t){if("function"!=typeof e)throw Error(r(191,e));e.call(t)}function va(e,t){var n=e.callbacks;if(null!==n)for(e.callbacks=null,e=0;e<n.length;e++)xa(n[e],t)}var wa=q(null),ka=q(0);function Sa(e,t){X(ka,e=xu),X(wa,t),xu=e|t.baseLanes}function Ia(){X(ka,xu),X(wa,wa.current)}function Ca(){xu=ka.current,K(wa),K(ka)}var Ta=0,Na=null,Ea=null,$a=null,Ra=!1,Aa=!1,_a=!1,Oa=0,Da=0,Fa=null,La=0;function za(){throw Error(r(321))}function Ma(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!rr(e[n],t[n]))return!1;return!0}function Pa(e,t,n,r,s,a){return Ta=a,Na=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,W.H=null===e||null===e.memoizedState?Zi:eo,_a=!1,a=n(r,s),_a=!1,Aa&&(a=Ua(t,n,r,s)),Ba(e),a}function Ba(e){W.H=Ji;var t=null!==Ea&&null!==Ea.next;if(Ta=0,$a=Ea=Na=null,Ra=!1,Da=0,Fa=null,t)throw Error(r(300));null===e||Fo||null!==(e=e.dependencies)&&_s(e)&&(Fo=!0)}function Ua(e,t,n,s){Na=e;var a=0;do{if(Aa&&(Fa=null),Da=0,Aa=!1,25<=a)throw Error(r(301));if(a+=1,$a=Ea=null,null!=e.updateQueue){var i=e.updateQueue;i.lastEffect=null,i.events=null,i.stores=null,null!=i.memoCache&&(i.memoCache.index=0)}W.H=to,i=t(n,s)}while(Aa);return i}function Wa(){var e=W.H,t=e.useState()[0];return t="function"==typeof t.then?Ka(t):t,e=e.useState()[0],(null!==Ea?Ea.memoizedState:null)!==e&&(Na.flags|=1024),t}function Va(){var e=0!==Oa;return Oa=0,e}function Ga(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function Ha(e){if(Ra){for(e=e.memoizedState;null!==e;){var t=e.queue;null!==t&&(t.pending=null),e=e.next}Ra=!1}Ta=0,$a=Ea=Na=null,Aa=!1,Da=Oa=0,Fa=null}function ja(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===$a?Na.memoizedState=$a=e:$a=$a.next=e,$a}function qa(){if(null===Ea){var e=Na.alternate;e=null!==e?e.memoizedState:null}else e=Ea.next;var t=null===$a?Na.memoizedState:$a.next;if(null!==t)$a=t,Ea=e;else{if(null===e){if(null===Na.alternate)throw Error(r(467));throw Error(r(310))}e={memoizedState:(Ea=e).memoizedState,baseState:Ea.baseState,baseQueue:Ea.baseQueue,queue:Ea.queue,next:null},null===$a?Na.memoizedState=$a=e:$a=$a.next=e}return $a}function Ka(e){var t=Da;return Da+=1,null===Fa&&(Fa=[]),e=aa(Fa,e,t),t=Na,null===(null===$a?t.memoizedState:$a.next)&&(t=t.alternate,W.H=null===t||null===t.memoizedState?Zi:eo),e}function Xa(e){if(null!==e&&"object"==typeof e){if("function"==typeof e.then)return Ka(e);if(e.$$typeof===N)return Ds(e)}throw Error(r(438,String(e)))}function Ya(e){var t=null,n=Na.updateQueue;if(null!==n&&(t=n.memoCache),null==t){var r=Na.alternate;null!==r&&null!==(r=r.updateQueue)&&null!=(r=r.memoCache)&&(t={data:r.data.map((function(e){return e.slice()})),index:0})}if(null==t&&(t={data:[],index:0}),null===n&&(n={lastEffect:null,events:null,stores:null,memoCache:null},Na.updateQueue=n),n.memoCache=t,void 0===(n=t.data[t.index]))for(n=t.data[t.index]=Array(e),r=0;r<e;r++)n[r]=L;return t.index++,n}function Qa(e,t){return"function"==typeof t?t(e):t}function Ja(e){return Za(qa(),Ea,e)}function Za(e,t,n){var s=e.queue;if(null===s)throw Error(r(311));s.lastRenderedReducer=n;var a=e.baseQueue,i=s.pending;if(null!==i){if(null!==a){var o=a.next;a.next=i.next,i.next=o}t.baseQueue=a=i,s.pending=null}if(i=e.baseState,null===a)e.memoizedState=i;else{var l=o=null,u=null,c=t=a.next,h=!1;do{var d=-536870913&c.lane;if(d!==c.lane?(pu&d)===d:(Ta&d)===d){var p=c.revertLane;if(0===p)null!==u&&(u=u.next={lane:0,revertLane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),d===Hs&&(h=!0);else{if((Ta&p)===p){c=c.next,p===Hs&&(h=!0);continue}d={lane:0,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=d,o=i):u=u.next=d,Na.lanes|=p,wu|=p}d=c.action,_a&&n(i,d),i=c.hasEagerState?c.eagerState:n(i,d)}else p={lane:d,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=p,o=i):u=u.next=p,Na.lanes|=d,wu|=d;c=c.next}while(null!==c&&c!==t);if(null===u?o=i:u.next=l,!rr(i,e.memoizedState)&&(Fo=!0,h&&null!==(n=js)))throw n;e.memoizedState=i,e.baseState=o,e.baseQueue=u,s.lastRenderedState=i}return null===a&&(s.lanes=0),[e.memoizedState,s.dispatch]}function ei(e){var t=qa(),n=t.queue;if(null===n)throw Error(r(311));n.lastRenderedReducer=e;var s=n.dispatch,a=n.pending,i=t.memoizedState;if(null!==a){n.pending=null;var o=a=a.next;do{i=e(i,o.action),o=o.next}while(o!==a);rr(i,t.memoizedState)||(Fo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,s]}function ti(e,t,n){var s=Na,a=qa(),i=ps;if(i){if(void 0===n)throw Error(r(407));n=n()}else n=t();var o=!rr((Ea||a).memoizedState,n);if(o&&(a.memoizedState=n,Fo=!0),a=a.queue,Ii(2048,8,si.bind(null,s,a,e),[e]),a.getSnapshot!==t||o||null!==$a&&1&$a.memoizedState.tag){if(s.flags|=2048,wi(9,{destroy:void 0,resource:void 0},ri.bind(null,s,a,n,t),null),null===hu)throw Error(r(349));i||124&Ta||ni(s,t,n)}return n}function ni(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=Na.updateQueue)?(t={lastEffect:null,events:null,stores:null,memoCache:null},Na.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function ri(e,t,n,r){t.value=n,t.getSnapshot=r,ai(t)&&ii(e)}function si(e,t,n){return n((function(){ai(t)&&ii(e)}))}function ai(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!rr(e,n)}catch(r){return!0}}function ii(e){var t=Pr(e,2);null!==t&&Gu(t,0,2)}function oi(e){var t=ja();if("function"==typeof e){var n=e;if(e=n(),_a){ve(!0);try{n()}finally{ve(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Qa,lastRenderedState:e},t}function li(e,t,n,r){return e.baseState=n,Za(e,Ea,"function"==typeof r?r:Qa)}function ui(e,t,n,s,a){if(Xi(e))throw Error(r(485));if(null!==(e=t.action)){var i={payload:a,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(e){i.listeners.push(e)}};null!==W.T?n(!0):i.isTransition=!1,s(i),null===(n=t.pending)?(i.next=t.pending=i,ci(t,i)):(i.next=n.next,t.pending=n.next=i)}}function ci(e,t){var n=t.action,r=t.payload,s=e.state;if(t.isTransition){var a=W.T,i={};W.T=i;try{var o=n(s,r),l=W.S;null!==l&&l(i,o),hi(e,t,o)}catch(u){pi(e,t,u)}finally{W.T=a}}else try{hi(e,t,a=n(s,r))}catch(c){pi(e,t,c)}}function hi(e,t,n){null!==n&&"object"==typeof n&&"function"==typeof n.then?n.then((function(n){di(e,t,n)}),(function(n){return pi(e,t,n)})):di(e,t,n)}function di(e,t,n){t.status="fulfilled",t.value=n,fi(t),e.state=n,null!==(t=e.pending)&&((n=t.next)===t?e.pending=null:(n=n.next,t.next=n,ci(e,n)))}function pi(e,t,n){var r=e.pending;if(e.pending=null,null!==r){r=r.next;do{t.status="rejected",t.reason=n,fi(t),t=t.next}while(t!==r)}e.action=null}function fi(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function gi(e,t){return t}function mi(e,t){if(ps){var n=hu.formState;if(null!==n){e:{var r=Na;if(ps){if(ds){t:{for(var s=ds,a=gs;8!==s.nodeType;){if(!a){s=null;break t}if(null===(s=Ch(s.nextSibling))){s=null;break t}}s="F!"===(a=s.data)||"F"===a?s:null}if(s){ds=Ch(s.nextSibling),r="F!"===s.data;break e}}bs(r)}r=!1}r&&(t=n[0])}}return(n=ja()).memoizedState=n.baseState=t,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:gi,lastRenderedState:t},n.queue=r,n=ji.bind(null,Na,r),r.dispatch=n,r=oi(!1),a=Ki.bind(null,Na,!1,r.queue),s={state:t,dispatch:null,action:e,pending:null},(r=ja()).queue=s,n=ui.bind(null,Na,s,a,n),s.dispatch=n,r.memoizedState=e,[t,n,!1]}function bi(e){return yi(qa(),Ea,e)}function yi(e,t,n){if(t=Za(e,t,gi)[0],e=Ja(Qa)[0],"object"==typeof t&&null!==t&&"function"==typeof t.then)try{var r=Ka(t)}catch(i){if(i===Zs)throw ta;throw i}else r=t;var s=(t=qa()).queue,a=s.dispatch;return n!==t.memoizedState&&(Na.flags|=2048,wi(9,{destroy:void 0,resource:void 0},xi.bind(null,s,n),null)),[r,a,e]}function xi(e,t){e.action=t}function vi(e){var t=qa(),n=Ea;if(null!==n)return yi(t,n,e);qa(),t=t.memoizedState;var r=(n=qa()).queue.dispatch;return n.memoizedState=e,[t,r,!1]}function wi(e,t,n,r){return e={tag:e,create:n,deps:r,inst:t,next:null},null===(t=Na.updateQueue)&&(t={lastEffect:null,events:null,stores:null,memoCache:null},Na.updateQueue=t),null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function ki(){return qa().memoizedState}function Si(e,t,n,r){var s=ja();r=void 0===r?null:r,Na.flags|=e,s.memoizedState=wi(1|t,{destroy:void 0,resource:void 0},n,r)}function Ii(e,t,n,r){var s=qa();r=void 0===r?null:r;var a=s.memoizedState.inst;null!==Ea&&null!==r&&Ma(r,Ea.memoizedState.deps)?s.memoizedState=wi(t,a,n,r):(Na.flags|=e,s.memoizedState=wi(1|t,a,n,r))}function Ci(e,t){Si(8390656,8,e,t)}function Ti(e,t){Ii(2048,8,e,t)}function Ni(e,t){return Ii(4,2,e,t)}function Ei(e,t){return Ii(4,4,e,t)}function $i(e,t){if("function"==typeof t){e=e();var n=t(e);return function(){"function"==typeof n?n():t(null)}}if(null!=t)return e=e(),t.current=e,function(){t.current=null}}function Ri(e,t,n){n=null!=n?n.concat([e]):null,Ii(4,4,$i.bind(null,t,e),n)}function Ai(){}function _i(e,t){var n=qa();t=void 0===t?null:t;var r=n.memoizedState;return null!==t&&Ma(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Oi(e,t){var n=qa();t=void 0===t?null:t;var r=n.memoizedState;if(null!==t&&Ma(t,r[1]))return r[0];if(r=e(),_a){ve(!0);try{e()}finally{ve(!1)}}return n.memoizedState=[r,t],r}function Di(e,t,n){return void 0===n||1073741824&Ta?e.memoizedState=t:(e.memoizedState=n,e=Vu(),Na.lanes|=e,wu|=e,n)}function Fi(e,t,n,r){return rr(n,t)?n:null!==wa.current?(e=Di(e,n,r),rr(e,t)||(Fo=!0),e):42&Ta?(e=Vu(),Na.lanes|=e,wu|=e,t):(Fo=!0,e.memoizedState=n)}function Li(e,t,n,r,s){var a=V.p;V.p=0!==a&&8>a?a:8;var i,o,l,u=W.T,c={};W.T=c,Ki(e,!1,t,n);try{var h=s(),d=W.S;null!==d&&d(c,h),null!==h&&"object"==typeof h&&"function"==typeof h.then?qi(e,t,(i=r,o=[],l={status:"pending",value:null,reason:null,then:function(e){o.push(e)}},h.then((function(){l.status="fulfilled",l.value=i;for(var e=0;e<o.length;e++)(0,o[e])(i)}),(function(e){for(l.status="rejected",l.reason=e,e=0;e<o.length;e++)(0,o[e])(void 0)})),l),Wu()):qi(e,t,r,Wu())}catch(p){qi(e,t,{then:function(){},status:"rejected",reason:p},Wu())}finally{V.p=a,W.T=u}}function zi(){}function Mi(e,t,n,s){if(5!==e.tag)throw Error(r(476));var a=Pi(e).queue;Li(e,a,t,G,null===n?zi:function(){return Bi(e),n(s)})}function Pi(e){var t=e.memoizedState;if(null!==t)return t;var n={};return(t={memoizedState:G,baseState:G,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Qa,lastRenderedState:G},next:null}).next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Qa,lastRenderedState:n},next:null},e.memoizedState=t,null!==(e=e.alternate)&&(e.memoizedState=t),t}function Bi(e){qi(e,Pi(e).next.queue,{},Wu())}function Ui(){return Ds(nd)}function Wi(){return qa().memoizedState}function Vi(){return qa().memoizedState}function Gi(e){for(var t=e.return;null!==t;){switch(t.tag){case 24:case 3:var n=Wu(),r=pa(t,e=da(n),n);return null!==r&&(Gu(r,0,n),fa(r,t,n)),t={cache:Us()},void(e.payload=t)}t=t.return}}function Hi(e,t,n){var r=Wu();n={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null},Xi(e)?Yi(t,n):null!==(n=Mr(e,t,n,r))&&(Gu(n,0,r),Qi(n,t,r))}function ji(e,t,n){qi(e,t,n,Wu())}function qi(e,t,n,r){var s={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null};if(Xi(e))Yi(t,s);else{var a=e.alternate;if(0===e.lanes&&(null===a||0===a.lanes)&&null!==(a=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,rr(o,i))return zr(e,t,s,0),null===hu&&Lr(),!1}catch(l){}if(null!==(n=Mr(e,t,s,r)))return Gu(n,0,r),Qi(n,t,r),!0}return!1}function Ki(e,t,n,s){if(s={lane:2,revertLane:zc(),action:s,hasEagerState:!1,eagerState:null,next:null},Xi(e)){if(t)throw Error(r(479))}else null!==(t=Mr(e,n,s,2))&&Gu(t,0,2)}function Xi(e){var t=e.alternate;return e===Na||null!==t&&t===Na}function Yi(e,t){Aa=Ra=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Qi(e,t,n){if(4194048&n){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Fe(e,n)}}var Ji={readContext:Ds,use:Xa,useCallback:za,useContext:za,useEffect:za,useImperativeHandle:za,useLayoutEffect:za,useInsertionEffect:za,useMemo:za,useReducer:za,useRef:za,useState:za,useDebugValue:za,useDeferredValue:za,useTransition:za,useSyncExternalStore:za,useId:za,useHostTransitionStatus:za,useFormState:za,useActionState:za,useOptimistic:za,useMemoCache:za,useCacheRefresh:za},Zi={readContext:Ds,use:Xa,useCallback:function(e,t){return ja().memoizedState=[e,void 0===t?null:t],e},useContext:Ds,useEffect:Ci,useImperativeHandle:function(e,t,n){n=null!=n?n.concat([e]):null,Si(4194308,4,$i.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Si(4194308,4,e,t)},useInsertionEffect:function(e,t){Si(4,2,e,t)},useMemo:function(e,t){var n=ja();t=void 0===t?null:t;var r=e();if(_a){ve(!0);try{e()}finally{ve(!1)}}return n.memoizedState=[r,t],r},useReducer:function(e,t,n){var r=ja();if(void 0!==n){var s=n(t);if(_a){ve(!0);try{n(t)}finally{ve(!1)}}}else s=t;return r.memoizedState=r.baseState=s,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:s},r.queue=e,e=e.dispatch=Hi.bind(null,Na,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},ja().memoizedState=e},useState:function(e){var t=(e=oi(e)).queue,n=ji.bind(null,Na,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:Ai,useDeferredValue:function(e,t){return Di(ja(),e,t)},useTransition:function(){var e=oi(!1);return e=Li.bind(null,Na,e.queue,!0,!1),ja().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var s=Na,a=ja();if(ps){if(void 0===n)throw Error(r(407));n=n()}else{if(n=t(),null===hu)throw Error(r(349));124&pu||ni(s,t,n)}a.memoizedState=n;var i={value:n,getSnapshot:t};return a.queue=i,Ci(si.bind(null,s,i,e),[e]),s.flags|=2048,wi(9,{destroy:void 0,resource:void 0},ri.bind(null,s,i,n,t),null),n},useId:function(){var e=ja(),t=hu.identifierPrefix;if(ps){var n=is;t="«"+t+"R"+(n=(as&~(1<<32-we(as)-1)).toString(32)+n),0<(n=Oa++)&&(t+="H"+n.toString(32)),t+="»"}else t="«"+t+"r"+(n=La++).toString(32)+"»";return e.memoizedState=t},useHostTransitionStatus:Ui,useFormState:mi,useActionState:mi,useOptimistic:function(e){var t=ja();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=Ki.bind(null,Na,!0,n),n.dispatch=t,[e,t]},useMemoCache:Ya,useCacheRefresh:function(){return ja().memoizedState=Gi.bind(null,Na)}},eo={readContext:Ds,use:Xa,useCallback:_i,useContext:Ds,useEffect:Ti,useImperativeHandle:Ri,useInsertionEffect:Ni,useLayoutEffect:Ei,useMemo:Oi,useReducer:Ja,useRef:ki,useState:function(){return Ja(Qa)},useDebugValue:Ai,useDeferredValue:function(e,t){return Fi(qa(),Ea.memoizedState,e,t)},useTransition:function(){var e=Ja(Qa)[0],t=qa().memoizedState;return["boolean"==typeof e?e:Ka(e),t]},useSyncExternalStore:ti,useId:Wi,useHostTransitionStatus:Ui,useFormState:bi,useActionState:bi,useOptimistic:function(e,t){return li(qa(),0,e,t)},useMemoCache:Ya,useCacheRefresh:Vi},to={readContext:Ds,use:Xa,useCallback:_i,useContext:Ds,useEffect:Ti,useImperativeHandle:Ri,useInsertionEffect:Ni,useLayoutEffect:Ei,useMemo:Oi,useReducer:ei,useRef:ki,useState:function(){return ei(Qa)},useDebugValue:Ai,useDeferredValue:function(e,t){var n=qa();return null===Ea?Di(n,e,t):Fi(n,Ea.memoizedState,e,t)},useTransition:function(){var e=ei(Qa)[0],t=qa().memoizedState;return["boolean"==typeof e?e:Ka(e),t]},useSyncExternalStore:ti,useId:Wi,useHostTransitionStatus:Ui,useFormState:vi,useActionState:vi,useOptimistic:function(e,t){var n=qa();return null!==Ea?li(n,0,e,t):(n.baseState=e,[e,n.queue.dispatch])},useMemoCache:Ya,useCacheRefresh:Vi},no=null,ro=0;function so(e){var t=ro;return ro+=1,null===no&&(no=[]),aa(no,e,t)}function ao(e,t){t=t.props.ref,e.ref=void 0!==t?t:null}function io(e,t){if(t.$$typeof===c)throw Error(r(525));throw e=Object.prototype.toString.call(t),Error(r(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function oo(e){return(0,e._init)(e._payload)}function lo(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function s(e){for(var t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function a(e,t){return(e=jr(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=67108866,n):r:(t.flags|=67108866,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=67108866),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Yr(n,e.mode,r)).return=e,t):((t=a(t,n)).return=e,t)}function u(e,t,n,r){var s=n.type;return s===p?f(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===s||"object"==typeof s&&null!==s&&s.$$typeof===D&&oo(s)===t.type)?(ao(t=a(t,n.props),n),t.return=e,t):(ao(t=Kr(n.type,n.key,n.props,null,e.mode,r),n),t.return=e,t)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Qr(n,e.mode,r)).return=e,t):((t=a(t,n.children||[])).return=e,t)}function f(e,t,n,r,s){return null===t||7!==t.tag?((t=Xr(n,e.mode,r,s)).return=e,t):((t=a(t,n)).return=e,t)}function g(e,t,n){if("string"==typeof t&&""!==t||"number"==typeof t||"bigint"==typeof t)return(t=Yr(""+t,e.mode,n)).return=e,t;if("object"==typeof t&&null!==t){switch(t.$$typeof){case h:return ao(n=Kr(t.type,t.key,t.props,null,e.mode,n),t),n.return=e,n;case d:return(t=Qr(t,e.mode,n)).return=e,t;case D:return g(e,t=(0,t._init)(t._payload),n)}if(U(t)||M(t))return(t=Xr(t,e.mode,n,null)).return=e,t;if("function"==typeof t.then)return g(e,so(t),n);if(t.$$typeof===N)return g(e,Fs(e,t),n);io(e,t)}return null}function m(e,t,n,r){var s=null!==t?t.key:null;if("string"==typeof n&&""!==n||"number"==typeof n||"bigint"==typeof n)return null!==s?null:l(e,t,""+n,r);if("object"==typeof n&&null!==n){switch(n.$$typeof){case h:return n.key===s?u(e,t,n,r):null;case d:return n.key===s?c(e,t,n,r):null;case D:return m(e,t,n=(s=n._init)(n._payload),r)}if(U(n)||M(n))return null!==s?null:f(e,t,n,r,null);if("function"==typeof n.then)return m(e,t,so(n),r);if(n.$$typeof===N)return m(e,t,Fs(e,n),r);io(e,n)}return null}function b(e,t,n,r,s){if("string"==typeof r&&""!==r||"number"==typeof r||"bigint"==typeof r)return l(t,e=e.get(n)||null,""+r,s);if("object"==typeof r&&null!==r){switch(r.$$typeof){case h:return u(t,e=e.get(null===r.key?n:r.key)||null,r,s);case d:return c(t,e=e.get(null===r.key?n:r.key)||null,r,s);case D:return b(e,t,n,r=(0,r._init)(r._payload),s)}if(U(r)||M(r))return f(t,e=e.get(n)||null,r,s,null);if("function"==typeof r.then)return b(e,t,n,so(r),s);if(r.$$typeof===N)return b(e,t,n,Fs(t,r),s);io(t,r)}return null}function y(l,u,c,f){if("object"==typeof c&&null!==c&&c.type===p&&null===c.key&&(c=c.props.children),"object"==typeof c&&null!==c){switch(c.$$typeof){case h:e:{for(var x=c.key;null!==u;){if(u.key===x){if((x=c.type)===p){if(7===u.tag){n(l,u.sibling),(f=a(u,c.props.children)).return=l,l=f;break e}}else if(u.elementType===x||"object"==typeof x&&null!==x&&x.$$typeof===D&&oo(x)===u.type){n(l,u.sibling),ao(f=a(u,c.props),c),f.return=l,l=f;break e}n(l,u);break}t(l,u),u=u.sibling}c.type===p?((f=Xr(c.props.children,l.mode,f,c.key)).return=l,l=f):(ao(f=Kr(c.type,c.key,c.props,null,l.mode,f),c),f.return=l,l=f)}return o(l);case d:e:{for(x=c.key;null!==u;){if(u.key===x){if(4===u.tag&&u.stateNode.containerInfo===c.containerInfo&&u.stateNode.implementation===c.implementation){n(l,u.sibling),(f=a(u,c.children||[])).return=l,l=f;break e}n(l,u);break}t(l,u),u=u.sibling}(f=Qr(c,l.mode,f)).return=l,l=f}return o(l);case D:return y(l,u,c=(x=c._init)(c._payload),f)}if(U(c))return function(r,a,o,l){for(var u=null,c=null,h=a,d=a=0,p=null;null!==h&&d<o.length;d++){h.index>d?(p=h,h=null):p=h.sibling;var f=m(r,h,o[d],l);if(null===f){null===h&&(h=p);break}e&&h&&null===f.alternate&&t(r,h),a=i(f,a,d),null===c?u=f:c.sibling=f,c=f,h=p}if(d===o.length)return n(r,h),ps&&os(r,d),u;if(null===h){for(;d<o.length;d++)null!==(h=g(r,o[d],l))&&(a=i(h,a,d),null===c?u=h:c.sibling=h,c=h);return ps&&os(r,d),u}for(h=s(h);d<o.length;d++)null!==(p=b(h,r,d,o[d],l))&&(e&&null!==p.alternate&&h.delete(null===p.key?d:p.key),a=i(p,a,d),null===c?u=p:c.sibling=p,c=p);return e&&h.forEach((function(e){return t(r,e)})),ps&&os(r,d),u}(l,u,c,f);if(M(c)){if("function"!=typeof(x=M(c)))throw Error(r(150));return function(a,o,l,u){if(null==l)throw Error(r(151));for(var c=null,h=null,d=o,p=o=0,f=null,y=l.next();null!==d&&!y.done;p++,y=l.next()){d.index>p?(f=d,d=null):f=d.sibling;var x=m(a,d,y.value,u);if(null===x){null===d&&(d=f);break}e&&d&&null===x.alternate&&t(a,d),o=i(x,o,p),null===h?c=x:h.sibling=x,h=x,d=f}if(y.done)return n(a,d),ps&&os(a,p),c;if(null===d){for(;!y.done;p++,y=l.next())null!==(y=g(a,y.value,u))&&(o=i(y,o,p),null===h?c=y:h.sibling=y,h=y);return ps&&os(a,p),c}for(d=s(d);!y.done;p++,y=l.next())null!==(y=b(d,a,p,y.value,u))&&(e&&null!==y.alternate&&d.delete(null===y.key?p:y.key),o=i(y,o,p),null===h?c=y:h.sibling=y,h=y);return e&&d.forEach((function(e){return t(a,e)})),ps&&os(a,p),c}(l,u,c=x.call(c),f)}if("function"==typeof c.then)return y(l,u,so(c),f);if(c.$$typeof===N)return y(l,u,Fs(l,c),f);io(l,c)}return"string"==typeof c&&""!==c||"number"==typeof c||"bigint"==typeof c?(c=""+c,null!==u&&6===u.tag?(n(l,u.sibling),(f=a(u,c)).return=l,l=f):(n(l,u),(f=Yr(c,l.mode,f)).return=l,l=f),o(l)):n(l,u)}return function(e,t,n,r){try{ro=0;var s=y(e,t,n,r);return no=null,s}catch(i){if(i===Zs||i===ta)throw i;var a=Gr(29,i,null,e.mode);return a.lanes=r,a.return=e,a}}}var uo=lo(!0),co=lo(!1),ho=q(null),po=null;function fo(e){var t=e.alternate;X(yo,1&yo.current),X(ho,e),null===po&&(null===t||null!==wa.current||null!==t.memoizedState)&&(po=e)}function go(e){if(22===e.tag){if(X(yo,yo.current),X(ho,e),null===po){var t=e.alternate;null!==t&&null!==t.memoizedState&&(po=e)}}else mo()}function mo(){X(yo,yo.current),X(ho,ho.current)}function bo(e){K(ho),po===e&&(po=null),K(yo)}var yo=q(0);function xo(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||Ih(n)))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(128&t.flags)return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}function vo(e,t,n,r){n=null==(n=n(r,t=e.memoizedState))?t:u({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var wo={enqueueSetState:function(e,t,n){e=e._reactInternals;var r=Wu(),s=da(r);s.payload=t,null!=n&&(s.callback=n),null!==(t=pa(e,s,r))&&(Gu(t,0,r),fa(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=Wu(),s=da(r);s.tag=1,s.payload=t,null!=n&&(s.callback=n),null!==(t=pa(e,s,r))&&(Gu(t,0,r),fa(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Wu(),r=da(n);r.tag=2,null!=t&&(r.callback=t),null!==(t=pa(e,r,n))&&(Gu(t,0,n),fa(t,e,n))}};function ko(e,t,n,r,s,a,i){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,a,i):!(t.prototype&&t.prototype.isPureReactComponent&&sr(n,r)&&sr(s,a))}function So(e,t,n,r){e=t.state,"function"==typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"==typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&wo.enqueueReplaceState(t,t.state,null)}function Io(e,t){var n=t;if("ref"in t)for(var r in n={},t)"ref"!==r&&(n[r]=t[r]);if(e=e.defaultProps)for(var s in n===t&&(n=u({},n)),e)void 0===n[s]&&(n[s]=e[s]);return n}var Co="function"==typeof reportError?reportError:function(e){if("object"==typeof window&&"function"==typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"==typeof e&&null!==e&&"string"==typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"==typeof process&&"function"==typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function To(e){Co(e)}function No(e){console.error(e)}function Eo(e){Co(e)}function $o(e,t){try{(0,e.onUncaughtError)(t.value,{componentStack:t.stack})}catch(n){setTimeout((function(){throw n}))}}function Ro(e,t,n){try{(0,e.onCaughtError)(n.value,{componentStack:n.stack,errorBoundary:1===t.tag?t.stateNode:null})}catch(r){setTimeout((function(){throw r}))}}function Ao(e,t,n){return(n=da(n)).tag=3,n.payload={element:null},n.callback=function(){$o(e,t)},n}function _o(e){return(e=da(e)).tag=3,e}function Oo(e,t,n,r){var s=n.type.getDerivedStateFromError;if("function"==typeof s){var a=r.value;e.payload=function(){return s(a)},e.callback=function(){Ro(t,n,r)}}var i=n.stateNode;null!==i&&"function"==typeof i.componentDidCatch&&(e.callback=function(){Ro(t,n,r),"function"!=typeof s&&(null===_u?_u=new Set([this]):_u.add(this));var e=r.stack;this.componentDidCatch(r.value,{componentStack:null!==e?e:""})})}var Do=Error(r(461)),Fo=!1;function Lo(e,t,n,r){t.child=null===e?co(t,null,n,r):uo(t,e.child,n,r)}function zo(e,t,n,r,s){n=n.render;var a=t.ref;if("ref"in r){var i={};for(var o in r)"ref"!==o&&(i[o]=r[o])}else i=r;return Os(t),r=Pa(e,t,n,i,a,s),o=Va(),null===e||Fo?(ps&&o&&us(t),t.flags|=1,Lo(e,t,r,s),t.child):(Ga(e,t,s),rl(e,t,s))}function Mo(e,t,n,r,s){if(null===e){var a=n.type;return"function"!=typeof a||Hr(a)||void 0!==a.defaultProps||null!==n.compare?((e=Kr(n.type,null,r,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=a,Po(e,t,a,r,s))}if(a=e.child,!sl(e,s)){var i=a.memoizedProps;if((n=null!==(n=n.compare)?n:sr)(i,r)&&e.ref===t.ref)return rl(e,t,s)}return t.flags|=1,(e=jr(a,r)).ref=t.ref,e.return=t,t.child=e}function Po(e,t,n,r,s){if(null!==e){var a=e.memoizedProps;if(sr(a,r)&&e.ref===t.ref){if(Fo=!1,t.pendingProps=r=a,!sl(e,s))return t.lanes=e.lanes,rl(e,t,s);131072&e.flags&&(Fo=!0)}}return Vo(e,t,n,r,s)}function Bo(e,t,n){var r=t.pendingProps,s=r.children,a=null!==e?e.memoizedState:null;if("hidden"===r.mode){if(128&t.flags){if(r=null!==a?a.baseLanes|n:n,null!==e){for(s=t.child=e.child,a=0;null!==s;)a=a|s.lanes|s.childLanes,s=s.sibling;t.childLanes=a&~r}else t.childLanes=0,t.child=null;return Uo(e,t,r,n)}if(!(536870912&n))return t.lanes=t.childLanes=536870912,Uo(e,t,null!==a?a.baseLanes|n:n,n);t.memoizedState={baseLanes:0,cachePool:null},null!==e&&Qs(0,null!==a?a.cachePool:null),null!==a?Sa(t,a):Ia(),go(t)}else null!==a?(Qs(0,a.cachePool),Sa(t,a),mo(),t.memoizedState=null):(null!==e&&Qs(0,null),Ia(),mo());return Lo(e,t,s,n),t.child}function Uo(e,t,n,r){var s=Ys();return s=null===s?null:{parent:Bs._currentValue,pool:s},t.memoizedState={baseLanes:n,cachePool:s},null!==e&&Qs(0,null),Ia(),go(t),null!==e&&As(e,t,r,!0),null}function Wo(e,t){var n=t.ref;if(null===n)null!==e&&null!==e.ref&&(t.flags|=4194816);else{if("function"!=typeof n&&"object"!=typeof n)throw Error(r(284));null!==e&&e.ref===n||(t.flags|=4194816)}}function Vo(e,t,n,r,s){return Os(t),n=Pa(e,t,n,r,void 0,s),r=Va(),null===e||Fo?(ps&&r&&us(t),t.flags|=1,Lo(e,t,n,s),t.child):(Ga(e,t,s),rl(e,t,s))}function Go(e,t,n,r,s,a){return Os(t),t.updateQueue=null,n=Ua(t,r,n,s),Ba(e),r=Va(),null===e||Fo?(ps&&r&&us(t),t.flags|=1,Lo(e,t,n,a),t.child):(Ga(e,t,a),rl(e,t,a))}function Ho(e,t,n,r,s){if(Os(t),null===t.stateNode){var a=Wr,i=n.contextType;"object"==typeof i&&null!==i&&(a=Ds(i)),a=new n(r,a),t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,a.updater=wo,t.stateNode=a,a._reactInternals=t,(a=t.stateNode).props=r,a.state=t.memoizedState,a.refs={},ca(t),i=n.contextType,a.context="object"==typeof i&&null!==i?Ds(i):Wr,a.state=t.memoizedState,"function"==typeof(i=n.getDerivedStateFromProps)&&(vo(t,n,i,r),a.state=t.memoizedState),"function"==typeof n.getDerivedStateFromProps||"function"==typeof a.getSnapshotBeforeUpdate||"function"!=typeof a.UNSAFE_componentWillMount&&"function"!=typeof a.componentWillMount||(i=a.state,"function"==typeof a.componentWillMount&&a.componentWillMount(),"function"==typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),i!==a.state&&wo.enqueueReplaceState(a,a.state,null),ya(t,r,a,s),ba(),a.state=t.memoizedState),"function"==typeof a.componentDidMount&&(t.flags|=4194308),r=!0}else if(null===e){a=t.stateNode;var o=t.memoizedProps,l=Io(n,o);a.props=l;var u=a.context,c=n.contextType;i=Wr,"object"==typeof c&&null!==c&&(i=Ds(c));var h=n.getDerivedStateFromProps;c="function"==typeof h||"function"==typeof a.getSnapshotBeforeUpdate,o=t.pendingProps!==o,c||"function"!=typeof a.UNSAFE_componentWillReceiveProps&&"function"!=typeof a.componentWillReceiveProps||(o||u!==i)&&So(t,a,r,i),ua=!1;var d=t.memoizedState;a.state=d,ya(t,r,a,s),ba(),u=t.memoizedState,o||d!==u||ua?("function"==typeof h&&(vo(t,n,h,r),u=t.memoizedState),(l=ua||ko(t,n,l,r,d,u,i))?(c||"function"!=typeof a.UNSAFE_componentWillMount&&"function"!=typeof a.componentWillMount||("function"==typeof a.componentWillMount&&a.componentWillMount(),"function"==typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount()),"function"==typeof a.componentDidMount&&(t.flags|=4194308)):("function"==typeof a.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=u),a.props=r,a.state=u,a.context=i,r=l):("function"==typeof a.componentDidMount&&(t.flags|=4194308),r=!1)}else{a=t.stateNode,ha(e,t),c=Io(n,i=t.memoizedProps),a.props=c,h=t.pendingProps,d=a.context,u=n.contextType,l=Wr,"object"==typeof u&&null!==u&&(l=Ds(u)),(u="function"==typeof(o=n.getDerivedStateFromProps)||"function"==typeof a.getSnapshotBeforeUpdate)||"function"!=typeof a.UNSAFE_componentWillReceiveProps&&"function"!=typeof a.componentWillReceiveProps||(i!==h||d!==l)&&So(t,a,r,l),ua=!1,d=t.memoizedState,a.state=d,ya(t,r,a,s),ba();var p=t.memoizedState;i!==h||d!==p||ua||null!==e&&null!==e.dependencies&&_s(e.dependencies)?("function"==typeof o&&(vo(t,n,o,r),p=t.memoizedState),(c=ua||ko(t,n,c,r,d,p,l)||null!==e&&null!==e.dependencies&&_s(e.dependencies))?(u||"function"!=typeof a.UNSAFE_componentWillUpdate&&"function"!=typeof a.componentWillUpdate||("function"==typeof a.componentWillUpdate&&a.componentWillUpdate(r,p,l),"function"==typeof a.UNSAFE_componentWillUpdate&&a.UNSAFE_componentWillUpdate(r,p,l)),"function"==typeof a.componentDidUpdate&&(t.flags|=4),"function"==typeof a.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!=typeof a.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!=typeof a.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=p),a.props=r,a.state=p,a.context=l,r=c):("function"!=typeof a.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!=typeof a.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),r=!1)}return a=r,Wo(e,t),r=!!(128&t.flags),a||r?(a=t.stateNode,n=r&&"function"!=typeof n.getDerivedStateFromError?null:a.render(),t.flags|=1,null!==e&&r?(t.child=uo(t,e.child,null,s),t.child=uo(t,null,n,s)):Lo(e,t,n,s),t.memoizedState=a.state,e=t.child):e=rl(e,t,s),e}function jo(e,t,n,r){return ws(),t.flags|=256,Lo(e,t,n,r),t.child}var qo={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Ko(e){return{baseLanes:e,cachePool:Js()}}function Xo(e,t,n){return e=null!==e?e.childLanes&~n:0,t&&(e|=Iu),e}function Yo(e,t,n){var s,a=t.pendingProps,i=!1,o=!!(128&t.flags);if((s=o)||(s=(null===e||null!==e.memoizedState)&&!!(2&yo.current)),s&&(i=!0,t.flags&=-129),s=!!(32&t.flags),t.flags&=-33,null===e){if(ps){if(i?fo(t):mo(),ps){var l,u=ds;if(l=u){e:{for(l=u,u=gs;8!==l.nodeType;){if(!u){u=null;break e}if(null===(l=Ch(l.nextSibling))){u=null;break e}}u=l}null!==u?(t.memoizedState={dehydrated:u,treeContext:null!==ss?{id:as,overflow:is}:null,retryLane:536870912,hydrationErrors:null},(l=Gr(18,null,null,0)).stateNode=u,l.return=t,t.child=l,hs=t,ds=null,l=!0):l=!1}l||bs(t)}if(null!==(u=t.memoizedState)&&null!==(u=u.dehydrated))return Ih(u)?t.lanes=32:t.lanes=536870912,null;bo(t)}return u=a.children,a=a.fallback,i?(mo(),u=Jo({mode:"hidden",children:u},i=t.mode),a=Xr(a,i,n,null),u.return=t,a.return=t,u.sibling=a,t.child=u,(i=t.child).memoizedState=Ko(n),i.childLanes=Xo(e,s,n),t.memoizedState=qo,a):(fo(t),Qo(t,u))}if(null!==(l=e.memoizedState)&&null!==(u=l.dehydrated)){if(o)256&t.flags?(fo(t),t.flags&=-257,t=Zo(e,t,n)):null!==t.memoizedState?(mo(),t.child=e.child,t.flags|=128,t=null):(mo(),i=a.fallback,u=t.mode,a=Jo({mode:"visible",children:a.children},u),(i=Xr(i,u,n,null)).flags|=2,a.return=t,i.return=t,a.sibling=i,t.child=a,uo(t,e.child,null,n),(a=t.child).memoizedState=Ko(n),a.childLanes=Xo(e,s,n),t.memoizedState=qo,t=i);else if(fo(t),Ih(u)){if(s=u.nextSibling&&u.nextSibling.dataset)var c=s.dgst;s=c,(a=Error(r(419))).stack="",a.digest=s,Ss({value:a,source:null,stack:null}),t=Zo(e,t,n)}else if(Fo||As(e,t,n,!1),s=!!(n&e.childLanes),Fo||s){if(null!==(s=hu)&&0!==(a=(a=42&(a=n&-n)?1:Le(a))&(s.suspendedLanes|n)?0:a)&&a!==l.retryLane)throw l.retryLane=a,Pr(e,a),Gu(s,0,a),Do;"$?"===u.data||tc(),t=Zo(e,t,n)}else"$?"===u.data?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,ds=Ch(u.nextSibling),hs=t,ps=!0,fs=null,gs=!1,null!==e&&(ns[rs++]=as,ns[rs++]=is,ns[rs++]=ss,as=e.id,is=e.overflow,ss=t),(t=Qo(t,a.children)).flags|=4096);return t}return i?(mo(),i=a.fallback,u=t.mode,c=(l=e.child).sibling,(a=jr(l,{mode:"hidden",children:a.children})).subtreeFlags=65011712&l.subtreeFlags,null!==c?i=jr(c,i):(i=Xr(i,u,n,null)).flags|=2,i.return=t,a.return=t,a.sibling=i,t.child=a,a=i,i=t.child,null===(u=e.child.memoizedState)?u=Ko(n):(null!==(l=u.cachePool)?(c=Bs._currentValue,l=l.parent!==c?{parent:c,pool:c}:l):l=Js(),u={baseLanes:u.baseLanes|n,cachePool:l}),i.memoizedState=u,i.childLanes=Xo(e,s,n),t.memoizedState=qo,a):(fo(t),e=(n=e.child).sibling,(n=jr(n,{mode:"visible",children:a.children})).return=t,n.sibling=null,null!==e&&(null===(s=t.deletions)?(t.deletions=[e],t.flags|=16):s.push(e)),t.child=n,t.memoizedState=null,n)}function Qo(e,t){return(t=Jo({mode:"visible",children:t},e.mode)).return=e,e.child=t}function Jo(e,t){return(e=Gr(22,e,null,t)).lanes=0,e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},e}function Zo(e,t,n){return uo(t,e.child,null,n),(e=Qo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function el(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),$s(e.return,t,n)}function tl(e,t,n,r,s){var a=e.memoizedState;null===a?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function nl(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(Lo(e,t,r.children,n),2&(r=yo.current))r=1&r|2,t.flags|=128;else{if(null!==e&&128&e.flags)e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&el(e,n,t);else if(19===e.tag)el(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}switch(X(yo,r),s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===xo(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),tl(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===xo(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}tl(t,!0,n,null,a);break;case"together":tl(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function rl(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),wu|=t.lanes,!(n&t.childLanes)){if(null===e)return null;if(As(e,t,n,!1),!(n&t.childLanes))return null}if(null!==e&&t.child!==e.child)throw Error(r(153));if(null!==t.child){for(n=jr(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=jr(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function sl(e,t){return!!(e.lanes&t)||!(null===(e=e.dependencies)||!_s(e))}function al(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps)Fo=!0;else{if(!(sl(e,n)||128&t.flags))return Fo=!1,function(e,t,n){switch(t.tag){case 3:ee(t,t.stateNode.containerInfo),Ns(0,Bs,e.memoizedState.cache),ws();break;case 27:case 5:ne(t);break;case 4:ee(t,t.stateNode.containerInfo);break;case 10:Ns(0,t.type,t.memoizedProps.value);break;case 13:var r=t.memoizedState;if(null!==r)return null!==r.dehydrated?(fo(t),t.flags|=128,null):n&t.child.childLanes?Yo(e,t,n):(fo(t),null!==(e=rl(e,t,n))?e.sibling:null);fo(t);break;case 19:var s=!!(128&e.flags);if((r=!!(n&t.childLanes))||(As(e,t,n,!1),r=!!(n&t.childLanes)),s){if(r)return nl(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),X(yo,yo.current),r)break;return null;case 22:case 23:return t.lanes=0,Bo(e,t,n);case 24:Ns(0,Bs,e.memoizedState.cache)}return rl(e,t,n)}(e,t,n);Fo=!!(131072&e.flags)}else Fo=!1,ps&&1048576&t.flags&&ls(t,ts,t.index);switch(t.lanes=0,t.tag){case 16:e:{e=t.pendingProps;var s=t.elementType,a=s._init;if(s=a(s._payload),t.type=s,"function"!=typeof s){if(null!=s){if((a=s.$$typeof)===R){t.tag=11,t=zo(null,t,s,e,n);break e}if(a===O){t.tag=14,t=Mo(null,t,s,e,n);break e}}throw t=B(s)||s,Error(r(306,t,""))}Hr(s)?(e=Io(s,e),t.tag=1,t=Ho(null,t,s,e,n)):(t.tag=0,t=Vo(null,t,s,e,n))}return t;case 0:return Vo(e,t,t.type,t.pendingProps,n);case 1:return Ho(e,t,s=t.type,a=Io(s,t.pendingProps),n);case 3:e:{if(ee(t,t.stateNode.containerInfo),null===e)throw Error(r(387));s=t.pendingProps;var i=t.memoizedState;a=i.element,ha(e,t),ya(t,s,null,n);var o=t.memoizedState;if(s=o.cache,Ns(0,Bs,s),s!==i.cache&&Rs(t,[Bs],n,!0),ba(),s=o.element,i.isDehydrated){if(i={element:s,isDehydrated:!1,cache:o.cache},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=jo(e,t,s,n);break e}if(s!==a){Ss(a=_r(Error(r(424)),t)),t=jo(e,t,s,n);break e}for(e=9===(e=t.stateNode.containerInfo).nodeType?e.body:"HTML"===e.nodeName?e.ownerDocument.body:e,ds=Ch(e.firstChild),hs=t,ps=!0,fs=null,gs=!0,n=co(t,null,s,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ws(),s===a){t=rl(e,t,n);break e}Lo(e,t,s,n)}t=t.child}return t;case 26:return Wo(e,t),null===e?(n=Lh(t.type,null,t.pendingProps,null))?t.memoizedState=n:ps||(n=t.type,e=t.pendingProps,(s=hh(J.current).createElement(n))[Be]=t,s[Ue]=e,lh(s,n,e),Ze(s),t.stateNode=s):t.memoizedState=Lh(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return ne(t),null===e&&ps&&(s=t.stateNode=Eh(t.type,t.pendingProps,J.current),hs=t,gs=!0,a=ds,wh(t.type)?(Th=a,ds=Ch(s.firstChild)):ds=a),Lo(e,t,t.pendingProps.children,n),Wo(e,t),null===e&&(t.flags|=4194304),t.child;case 5:return null===e&&ps&&((a=s=ds)&&(null!==(s=function(e,t,n,r){for(;1===e.nodeType;){var s=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!r&&("INPUT"!==e.nodeName||"hidden"!==e.type))break}else if(r){if(!e[qe])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if("stylesheet"===(a=e.getAttribute("rel"))&&e.hasAttribute("data-precedence"))break;if(a!==s.rel||e.getAttribute("href")!==(null==s.href||""===s.href?null:s.href)||e.getAttribute("crossorigin")!==(null==s.crossOrigin?null:s.crossOrigin)||e.getAttribute("title")!==(null==s.title?null:s.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(((a=e.getAttribute("src"))!==(null==s.src?null:s.src)||e.getAttribute("type")!==(null==s.type?null:s.type)||e.getAttribute("crossorigin")!==(null==s.crossOrigin?null:s.crossOrigin))&&a&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else{if("input"!==t||"hidden"!==e.type)return e;var a=null==s.name?null:""+s.name;if("hidden"===s.type&&e.getAttribute("name")===a)return e}if(null===(e=Ch(e.nextSibling)))break}return null}(s,t.type,t.pendingProps,gs))?(t.stateNode=s,hs=t,ds=Ch(s.firstChild),gs=!1,a=!0):a=!1),a||bs(t)),ne(t),a=t.type,i=t.pendingProps,o=null!==e?e.memoizedProps:null,s=i.children,fh(a,i)?s=null:null!==o&&fh(a,o)&&(t.flags|=32),null!==t.memoizedState&&(a=Pa(e,t,Wa,null,null,n),nd._currentValue=a),Wo(e,t),Lo(e,t,s,n),t.child;case 6:return null===e&&ps&&((e=n=ds)&&(null!==(n=function(e,t,n){if(""===t)return null;for(;3!==e.nodeType;){if((1!==e.nodeType||"INPUT"!==e.nodeName||"hidden"!==e.type)&&!n)return null;if(null===(e=Ch(e.nextSibling)))return null}return e}(n,t.pendingProps,gs))?(t.stateNode=n,hs=t,ds=null,e=!0):e=!1),e||bs(t)),null;case 13:return Yo(e,t,n);case 4:return ee(t,t.stateNode.containerInfo),s=t.pendingProps,null===e?t.child=uo(t,null,s,n):Lo(e,t,s,n),t.child;case 11:return zo(e,t,t.type,t.pendingProps,n);case 7:return Lo(e,t,t.pendingProps,n),t.child;case 8:case 12:return Lo(e,t,t.pendingProps.children,n),t.child;case 10:return s=t.pendingProps,Ns(0,t.type,s.value),Lo(e,t,s.children,n),t.child;case 9:return a=t.type._context,s=t.pendingProps.children,Os(t),s=s(a=Ds(a)),t.flags|=1,Lo(e,t,s,n),t.child;case 14:return Mo(e,t,t.type,t.pendingProps,n);case 15:return Po(e,t,t.type,t.pendingProps,n);case 19:return nl(e,t,n);case 31:return s=t.pendingProps,n=t.mode,s={mode:s.mode,children:s.children},null===e?((n=Jo(s,n)).ref=t.ref,t.child=n,n.return=t,t=n):((n=jr(e.child,s)).ref=t.ref,t.child=n,n.return=t,t=n),t;case 22:return Bo(e,t,n);case 24:return Os(t),s=Ds(Bs),null===e?(null===(a=Ys())&&(a=hu,i=Us(),a.pooledCache=i,i.refCount++,null!==i&&(a.pooledCacheLanes|=n),a=i),t.memoizedState={parent:s,cache:a},ca(t),Ns(0,Bs,a)):(!!(e.lanes&n)&&(ha(e,t),ya(t,null,null,n),ba()),a=e.memoizedState,i=t.memoizedState,a.parent!==s?(a={parent:s,cache:s},t.memoizedState=a,0===t.lanes&&(t.memoizedState=t.updateQueue.baseState=a),Ns(0,Bs,s)):(s=i.cache,Ns(0,Bs,s),s!==a.cache&&Rs(t,[Bs],n,!0))),Lo(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(r(156,t.tag))}function il(e){e.flags|=4}function ol(e,t){if("stylesheet"!==t.type||4&t.state.loading)e.flags&=-16777217;else if(e.flags|=16777216,!Xh(t)){if(null!==(t=ho.current)&&((4194048&pu)===pu?null!==po:(62914560&pu)!==pu&&!(536870912&pu)||t!==po))throw ia=na,ea;e.flags|=8192}}function ll(e,t){null!==t&&(e.flags|=4),16384&e.flags&&(t=22!==e.tag?Ae():536870912,e.lanes|=t,Cu|=t)}function ul(e,t){if(!ps)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function cl(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=65011712&s.subtreeFlags,r|=65011712&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function hl(e,t,n){var s=t.pendingProps;switch(cs(t),t.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:case 1:return cl(t),null;case 3:return n=t.stateNode,s=null,null!==e&&(s=e.memoizedState.cache),t.memoizedState.cache!==s&&(t.flags|=2048),Es(Bs),te(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||(vs(t)?il(t):null===e||e.memoizedState.isDehydrated&&!(256&t.flags)||(t.flags|=1024,ks())),cl(t),null;case 26:return n=t.memoizedState,null===e?(il(t),null!==n?(cl(t),ol(t,n)):(cl(t),t.flags&=-16777217)):n?n!==e.memoizedState?(il(t),cl(t),ol(t,n)):(cl(t),t.flags&=-16777217):(e.memoizedProps!==s&&il(t),cl(t),t.flags&=-16777217),null;case 27:re(t),n=J.current;var a=t.type;if(null!==e&&null!=t.stateNode)e.memoizedProps!==s&&il(t);else{if(!s){if(null===t.stateNode)throw Error(r(166));return cl(t),null}e=Y.current,vs(t)?ys(t):(e=Eh(a,s,n),t.stateNode=e,il(t))}return cl(t),null;case 5:if(re(t),n=t.type,null!==e&&null!=t.stateNode)e.memoizedProps!==s&&il(t);else{if(!s){if(null===t.stateNode)throw Error(r(166));return cl(t),null}if(e=Y.current,vs(t))ys(t);else{switch(a=hh(J.current),e){case 1:e=a.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:e=a.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":e=a.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":e=a.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":(e=a.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e="string"==typeof s.is?a.createElement("select",{is:s.is}):a.createElement("select"),s.multiple?e.multiple=!0:s.size&&(e.size=s.size);break;default:e="string"==typeof s.is?a.createElement(n,{is:s.is}):a.createElement(n)}}e[Be]=t,e[Ue]=s;e:for(a=t.child;null!==a;){if(5===a.tag||6===a.tag)e.appendChild(a.stateNode);else if(4!==a.tag&&27!==a.tag&&null!==a.child){a.child.return=a,a=a.child;continue}if(a===t)break e;for(;null===a.sibling;){if(null===a.return||a.return===t)break e;a=a.return}a.sibling.return=a.return,a=a.sibling}t.stateNode=e;e:switch(lh(e,n,s),n){case"button":case"input":case"select":case"textarea":e=!!s.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&il(t)}}return cl(t),t.flags&=-16777217,null;case 6:if(e&&null!=t.stateNode)e.memoizedProps!==s&&il(t);else{if("string"!=typeof s&&null===t.stateNode)throw Error(r(166));if(e=J.current,vs(t)){if(e=t.stateNode,n=t.memoizedProps,s=null,null!==(a=hs))switch(a.tag){case 27:case 5:s=a.memoizedProps}e[Be]=t,(e=!!(e.nodeValue===n||null!==s&&!0===s.suppressHydrationWarning||sh(e.nodeValue,n)))||bs(t)}else(e=hh(e).createTextNode(s))[Be]=t,t.stateNode=e}return cl(t),null;case 13:if(s=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(a=vs(t),null!==s&&null!==s.dehydrated){if(null===e){if(!a)throw Error(r(318));if(!(a=null!==(a=t.memoizedState)?a.dehydrated:null))throw Error(r(317));a[Be]=t}else ws(),!(128&t.flags)&&(t.memoizedState=null),t.flags|=4;cl(t),a=!1}else a=ks(),null!==e&&null!==e.memoizedState&&(e.memoizedState.hydrationErrors=a),a=!0;if(!a)return 256&t.flags?(bo(t),t):(bo(t),null)}if(bo(t),128&t.flags)return t.lanes=n,t;if(n=null!==s,e=null!==e&&null!==e.memoizedState,n){a=null,null!==(s=t.child).alternate&&null!==s.alternate.memoizedState&&null!==s.alternate.memoizedState.cachePool&&(a=s.alternate.memoizedState.cachePool.pool);var i=null;null!==s.memoizedState&&null!==s.memoizedState.cachePool&&(i=s.memoizedState.cachePool.pool),i!==a&&(s.flags|=2048)}return n!==e&&n&&(t.child.flags|=8192),ll(t,t.updateQueue),cl(t),null;case 4:return te(),null===e&&Kc(t.stateNode.containerInfo),cl(t),null;case 10:return Es(t.type),cl(t),null;case 19:if(K(yo),null===(a=t.memoizedState))return cl(t),null;if(s=!!(128&t.flags),null===(i=a.rendering))if(s)ul(a,!1);else{if(0!==vu||null!==e&&128&e.flags)for(e=t.child;null!==e;){if(null!==(i=xo(e))){for(t.flags|=128,ul(a,!1),e=i.updateQueue,t.updateQueue=e,ll(t,e),t.subtreeFlags=0,e=n,n=t.child;null!==n;)qr(n,e),n=n.sibling;return X(yo,1&yo.current|2),t.child}e=e.sibling}null!==a.tail&&ue()>Ru&&(t.flags|=128,s=!0,ul(a,!1),t.lanes=4194304)}else{if(!s)if(null!==(e=xo(i))){if(t.flags|=128,s=!0,e=e.updateQueue,t.updateQueue=e,ll(t,e),ul(a,!0),null===a.tail&&"hidden"===a.tailMode&&!i.alternate&&!ps)return cl(t),null}else 2*ue()-a.renderingStartTime>Ru&&536870912!==n&&(t.flags|=128,s=!0,ul(a,!1),t.lanes=4194304);a.isBackwards?(i.sibling=t.child,t.child=i):(null!==(e=a.last)?e.sibling=i:t.child=i,a.last=i)}return null!==a.tail?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=ue(),t.sibling=null,e=yo.current,X(yo,s?1&e|2:1&e),t):(cl(t),null);case 22:case 23:return bo(t),Ca(),s=null!==t.memoizedState,null!==e?null!==e.memoizedState!==s&&(t.flags|=8192):s&&(t.flags|=8192),s?!!(536870912&n)&&!(128&t.flags)&&(cl(t),6&t.subtreeFlags&&(t.flags|=8192)):cl(t),null!==(n=t.updateQueue)&&ll(t,n.retryQueue),n=null,null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),s=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(s=t.memoizedState.cachePool.pool),s!==n&&(t.flags|=2048),null!==e&&K(Xs),null;case 24:return n=null,null!==e&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),Es(Bs),cl(t),null;case 25:case 30:return null}throw Error(r(156,t.tag))}function dl(e,t){switch(cs(t),t.tag){case 1:return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Es(Bs),te(),65536&(e=t.flags)&&!(128&e)?(t.flags=-65537&e|128,t):null;case 26:case 27:case 5:return re(t),null;case 13:if(bo(t),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(r(340));ws()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return K(yo),null;case 4:return te(),null;case 10:return Es(t.type),null;case 22:case 23:return bo(t),Ca(),null!==e&&K(Xs),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 24:return Es(Bs),null;default:return null}}function pl(e,t){switch(cs(t),t.tag){case 3:Es(Bs),te();break;case 26:case 27:case 5:re(t);break;case 4:te();break;case 13:bo(t);break;case 19:K(yo);break;case 10:Es(t.type);break;case 22:case 23:bo(t),Ca(),null!==e&&K(Xs);break;case 24:Es(Bs)}}function fl(e,t){try{var n=t.updateQueue,r=null!==n?n.lastEffect:null;if(null!==r){var s=r.next;n=s;do{if((n.tag&e)===e){r=void 0;var a=n.create,i=n.inst;r=a(),i.destroy=r}n=n.next}while(n!==s)}}catch(o){yc(t,t.return,o)}}function gl(e,t,n){try{var r=t.updateQueue,s=null!==r?r.lastEffect:null;if(null!==s){var a=s.next;r=a;do{if((r.tag&e)===e){var i=r.inst,o=i.destroy;if(void 0!==o){i.destroy=void 0,s=t;var l=n,u=o;try{u()}catch(c){yc(s,l,c)}}}r=r.next}while(r!==a)}}catch(c){yc(t,t.return,c)}}function ml(e){var t=e.updateQueue;if(null!==t){var n=e.stateNode;try{va(t,n)}catch(r){yc(e,e.return,r)}}}function bl(e,t,n){n.props=Io(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(r){yc(e,t,r)}}function yl(e,t){try{var n=e.ref;if(null!==n){switch(e.tag){case 26:case 27:case 5:var r=e.stateNode;break;default:r=e.stateNode}"function"==typeof n?e.refCleanup=n(r):n.current=r}}catch(s){yc(e,t,s)}}function xl(e,t){var n=e.ref,r=e.refCleanup;if(null!==n)if("function"==typeof r)try{r()}catch(s){yc(e,t,s)}finally{e.refCleanup=null,null!=(e=e.alternate)&&(e.refCleanup=null)}else if("function"==typeof n)try{n(null)}catch(a){yc(e,t,a)}else n.current=null}function vl(e){var t=e.type,n=e.memoizedProps,r=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&r.focus();break e;case"img":n.src?r.src=n.src:n.srcSet&&(r.srcset=n.srcSet)}}catch(s){yc(e,e.return,s)}}function wl(e,t,n){try{var s=e.stateNode;!function(e,t,n,s){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var a=null,i=null,o=null,l=null,u=null,c=null,h=null;for(f in n){var d=n[f];if(n.hasOwnProperty(f)&&null!=d)switch(f){case"checked":case"value":break;case"defaultValue":u=d;default:s.hasOwnProperty(f)||ih(e,t,f,null,s,d)}}for(var p in s){var f=s[p];if(d=n[p],s.hasOwnProperty(p)&&(null!=f||null!=d))switch(p){case"type":i=f;break;case"name":a=f;break;case"checked":c=f;break;case"defaultChecked":h=f;break;case"value":o=f;break;case"defaultValue":l=f;break;case"children":case"dangerouslySetInnerHTML":if(null!=f)throw Error(r(137,t));break;default:f!==d&&ih(e,t,p,f,s,d)}}return void It(e,o,l,u,c,h,i,a);case"select":for(i in f=o=l=p=null,n)if(u=n[i],n.hasOwnProperty(i)&&null!=u)switch(i){case"value":break;case"multiple":f=u;default:s.hasOwnProperty(i)||ih(e,t,i,null,s,u)}for(a in s)if(i=s[a],u=n[a],s.hasOwnProperty(a)&&(null!=i||null!=u))switch(a){case"value":p=i;break;case"defaultValue":l=i;break;case"multiple":o=i;default:i!==u&&ih(e,t,a,i,s,u)}return t=l,n=o,s=f,void(null!=p?Nt(e,!!n,p,!1):!!s!=!!n&&(null!=t?Nt(e,!!n,t,!0):Nt(e,!!n,n?[]:"",!1)));case"textarea":for(l in f=p=null,n)if(a=n[l],n.hasOwnProperty(l)&&null!=a&&!s.hasOwnProperty(l))switch(l){case"value":case"children":break;default:ih(e,t,l,null,s,a)}for(o in s)if(a=s[o],i=n[o],s.hasOwnProperty(o)&&(null!=a||null!=i))switch(o){case"value":p=a;break;case"defaultValue":f=a;break;case"children":break;case"dangerouslySetInnerHTML":if(null!=a)throw Error(r(91));break;default:a!==i&&ih(e,t,o,a,s,i)}return void Et(e,p,f);case"option":for(var g in n)p=n[g],n.hasOwnProperty(g)&&null!=p&&!s.hasOwnProperty(g)&&("selected"===g?e.selected=!1:ih(e,t,g,null,s,p));for(u in s)p=s[u],f=n[u],!s.hasOwnProperty(u)||p===f||null==p&&null==f||("selected"===u?e.selected=p&&"function"!=typeof p&&"symbol"!=typeof p:ih(e,t,u,p,s,f));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var m in n)p=n[m],n.hasOwnProperty(m)&&null!=p&&!s.hasOwnProperty(m)&&ih(e,t,m,null,s,p);for(c in s)if(p=s[c],f=n[c],s.hasOwnProperty(c)&&p!==f&&(null!=p||null!=f))switch(c){case"children":case"dangerouslySetInnerHTML":if(null!=p)throw Error(r(137,t));break;default:ih(e,t,c,p,s,f)}return;default:if(Dt(t)){for(var b in n)p=n[b],n.hasOwnProperty(b)&&void 0!==p&&!s.hasOwnProperty(b)&&oh(e,t,b,void 0,s,p);for(h in s)p=s[h],f=n[h],!s.hasOwnProperty(h)||p===f||void 0===p&&void 0===f||oh(e,t,h,p,s,f);return}}for(var y in n)p=n[y],n.hasOwnProperty(y)&&null!=p&&!s.hasOwnProperty(y)&&ih(e,t,y,null,s,p);for(d in s)p=s[d],f=n[d],!s.hasOwnProperty(d)||p===f||null==p&&null==f||ih(e,t,d,p,s,f)}(s,e.type,n,t),s[Ue]=t}catch(a){yc(e,e.return,a)}}function kl(e){return 5===e.tag||3===e.tag||26===e.tag||27===e.tag&&wh(e.type)||4===e.tag}function Sl(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||kl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(27===e.tag&&wh(e.type))continue e;if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function Il(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?(9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).insertBefore(e,t):((t=9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).appendChild(e),null!=(n=n._reactRootContainer)||null!==t.onclick||(t.onclick=ah));else if(4!==r&&(27===r&&wh(e.type)&&(n=e.stateNode,t=null),null!==(e=e.child)))for(Il(e,t,n),e=e.sibling;null!==e;)Il(e,t,n),e=e.sibling}function Cl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&(27===r&&wh(e.type)&&(n=e.stateNode),null!==(e=e.child)))for(Cl(e,t,n),e=e.sibling;null!==e;)Cl(e,t,n),e=e.sibling}function Tl(e){var t=e.stateNode,n=e.memoizedProps;try{for(var r=e.type,s=t.attributes;s.length;)t.removeAttributeNode(s[0]);lh(t,r,n),t[Be]=e,t[Ue]=n}catch(a){yc(e,e.return,a)}}var Nl=!1,El=!1,$l=!1,Rl="function"==typeof WeakSet?WeakSet:Set,Al=null;function _l(e,t,n){var r=n.flags;switch(n.tag){case 0:case 11:case 15:Hl(e,n),4&r&&fl(5,n);break;case 1:if(Hl(e,n),4&r)if(e=n.stateNode,null===t)try{e.componentDidMount()}catch(i){yc(n,n.return,i)}else{var s=Io(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(s,t,e.__reactInternalSnapshotBeforeUpdate)}catch(o){yc(n,n.return,o)}}64&r&&ml(n),512&r&&yl(n,n.return);break;case 3:if(Hl(e,n),64&r&&null!==(e=n.updateQueue)){if(t=null,null!==n.child)switch(n.child.tag){case 27:case 5:case 1:t=n.child.stateNode}try{va(e,t)}catch(i){yc(n,n.return,i)}}break;case 27:null===t&&4&r&&Tl(n);case 26:case 5:Hl(e,n),null===t&&4&r&&vl(n),512&r&&yl(n,n.return);break;case 12:Hl(e,n);break;case 13:Hl(e,n),4&r&&Ml(e,n),64&r&&null!==(e=n.memoizedState)&&null!==(e=e.dehydrated)&&function(e,t){var n=e.ownerDocument;if("$?"!==e.data||"complete"===n.readyState)t();else{var r=function(){t(),n.removeEventListener("DOMContentLoaded",r)};n.addEventListener("DOMContentLoaded",r),e._reactRetry=r}}(e,n=kc.bind(null,n));break;case 22:if(!(r=null!==n.memoizedState||Nl)){t=null!==t&&null!==t.memoizedState||El,s=Nl;var a=El;Nl=r,(El=t)&&!a?ql(e,n,!!(8772&n.subtreeFlags)):Hl(e,n),Nl=s,El=a}break;case 30:break;default:Hl(e,n)}}function Ol(e){var t=e.alternate;null!==t&&(e.alternate=null,Ol(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&null!==(t=e.stateNode)&&Ke(t),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Dl=null,Fl=!1;function Ll(e,t,n){for(n=n.child;null!==n;)zl(e,t,n),n=n.sibling}function zl(e,t,n){if(xe&&"function"==typeof xe.onCommitFiberUnmount)try{xe.onCommitFiberUnmount(ye,n)}catch(a){}switch(n.tag){case 26:El||xl(n,t),Ll(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode).parentNode.removeChild(n);break;case 27:El||xl(n,t);var r=Dl,s=Fl;wh(n.type)&&(Dl=n.stateNode,Fl=!1),Ll(e,t,n),$h(n.stateNode),Dl=r,Fl=s;break;case 5:El||xl(n,t);case 6:if(r=Dl,s=Fl,Dl=null,Ll(e,t,n),Fl=s,null!==(Dl=r))if(Fl)try{(9===Dl.nodeType?Dl.body:"HTML"===Dl.nodeName?Dl.ownerDocument.body:Dl).removeChild(n.stateNode)}catch(i){yc(n,t,i)}else try{Dl.removeChild(n.stateNode)}catch(i){yc(n,t,i)}break;case 18:null!==Dl&&(Fl?(kh(9===(e=Dl).nodeType?e.body:"HTML"===e.nodeName?e.ownerDocument.body:e,n.stateNode),Fd(e)):kh(Dl,n.stateNode));break;case 4:r=Dl,s=Fl,Dl=n.stateNode.containerInfo,Fl=!0,Ll(e,t,n),Dl=r,Fl=s;break;case 0:case 11:case 14:case 15:El||gl(2,n,t),El||gl(4,n,t),Ll(e,t,n);break;case 1:El||(xl(n,t),"function"==typeof(r=n.stateNode).componentWillUnmount&&bl(n,t,r)),Ll(e,t,n);break;case 21:Ll(e,t,n);break;case 22:El=(r=El)||null!==n.memoizedState,Ll(e,t,n),El=r;break;default:Ll(e,t,n)}}function Ml(e,t){if(null===t.memoizedState&&null!==(e=t.alternate)&&null!==(e=e.memoizedState)&&null!==(e=e.dehydrated))try{Fd(e)}catch(n){yc(t,t.return,n)}}function Pl(e,t){var n=function(e){switch(e.tag){case 13:case 19:var t=e.stateNode;return null===t&&(t=e.stateNode=new Rl),t;case 22:return null===(t=(e=e.stateNode)._retryCache)&&(t=e._retryCache=new Rl),t;default:throw Error(r(435,e.tag))}}(e);t.forEach((function(t){var r=Sc.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}function Bl(e,t){var n=t.deletions;if(null!==n)for(var s=0;s<n.length;s++){var a=n[s],i=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 27:if(wh(l.type)){Dl=l.stateNode,Fl=!1;break e}break;case 5:Dl=l.stateNode,Fl=!1;break e;case 3:case 4:Dl=l.stateNode.containerInfo,Fl=!0;break e}l=l.return}if(null===Dl)throw Error(r(160));zl(i,o,a),Dl=null,Fl=!1,null!==(i=a.alternate)&&(i.return=null),a.return=null}if(13878&t.subtreeFlags)for(t=t.child;null!==t;)Wl(t,e),t=t.sibling}var Ul=null;function Wl(e,t){var n=e.alternate,s=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Bl(t,e),Vl(e),4&s&&(gl(3,e,e.return),fl(3,e),gl(5,e,e.return));break;case 1:Bl(t,e),Vl(e),512&s&&(El||null===n||xl(n,n.return)),64&s&&Nl&&null!==(e=e.updateQueue)&&null!==(s=e.callbacks)&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=null===n?s:n.concat(s));break;case 26:var a=Ul;if(Bl(t,e),Vl(e),512&s&&(El||null===n||xl(n,n.return)),4&s){var i=null!==n?n.memoizedState:null;if(s=e.memoizedState,null===n)if(null===s)if(null===e.stateNode){e:{s=e.type,n=e.memoizedProps,a=a.ownerDocument||a;t:switch(s){case"title":(!(i=a.getElementsByTagName("title")[0])||i[qe]||i[Be]||"http://www.w3.org/2000/svg"===i.namespaceURI||i.hasAttribute("itemprop"))&&(i=a.createElement(s),a.head.insertBefore(i,a.querySelector("head > title"))),lh(i,s,n),i[Be]=e,Ze(i),s=i;break e;case"link":var o=qh("link","href",a).get(s+(n.href||""));if(o)for(var l=0;l<o.length;l++)if((i=o[l]).getAttribute("href")===(null==n.href||""===n.href?null:n.href)&&i.getAttribute("rel")===(null==n.rel?null:n.rel)&&i.getAttribute("title")===(null==n.title?null:n.title)&&i.getAttribute("crossorigin")===(null==n.crossOrigin?null:n.crossOrigin)){o.splice(l,1);break t}lh(i=a.createElement(s),s,n),a.head.appendChild(i);break;case"meta":if(o=qh("meta","content",a).get(s+(n.content||"")))for(l=0;l<o.length;l++)if((i=o[l]).getAttribute("content")===(null==n.content?null:""+n.content)&&i.getAttribute("name")===(null==n.name?null:n.name)&&i.getAttribute("property")===(null==n.property?null:n.property)&&i.getAttribute("http-equiv")===(null==n.httpEquiv?null:n.httpEquiv)&&i.getAttribute("charset")===(null==n.charSet?null:n.charSet)){o.splice(l,1);break t}lh(i=a.createElement(s),s,n),a.head.appendChild(i);break;default:throw Error(r(468,s))}i[Be]=e,Ze(i),s=i}e.stateNode=s}else Kh(a,e.type,e.stateNode);else e.stateNode=Wh(a,s,e.memoizedProps);else i!==s?(null===i?null!==n.stateNode&&(n=n.stateNode).parentNode.removeChild(n):i.count--,null===s?Kh(a,e.type,e.stateNode):Wh(a,s,e.memoizedProps)):null===s&&null!==e.stateNode&&wl(e,e.memoizedProps,n.memoizedProps)}break;case 27:Bl(t,e),Vl(e),512&s&&(El||null===n||xl(n,n.return)),null!==n&&4&s&&wl(e,e.memoizedProps,n.memoizedProps);break;case 5:if(Bl(t,e),Vl(e),512&s&&(El||null===n||xl(n,n.return)),32&e.flags){a=e.stateNode;try{Rt(a,"")}catch(f){yc(e,e.return,f)}}4&s&&null!=e.stateNode&&wl(e,a=e.memoizedProps,null!==n?n.memoizedProps:a),1024&s&&($l=!0);break;case 6:if(Bl(t,e),Vl(e),4&s){if(null===e.stateNode)throw Error(r(162));s=e.memoizedProps,n=e.stateNode;try{n.nodeValue=s}catch(f){yc(e,e.return,f)}}break;case 3:if(jh=null,a=Ul,Ul=_h(t.containerInfo),Bl(t,e),Ul=a,Vl(e),4&s&&null!==n&&n.memoizedState.isDehydrated)try{Fd(t.containerInfo)}catch(f){yc(e,e.return,f)}$l&&($l=!1,Gl(e));break;case 4:s=Ul,Ul=_h(e.stateNode.containerInfo),Bl(t,e),Vl(e),Ul=s;break;case 12:default:Bl(t,e),Vl(e);break;case 13:Bl(t,e),Vl(e),8192&e.child.flags&&null!==e.memoizedState!=(null!==n&&null!==n.memoizedState)&&($u=ue()),4&s&&null!==(s=e.updateQueue)&&(e.updateQueue=null,Pl(e,s));break;case 22:a=null!==e.memoizedState;var u=null!==n&&null!==n.memoizedState,c=Nl,h=El;if(Nl=c||a,El=h||u,Bl(t,e),El=h,Nl=c,Vl(e),8192&s)e:for(t=e.stateNode,t._visibility=a?-2&t._visibility:1|t._visibility,a&&(null===n||u||Nl||El||jl(e)),n=null,t=e;;){if(5===t.tag||26===t.tag){if(null===n){u=n=t;try{if(i=u.stateNode,a)"function"==typeof(o=i.style).setProperty?o.setProperty("display","none","important"):o.display="none";else{l=u.stateNode;var d=u.memoizedProps.style,p=null!=d&&d.hasOwnProperty("display")?d.display:null;l.style.display=null==p||"boolean"==typeof p?"":(""+p).trim()}}catch(f){yc(u,u.return,f)}}}else if(6===t.tag){if(null===n){u=t;try{u.stateNode.nodeValue=a?"":u.memoizedProps}catch(f){yc(u,u.return,f)}}}else if((22!==t.tag&&23!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;null===t.sibling;){if(null===t.return||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}4&s&&null!==(s=e.updateQueue)&&null!==(n=s.retryQueue)&&(s.retryQueue=null,Pl(e,n));break;case 19:Bl(t,e),Vl(e),4&s&&null!==(s=e.updateQueue)&&(e.updateQueue=null,Pl(e,s));case 30:case 21:}}function Vl(e){var t=e.flags;if(2&t){try{for(var n,s=e.return;null!==s;){if(kl(s)){n=s;break}s=s.return}if(null==n)throw Error(r(160));switch(n.tag){case 27:var a=n.stateNode;Cl(e,Sl(e),a);break;case 5:var i=n.stateNode;32&n.flags&&(Rt(i,""),n.flags&=-33),Cl(e,Sl(e),i);break;case 3:case 4:var o=n.stateNode.containerInfo;Il(e,Sl(e),o);break;default:throw Error(r(161))}}catch(l){yc(e,e.return,l)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function Gl(e){if(1024&e.subtreeFlags)for(e=e.child;null!==e;){var t=e;Gl(t),5===t.tag&&1024&t.flags&&t.stateNode.reset(),e=e.sibling}}function Hl(e,t){if(8772&t.subtreeFlags)for(t=t.child;null!==t;)_l(e,t.alternate,t),t=t.sibling}function jl(e){for(e=e.child;null!==e;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:gl(4,t,t.return),jl(t);break;case 1:xl(t,t.return);var n=t.stateNode;"function"==typeof n.componentWillUnmount&&bl(t,t.return,n),jl(t);break;case 27:$h(t.stateNode);case 26:case 5:xl(t,t.return),jl(t);break;case 22:null===t.memoizedState&&jl(t);break;default:jl(t)}e=e.sibling}}function ql(e,t,n){for(n=n&&!!(8772&t.subtreeFlags),t=t.child;null!==t;){var r=t.alternate,s=e,a=t,i=a.flags;switch(a.tag){case 0:case 11:case 15:ql(s,a,n),fl(4,a);break;case 1:if(ql(s,a,n),"function"==typeof(s=(r=a).stateNode).componentDidMount)try{s.componentDidMount()}catch(u){yc(r,r.return,u)}if(null!==(s=(r=a).updateQueue)){var o=r.stateNode;try{var l=s.shared.hiddenCallbacks;if(null!==l)for(s.shared.hiddenCallbacks=null,s=0;s<l.length;s++)xa(l[s],o)}catch(u){yc(r,r.return,u)}}n&&64&i&&ml(a),yl(a,a.return);break;case 27:Tl(a);case 26:case 5:ql(s,a,n),n&&null===r&&4&i&&vl(a),yl(a,a.return);break;case 12:ql(s,a,n);break;case 13:ql(s,a,n),n&&4&i&&Ml(s,a);break;case 22:null===a.memoizedState&&ql(s,a,n),yl(a,a.return);break;case 30:break;default:ql(s,a,n)}t=t.sibling}}function Kl(e,t){var n=null;null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),e=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(e=t.memoizedState.cachePool.pool),e!==n&&(null!=e&&e.refCount++,null!=n&&Ws(n))}function Xl(e,t){e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Ws(e))}function Yl(e,t,n,r){if(10256&t.subtreeFlags)for(t=t.child;null!==t;)Ql(e,t,n,r),t=t.sibling}function Ql(e,t,n,r){var s=t.flags;switch(t.tag){case 0:case 11:case 15:Yl(e,t,n,r),2048&s&&fl(9,t);break;case 1:case 13:default:Yl(e,t,n,r);break;case 3:Yl(e,t,n,r),2048&s&&(e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Ws(e)));break;case 12:if(2048&s){Yl(e,t,n,r),e=t.stateNode;try{var a=t.memoizedProps,i=a.id,o=a.onPostCommit;"function"==typeof o&&o(i,null===t.alternate?"mount":"update",e.passiveEffectDuration,-0)}catch(l){yc(t,t.return,l)}}else Yl(e,t,n,r);break;case 23:break;case 22:a=t.stateNode,i=t.alternate,null!==t.memoizedState?2&a._visibility?Yl(e,t,n,r):Zl(e,t):2&a._visibility?Yl(e,t,n,r):(a._visibility|=2,Jl(e,t,n,r,!!(10256&t.subtreeFlags))),2048&s&&Kl(i,t);break;case 24:Yl(e,t,n,r),2048&s&&Xl(t.alternate,t)}}function Jl(e,t,n,r,s){for(s=s&&!!(10256&t.subtreeFlags),t=t.child;null!==t;){var a=e,i=t,o=n,l=r,u=i.flags;switch(i.tag){case 0:case 11:case 15:Jl(a,i,o,l,s),fl(8,i);break;case 23:break;case 22:var c=i.stateNode;null!==i.memoizedState?2&c._visibility?Jl(a,i,o,l,s):Zl(a,i):(c._visibility|=2,Jl(a,i,o,l,s)),s&&2048&u&&Kl(i.alternate,i);break;case 24:Jl(a,i,o,l,s),s&&2048&u&&Xl(i.alternate,i);break;default:Jl(a,i,o,l,s)}t=t.sibling}}function Zl(e,t){if(10256&t.subtreeFlags)for(t=t.child;null!==t;){var n=e,r=t,s=r.flags;switch(r.tag){case 22:Zl(n,r),2048&s&&Kl(r.alternate,r);break;case 24:Zl(n,r),2048&s&&Xl(r.alternate,r);break;default:Zl(n,r)}t=t.sibling}}var eu=8192;function tu(e){if(e.subtreeFlags&eu)for(e=e.child;null!==e;)nu(e),e=e.sibling}function nu(e){switch(e.tag){case 26:tu(e),e.flags&eu&&null!==e.memoizedState&&function(e,t,n){if(null===Yh)throw Error(r(475));var s=Yh;if(!("stylesheet"!==t.type||"string"==typeof n.media&&!1===matchMedia(n.media).matches||4&t.state.loading)){if(null===t.instance){var a=zh(n.href),i=e.querySelector(Mh(a));if(i)return null!==(e=i._p)&&"object"==typeof e&&"function"==typeof e.then&&(s.count++,s=Jh.bind(s),e.then(s,s)),t.state.loading|=4,t.instance=i,void Ze(i);i=e.ownerDocument||e,n=Ph(n),(a=Rh.get(a))&&Gh(n,a),Ze(i=i.createElement("link"));var o=i;o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),lh(i,"link",n),t.instance=i}null===s.stylesheets&&(s.stylesheets=new Map),s.stylesheets.set(t,e),(e=t.state.preload)&&!(3&t.state.loading)&&(s.count++,t=Jh.bind(s),e.addEventListener("load",t),e.addEventListener("error",t))}}(Ul,e.memoizedState,e.memoizedProps);break;case 5:default:tu(e);break;case 3:case 4:var t=Ul;Ul=_h(e.stateNode.containerInfo),tu(e),Ul=t;break;case 22:null===e.memoizedState&&(null!==(t=e.alternate)&&null!==t.memoizedState?(t=eu,eu=16777216,tu(e),eu=t):tu(e))}}function ru(e){var t=e.alternate;if(null!==t&&null!==(e=t.child)){t.child=null;do{t=e.sibling,e.sibling=null,e=t}while(null!==e)}}function su(e){var t=e.deletions;if(16&e.flags){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Al=r,ou(r,e)}ru(e)}if(10256&e.subtreeFlags)for(e=e.child;null!==e;)au(e),e=e.sibling}function au(e){switch(e.tag){case 0:case 11:case 15:su(e),2048&e.flags&&gl(9,e,e.return);break;case 3:case 12:default:su(e);break;case 22:var t=e.stateNode;null!==e.memoizedState&&2&t._visibility&&(null===e.return||13!==e.return.tag)?(t._visibility&=-3,iu(e)):su(e)}}function iu(e){var t=e.deletions;if(16&e.flags){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Al=r,ou(r,e)}ru(e)}for(e=e.child;null!==e;){switch((t=e).tag){case 0:case 11:case 15:gl(8,t,t.return),iu(t);break;case 22:2&(n=t.stateNode)._visibility&&(n._visibility&=-3,iu(t));break;default:iu(t)}e=e.sibling}}function ou(e,t){for(;null!==Al;){var n=Al;switch(n.tag){case 0:case 11:case 15:gl(8,n,t);break;case 23:case 22:if(null!==n.memoizedState&&null!==n.memoizedState.cachePool){var r=n.memoizedState.cachePool.pool;null!=r&&r.refCount++}break;case 24:Ws(n.memoizedState.cache)}if(null!==(r=n.child))r.return=n,Al=r;else e:for(n=e;null!==Al;){var s=(r=Al).sibling,a=r.return;if(Ol(r),r===n){Al=null;break e}if(null!==s){s.return=a,Al=s;break e}Al=a}}}var lu={getCacheForType:function(e){var t=Ds(Bs),n=t.data.get(e);return void 0===n&&(n=e(),t.data.set(e,n)),n}},uu="function"==typeof WeakMap?WeakMap:Map,cu=0,hu=null,du=null,pu=0,fu=0,gu=null,mu=!1,bu=!1,yu=!1,xu=0,vu=0,wu=0,ku=0,Su=0,Iu=0,Cu=0,Tu=null,Nu=null,Eu=!1,$u=0,Ru=1/0,Au=null,_u=null,Ou=0,Du=null,Fu=null,Lu=0,zu=0,Mu=null,Pu=null,Bu=0,Uu=null;function Wu(){return 2&cu&&0!==pu?pu&-pu:null!==W.T?0!==Hs?Hs:zc():Me()}function Vu(){0===Iu&&(Iu=536870912&pu&&!ps?536870912:Re());var e=ho.current;return null!==e&&(e.flags|=32),Iu}function Gu(e,t,n){(e!==hu||2!==fu&&9!==fu)&&null===e.cancelPendingCommit||(Qu(e,0),Ku(e,pu,Iu,!1)),Oe(e,n),2&cu&&e===hu||(e===hu&&(!(2&cu)&&(ku|=n),4===vu&&Ku(e,pu,Iu,!1)),Rc(e))}function Hu(e,t,n){if(6&cu)throw Error(r(327));for(var s=!n&&!(124&t)&&!(t&e.expiredLanes)||Ee(e,t),a=s?function(e,t){var n=cu;cu|=2;var s=Zu(),a=ec();hu!==e||pu!==t?(Au=null,Ru=ue()+500,Qu(e,t)):bu=Ee(e,t);e:for(;;)try{if(0!==fu&&null!==du){t=du;var i=gu;t:switch(fu){case 1:fu=0,gu=null,oc(e,t,i,1);break;case 2:case 9:if(ra(i)){fu=0,gu=null,ic(t);break}t=function(){2!==fu&&9!==fu||hu!==e||(fu=7),Rc(e)},i.then(t,t);break e;case 3:fu=7;break e;case 4:fu=5;break e;case 7:ra(i)?(fu=0,gu=null,ic(t)):(fu=0,gu=null,oc(e,t,i,7));break;case 5:var o=null;switch(du.tag){case 26:o=du.memoizedState;case 5:case 27:var l=du;if(!o||Xh(o)){fu=0,gu=null;var u=l.sibling;if(null!==u)du=u;else{var c=l.return;null!==c?(du=c,lc(c)):du=null}break t}}fu=0,gu=null,oc(e,t,i,5);break;case 6:fu=0,gu=null,oc(e,t,i,6);break;case 8:Yu(),vu=6;break e;default:throw Error(r(462))}}sc();break}catch(h){Ju(e,h)}return Ts=Cs=null,W.H=s,W.A=a,cu=n,null!==du?0:(hu=null,pu=0,Lr(),vu)}(e,t):nc(e,t,!0),i=s;;){if(0===a){bu&&!s&&Ku(e,t,0,!1);break}if(n=e.current.alternate,!i||qu(n)){if(2===a){if(i=t,e.errorRecoveryDisabledLanes&i)var o=0;else o=0!=(o=-536870913&e.pendingLanes)?o:536870912&o?536870912:0;if(0!==o){t=o;e:{var l=e;a=Tu;var u=l.current.memoizedState.isDehydrated;if(u&&(Qu(l,o).flags|=256),2!==(o=nc(l,o,!1))){if(yu&&!u){l.errorRecoveryDisabledLanes|=i,ku|=i,a=4;break e}i=Nu,Nu=a,null!==i&&(null===Nu?Nu=i:Nu.push.apply(Nu,i))}a=o}if(i=!1,2!==a)continue}}if(1===a){Qu(e,0),Ku(e,t,0,!0);break}e:{switch(s=e,i=a){case 0:case 1:throw Error(r(345));case 4:if((4194048&t)!==t)break;case 6:Ku(s,t,Iu,!mu);break e;case 2:Nu=null;break;case 3:case 5:break;default:throw Error(r(329))}if((62914560&t)===t&&10<(a=$u+300-ue())){if(Ku(s,t,Iu,!mu),0!==Ne(s,0,!0))break e;s.timeoutHandle=mh(ju.bind(null,s,n,Nu,Au,Eu,t,Iu,ku,Cu,mu,i,2,-0,0),a)}else ju(s,n,Nu,Au,Eu,t,Iu,ku,Cu,mu,i,0,-0,0)}break}a=nc(e,t,!1),i=!1}Rc(e)}function ju(e,t,n,s,a,i,o,l,u,c,h,d,p,f){if(e.timeoutHandle=-1,(8192&(d=t.subtreeFlags)||!(16785408&~d))&&(Yh={stylesheets:null,count:0,unsuspend:Qh},nu(t),null!==(d=function(){if(null===Yh)throw Error(r(475));var e=Yh;return e.stylesheets&&0===e.count&&ed(e,e.stylesheets),0<e.count?function(t){var n=setTimeout((function(){if(e.stylesheets&&ed(e,e.stylesheets),e.unsuspend){var t=e.unsuspend;e.unsuspend=null,t()}}),6e4);return e.unsuspend=t,function(){e.unsuspend=null,clearTimeout(n)}}:null}())))return e.cancelPendingCommit=d(cc.bind(null,e,t,i,n,s,a,o,l,u,h,1,p,f)),void Ku(e,i,o,!c);cc(e,t,i,n,s,a,o,l,u)}function qu(e){for(var t=e;;){var n=t.tag;if((0===n||11===n||15===n)&&16384&t.flags&&null!==(n=t.updateQueue)&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!rr(a(),s))return!1}catch(i){return!1}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Ku(e,t,n,r){t&=~Su,t&=~ku,e.suspendedLanes|=t,e.pingedLanes&=~t,r&&(e.warmLanes|=t),r=e.expirationTimes;for(var s=t;0<s;){var a=31-we(s),i=1<<a;r[a]=-1,s&=~i}0!==n&&De(e,n,t)}function Xu(){return!!(6&cu)||(Ac(0),!1)}function Yu(){if(null!==du){if(0===fu)var e=du.return;else Ts=Cs=null,Ha(e=du),no=null,ro=0,e=du;for(;null!==e;)pl(e.alternate,e),e=e.return;du=null}}function Qu(e,t){var n=e.timeoutHandle;-1!==n&&(e.timeoutHandle=-1,bh(n)),null!==(n=e.cancelPendingCommit)&&(e.cancelPendingCommit=null,n()),Yu(),hu=e,du=n=jr(e.current,null),pu=t,fu=0,gu=null,mu=!1,bu=Ee(e,t),yu=!1,Cu=Iu=Su=ku=wu=vu=0,Nu=Tu=null,Eu=!1,8&t&&(t|=32&t);var r=e.entangledLanes;if(0!==r)for(e=e.entanglements,r&=t;0<r;){var s=31-we(r),a=1<<s;t|=e[s],r&=~a}return xu=t,Lr(),n}function Ju(e,t){Na=null,W.H=Ji,t===Zs||t===ta?(t=oa(),fu=3):t===ea?(t=oa(),fu=4):fu=t===Do?8:null!==t&&"object"==typeof t&&"function"==typeof t.then?6:1,gu=t,null===du&&(vu=1,$o(e,_r(t,e.current)))}function Zu(){var e=W.H;return W.H=Ji,null===e?Ji:e}function ec(){var e=W.A;return W.A=lu,e}function tc(){vu=4,mu||(4194048&pu)!==pu&&null!==ho.current||(bu=!0),!(134217727&wu)&&!(134217727&ku)||null===hu||Ku(hu,pu,Iu,!1)}function nc(e,t,n){var r=cu;cu|=2;var s=Zu(),a=ec();hu===e&&pu===t||(Au=null,Qu(e,t)),t=!1;var i=vu;e:for(;;)try{if(0!==fu&&null!==du){var o=du,l=gu;switch(fu){case 8:Yu(),i=6;break e;case 3:case 2:case 9:case 6:null===ho.current&&(t=!0);var u=fu;if(fu=0,gu=null,oc(e,o,l,u),n&&bu){i=0;break e}break;default:u=fu,fu=0,gu=null,oc(e,o,l,u)}}rc(),i=vu;break}catch(c){Ju(e,c)}return t&&e.shellSuspendCounter++,Ts=Cs=null,cu=r,W.H=s,W.A=a,null===du&&(hu=null,pu=0,Lr()),i}function rc(){for(;null!==du;)ac(du)}function sc(){for(;null!==du&&!oe();)ac(du)}function ac(e){var t=al(e.alternate,e,xu);e.memoizedProps=e.pendingProps,null===t?lc(e):du=t}function ic(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=Go(n,t,t.pendingProps,t.type,void 0,pu);break;case 11:t=Go(n,t,t.pendingProps,t.type.render,t.ref,pu);break;case 5:Ha(t);default:pl(n,t),t=al(n,t=du=qr(t,xu),xu)}e.memoizedProps=e.pendingProps,null===t?lc(e):du=t}function oc(e,t,n,s){Ts=Cs=null,Ha(t),no=null,ro=0;var a=t.return;try{if(function(e,t,n,s,a){if(n.flags|=32768,null!==s&&"object"==typeof s&&"function"==typeof s.then){if(null!==(t=n.alternate)&&As(t,n,a,!0),null!==(n=ho.current)){switch(n.tag){case 13:return null===po?tc():null===n.alternate&&0===vu&&(vu=3),n.flags&=-257,n.flags|=65536,n.lanes=a,s===na?n.flags|=16384:(null===(t=n.updateQueue)?n.updateQueue=new Set([s]):t.add(s),xc(e,s,a)),!1;case 22:return n.flags|=65536,s===na?n.flags|=16384:(null===(t=n.updateQueue)?(t={transitions:null,markerInstances:null,retryQueue:new Set([s])},n.updateQueue=t):null===(n=t.retryQueue)?t.retryQueue=new Set([s]):n.add(s),xc(e,s,a)),!1}throw Error(r(435,n.tag))}return xc(e,s,a),tc(),!1}if(ps)return null!==(t=ho.current)?(!(65536&t.flags)&&(t.flags|=256),t.flags|=65536,t.lanes=a,s!==ms&&Ss(_r(e=Error(r(422),{cause:s}),n))):(s!==ms&&Ss(_r(t=Error(r(423),{cause:s}),n)),(e=e.current.alternate).flags|=65536,a&=-a,e.lanes|=a,s=_r(s,n),ga(e,a=Ao(e.stateNode,s,a)),4!==vu&&(vu=2)),!1;var i=Error(r(520),{cause:s});if(i=_r(i,n),null===Tu?Tu=[i]:Tu.push(i),4!==vu&&(vu=2),null===t)return!0;s=_r(s,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=a&-a,n.lanes|=e,ga(n,e=Ao(n.stateNode,s,e)),!1;case 1:if(t=n.type,i=n.stateNode,!(128&n.flags||"function"!=typeof t.getDerivedStateFromError&&(null===i||"function"!=typeof i.componentDidCatch||null!==_u&&_u.has(i))))return n.flags|=65536,a&=-a,n.lanes|=a,Oo(a=_o(a),e,n,s),ga(n,a),!1}n=n.return}while(null!==n);return!1}(e,a,t,n,pu))return vu=1,$o(e,_r(n,e.current)),void(du=null)}catch(i){if(null!==a)throw du=a,i;return vu=1,$o(e,_r(n,e.current)),void(du=null)}32768&t.flags?(ps||1===s?e=!0:bu||536870912&pu?e=!1:(mu=e=!0,(2===s||9===s||3===s||6===s)&&null!==(s=ho.current)&&13===s.tag&&(s.flags|=16384)),uc(t,e)):lc(t)}function lc(e){var t=e;do{if(32768&t.flags)return void uc(t,mu);e=t.return;var n=hl(t.alternate,t,xu);if(null!==n)return void(du=n);if(null!==(t=t.sibling))return void(du=t);du=t=e}while(null!==t);0===vu&&(vu=5)}function uc(e,t){do{var n=dl(e.alternate,e);if(null!==n)return n.flags&=32767,void(du=n);if(null!==(n=e.return)&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&null!==(e=e.sibling))return void(du=e);du=e=n}while(null!==e);vu=6,du=null}function cc(e,t,n,s,a,i,o,l,u){e.cancelPendingCommit=null;do{gc()}while(0!==Ou);if(6&cu)throw Error(r(327));if(null!==t){if(t===e.current)throw Error(r(177));if(i=t.lanes|t.childLanes,function(e,t,n,r,s,a){var i=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var o=e.entanglements,l=e.expirationTimes,u=e.hiddenUpdates;for(n=i&~n;0<n;){var c=31-we(n),h=1<<c;o[c]=0,l[c]=-1;var d=u[c];if(null!==d)for(u[c]=null,c=0;c<d.length;c++){var p=d[c];null!==p&&(p.lane&=-536870913)}n&=~h}0!==r&&De(e,r,0),0!==a&&0===s&&0!==e.tag&&(e.suspendedLanes|=a&~(i&~t))}(e,n,i|=Fr,o,l,u),e===hu&&(du=hu=null,pu=0),Fu=t,Du=e,Lu=n,zu=i,Mu=a,Pu=s,10256&t.subtreeFlags||10256&t.flags?(e.callbackNode=null,e.callbackPriority=0,ae(pe,(function(){return mc(),null}))):(e.callbackNode=null,e.callbackPriority=0),s=!!(13878&t.flags),13878&t.subtreeFlags||s){s=W.T,W.T=null,a=V.p,V.p=2,o=cu,cu|=4;try{!function(e,t){if(e=e.containerInfo,uh=cd,ur(e=lr(e))){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var s=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(s&&0!==s.rangeCount){n=s.anchorNode;var a=s.anchorOffset,i=s.focusNode;s=s.focusOffset;try{n.nodeType,i.nodeType}catch(m){n=null;break e}var o=0,l=-1,u=-1,c=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==a&&3!==d.nodeType||(l=o+a),d!==i||0!==s&&3!==d.nodeType||(u=o+s),3===d.nodeType&&(o+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++c===a&&(l=o),p===i&&++h===s&&(u=o),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ch={focusedElem:e,selectionRange:n},cd=!1,Al=t;null!==Al;)if(e=(t=Al).child,1024&t.subtreeFlags&&null!==e)e.return=t,Al=e;else for(;null!==Al;){switch(i=(t=Al).alternate,e=t.flags,t.tag){case 0:case 11:case 15:case 5:case 26:case 27:case 6:case 4:case 17:break;case 1:if(1024&e&&null!==i){e=void 0,n=t,a=i.memoizedProps,i=i.memoizedState,s=n.stateNode;try{var g=Io(n.type,a,(n.elementType,n.type));e=s.getSnapshotBeforeUpdate(g,i),s.__reactInternalSnapshotBeforeUpdate=e}catch(b){yc(n,n.return,b)}}break;case 3:if(1024&e)if(9===(n=(e=t.stateNode.containerInfo).nodeType))Sh(e);else if(1===n)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":Sh(e);break;default:e.textContent=""}break;default:if(1024&e)throw Error(r(163))}if(null!==(e=t.sibling)){e.return=t.return,Al=e;break}Al=t.return}}(e,t)}finally{cu=o,V.p=a,W.T=s}}Ou=1,hc(),dc(),pc()}}function hc(){if(1===Ou){Ou=0;var e=Du,t=Fu,n=!!(13878&t.flags);if(13878&t.subtreeFlags||n){n=W.T,W.T=null;var r=V.p;V.p=2;var s=cu;cu|=4;try{Wl(t,e);var a=ch,i=lr(e.containerInfo),o=a.focusedElem,l=a.selectionRange;if(i!==o&&o&&o.ownerDocument&&or(o.ownerDocument.documentElement,o)){if(null!==l&&ur(o)){var u=l.start,c=l.end;if(void 0===c&&(c=u),"selectionStart"in o)o.selectionStart=u,o.selectionEnd=Math.min(c,o.value.length);else{var h=o.ownerDocument||document,d=h&&h.defaultView||window;if(d.getSelection){var p=d.getSelection(),f=o.textContent.length,g=Math.min(l.start,f),m=void 0===l.end?g:Math.min(l.end,f);!p.extend&&g>m&&(i=m,m=g,g=i);var b=ir(o,g),y=ir(o,m);if(b&&y&&(1!==p.rangeCount||p.anchorNode!==b.node||p.anchorOffset!==b.offset||p.focusNode!==y.node||p.focusOffset!==y.offset)){var x=h.createRange();x.setStart(b.node,b.offset),p.removeAllRanges(),g>m?(p.addRange(x),p.extend(y.node,y.offset)):(x.setEnd(y.node,y.offset),p.addRange(x))}}}}for(h=[],p=o;p=p.parentNode;)1===p.nodeType&&h.push({element:p,left:p.scrollLeft,top:p.scrollTop});for("function"==typeof o.focus&&o.focus(),o=0;o<h.length;o++){var v=h[o];v.element.scrollLeft=v.left,v.element.scrollTop=v.top}}cd=!!uh,ch=uh=null}finally{cu=s,V.p=r,W.T=n}}e.current=t,Ou=2}}function dc(){if(2===Ou){Ou=0;var e=Du,t=Fu,n=!!(8772&t.flags);if(8772&t.subtreeFlags||n){n=W.T,W.T=null;var r=V.p;V.p=2;var s=cu;cu|=4;try{_l(e,t.alternate,t)}finally{cu=s,V.p=r,W.T=n}}Ou=3}}function pc(){if(4===Ou||3===Ou){Ou=0,le();var e=Du,t=Fu,n=Lu,r=Pu;10256&t.subtreeFlags||10256&t.flags?Ou=5:(Ou=0,Fu=Du=null,fc(e,e.pendingLanes));var s=e.pendingLanes;if(0===s&&(_u=null),ze(n),t=t.stateNode,xe&&"function"==typeof xe.onCommitFiberRoot)try{xe.onCommitFiberRoot(ye,t,void 0,!(128&~t.current.flags))}catch(l){}if(null!==r){t=W.T,s=V.p,V.p=2,W.T=null;try{for(var a=e.onRecoverableError,i=0;i<r.length;i++){var o=r[i];a(o.value,{componentStack:o.stack})}}finally{W.T=t,V.p=s}}3&Lu&&gc(),Rc(e),s=e.pendingLanes,4194090&n&&42&s?e===Uu?Bu++:(Bu=0,Uu=e):Bu=0,Ac(0)}}function fc(e,t){0==(e.pooledCacheLanes&=t)&&null!=(t=e.pooledCache)&&(e.pooledCache=null,Ws(t))}function gc(e){return hc(),dc(),pc(),mc()}function mc(){if(5!==Ou)return!1;var e=Du,t=zu;zu=0;var n=ze(Lu),s=W.T,a=V.p;try{V.p=32>n?32:n,W.T=null,n=Mu,Mu=null;var i=Du,o=Lu;if(Ou=0,Fu=Du=null,Lu=0,6&cu)throw Error(r(331));var l=cu;if(cu|=4,au(i.current),Ql(i,i.current,o,n),cu=l,Ac(0),xe&&"function"==typeof xe.onPostCommitFiberRoot)try{xe.onPostCommitFiberRoot(ye,i)}catch(u){}return!0}finally{V.p=a,W.T=s,fc(e,t)}}function bc(e,t,n){t=_r(n,t),null!==(e=pa(e,t=Ao(e.stateNode,t,2),2))&&(Oe(e,2),Rc(e))}function yc(e,t,n){if(3===e.tag)bc(e,e,n);else for(;null!==t;){if(3===t.tag){bc(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"==typeof t.type.getDerivedStateFromError||"function"==typeof r.componentDidCatch&&(null===_u||!_u.has(r))){e=_r(n,e),null!==(r=pa(t,n=_o(2),2))&&(Oo(n,r,t,e),Oe(r,2),Rc(r));break}}t=t.return}}function xc(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new uu;var s=new Set;r.set(t,s)}else void 0===(s=r.get(t))&&(s=new Set,r.set(t,s));s.has(n)||(yu=!0,s.add(n),e=vc.bind(null,e,t,n),t.then(e,e))}function vc(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,hu===e&&(pu&n)===n&&(4===vu||3===vu&&(62914560&pu)===pu&&300>ue()-$u?!(2&cu)&&Qu(e,0):Su|=n,Cu===pu&&(Cu=0)),Rc(e)}function wc(e,t){0===t&&(t=Ae()),null!==(e=Pr(e,t))&&(Oe(e,t),Rc(e))}function kc(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),wc(e,n)}function Sc(e,t){var n=0;switch(e.tag){case 13:var s=e.stateNode,a=e.memoizedState;null!==a&&(n=a.retryLane);break;case 19:s=e.stateNode;break;case 22:s=e.stateNode._retryCache;break;default:throw Error(r(314))}null!==s&&s.delete(t),wc(e,n)}var Ic=null,Cc=null,Tc=!1,Nc=!1,Ec=!1,$c=0;function Rc(e){e!==Cc&&null===e.next&&(null===Cc?Ic=Cc=e:Cc=Cc.next=e),Nc=!0,Tc||(Tc=!0,xh((function(){6&cu?ae(he,_c):Oc()})))}function Ac(e,t){if(!Ec&&Nc){Ec=!0;do{for(var n=!1,r=Ic;null!==r;){if(0!==e){var s=r.pendingLanes;if(0===s)var a=0;else{var i=r.suspendedLanes,o=r.pingedLanes;a=(1<<31-we(42|e)+1)-1,a=201326741&(a&=s&~(i&~o))?201326741&a|1:a?2|a:0}0!==a&&(n=!0,Lc(r,a))}else a=pu,!(3&(a=Ne(r,r===hu?a:0,null!==r.cancelPendingCommit||-1!==r.timeoutHandle)))||Ee(r,a)||(n=!0,Lc(r,a));r=r.next}}while(n);Ec=!1}}function _c(){Oc()}function Oc(){Nc=Tc=!1;var e,t=0;0!==$c&&(((e=window.event)&&"popstate"===e.type?e!==gh&&(gh=e,!0):(gh=null,!1))&&(t=$c),$c=0);for(var n=ue(),r=null,s=Ic;null!==s;){var a=s.next,i=Dc(s,n);0===i?(s.next=null,null===r?Ic=a:r.next=a,null===a&&(Cc=r)):(r=s,(0!==t||3&i)&&(Nc=!0)),s=a}Ac(t)}function Dc(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=-62914561&e.pendingLanes;0<a;){var i=31-we(a),o=1<<i,l=s[i];-1===l?o&n&&!(o&r)||(s[i]=$e(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}if(n=pu,n=Ne(e,e===(t=hu)?n:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle),r=e.callbackNode,0===n||e===t&&(2===fu||9===fu)||null!==e.cancelPendingCommit)return null!==r&&null!==r&&ie(r),e.callbackNode=null,e.callbackPriority=0;if(!(3&n)||Ee(e,n)){if((t=n&-n)===e.callbackPriority)return t;switch(null!==r&&ie(r),ze(n)){case 2:case 8:n=de;break;case 32:default:n=pe;break;case 268435456:n=ge}return r=Fc.bind(null,e),n=ae(n,r),e.callbackPriority=t,e.callbackNode=n,t}return null!==r&&null!==r&&ie(r),e.callbackPriority=2,e.callbackNode=null,2}function Fc(e,t){if(0!==Ou&&5!==Ou)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(gc()&&e.callbackNode!==n)return null;var r=pu;return 0===(r=Ne(e,e===hu?r:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle))?null:(Hu(e,r,t),Dc(e,ue()),null!=e.callbackNode&&e.callbackNode===n?Fc.bind(null,e):null)}function Lc(e,t){if(gc())return null;Hu(e,t,!0)}function zc(){return 0===$c&&($c=Re()),$c}function Mc(e){return null==e||"symbol"==typeof e||"boolean"==typeof e?null:"function"==typeof e?e:zt(""+e)}function Pc(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}for(var Bc=0;Bc<$r.length;Bc++){var Uc=$r[Bc];Rr(Uc.toLowerCase(),"on"+(Uc[0].toUpperCase()+Uc.slice(1)))}Rr(wr,"onAnimationEnd"),Rr(kr,"onAnimationIteration"),Rr(Sr,"onAnimationStart"),Rr("dblclick","onDoubleClick"),Rr("focusin","onFocus"),Rr("focusout","onBlur"),Rr(Ir,"onTransitionRun"),Rr(Cr,"onTransitionStart"),Rr(Tr,"onTransitionCancel"),Rr(Nr,"onTransitionEnd"),rt("onMouseEnter",["mouseout","mouseover"]),rt("onMouseLeave",["mouseout","mouseover"]),rt("onPointerEnter",["pointerout","pointerover"]),rt("onPointerLeave",["pointerout","pointerover"]),nt("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),nt("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),nt("onBeforeInput",["compositionend","keypress","textInput","paste"]),nt("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),nt("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),nt("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Wc="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Vc=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Wc));function Gc(e,t){t=!!(4&t);for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;a=o,s.currentTarget=u;try{a(s)}catch(c){Co(c)}s.currentTarget=null,a=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;a=o,s.currentTarget=u;try{a(s)}catch(c){Co(c)}s.currentTarget=null,a=l}}}}function Hc(e,t){var n=t[Ve];void 0===n&&(n=t[Ve]=new Set);var r=e+"__bubble";n.has(r)||(Xc(t,e,2,!1),n.add(r))}function jc(e,t,n){var r=0;t&&(r|=4),Xc(n,e,r,t)}var qc="_reactListening"+Math.random().toString(36).slice(2);function Kc(e){if(!e[qc]){e[qc]=!0,et.forEach((function(t){"selectionchange"!==t&&(Vc.has(t)||jc(t,!1,e),jc(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[qc]||(t[qc]=!0,jc("selectionchange",!1,t))}}function Xc(e,t,n,r){switch(bd(t)){case 2:var s=hd;break;case 8:s=dd;break;default:s=pd}n=s.bind(null,t,n,e),s=void 0,!qt||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),r?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Yc(e,t,n,r,s){var i=r;if(!(1&t||2&t||null===r))e:for(;;){if(null===r)return;var o=r.tag;if(3===o||4===o){var l=r.stateNode.containerInfo;if(l===s)break;if(4===o)for(o=r.return;null!==o;){var u=o.tag;if((3===u||4===u)&&o.stateNode.containerInfo===s)return;o=o.return}for(;null!==l;){if(null===(o=Xe(l)))return;if(5===(u=o.tag)||6===u||26===u||27===u){r=i=o;continue e}l=l.parentNode}}r=r.return}Gt((function(){var r=i,s=Pt(n),o=[];e:{var l=Er.get(e);if(void 0!==l){var u=ln,c=e;switch(e){case"keypress":if(0===Zt(n))break e;case"keydown":case"keyup":u=Sn;break;case"focusin":c="focus",u=fn;break;case"focusout":c="blur",u=fn;break;case"beforeblur":case"afterblur":u=fn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":u=dn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":u=pn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":u=Cn;break;case wr:case kr:case Sr:u=gn;break;case Nr:u=Tn;break;case"scroll":case"scrollend":u=cn;break;case"wheel":u=Nn;break;case"copy":case"cut":case"paste":u=mn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":u=In;break;case"toggle":case"beforetoggle":u=En}var h=!!(4&t),d=!h&&("scroll"===e||"scrollend"===e),p=h?null!==l?l+"Capture":null:l;h=[];for(var f,g=r;null!==g;){var m=g;if(f=m.stateNode,5!==(m=m.tag)&&26!==m&&27!==m||null===f||null===p||null!=(m=Ht(g,p))&&h.push(Qc(g,m,f)),d)break;g=g.return}0<h.length&&(l=new u(l,c,null,n,s),o.push({event:l,listeners:h}))}}if(!(7&t)){if(u="mouseout"===e||"pointerout"===e,(!(l="mouseover"===e||"pointerover"===e)||n===Mt||!(c=n.relatedTarget||n.fromElement)||!Xe(c)&&!c[We])&&(u||l)&&(l=s.window===s?s:(l=s.ownerDocument)?l.defaultView||l.parentWindow:window,u?(u=r,null!==(c=(c=n.relatedTarget||n.toElement)?Xe(c):null)&&(d=a(c),h=c.tag,c!==d||5!==h&&27!==h&&6!==h)&&(c=null)):(u=null,c=r),u!==c)){if(h=dn,m="onMouseLeave",p="onMouseEnter",g="mouse","pointerout"!==e&&"pointerover"!==e||(h=In,m="onPointerLeave",p="onPointerEnter",g="pointer"),d=null==u?l:Qe(u),f=null==c?l:Qe(c),(l=new h(m,g+"leave",u,n,s)).target=d,l.relatedTarget=f,m=null,Xe(s)===r&&((h=new h(p,g+"enter",c,n,s)).target=f,h.relatedTarget=d,m=h),d=m,u&&c)e:{for(p=c,g=0,f=h=u;f;f=Zc(f))g++;for(f=0,m=p;m;m=Zc(m))f++;for(;0<g-f;)h=Zc(h),g--;for(;0<f-g;)p=Zc(p),f--;for(;g--;){if(h===p||null!==p&&h===p.alternate)break e;h=Zc(h),p=Zc(p)}h=null}else h=null;null!==u&&eh(o,l,u,h,!1),null!==c&&null!==d&&eh(o,d,c,h,!0)}if("select"===(u=(l=r?Qe(r):window).nodeName&&l.nodeName.toLowerCase())||"input"===u&&"file"===l.type)var b=jn;else if(Bn(l))if(qn)b=nr;else{b=er;var y=Zn}else!(u=l.nodeName)||"input"!==u.toLowerCase()||"checkbox"!==l.type&&"radio"!==l.type?r&&Dt(r.elementType)&&(b=jn):b=tr;switch(b&&(b=b(e,r))?Un(o,b,n,s):(y&&y(e,l,r),"focusout"===e&&r&&"number"===l.type&&null!=r.memoizedProps.value&&Tt(l,"number",l.value)),y=r?Qe(r):window,e){case"focusin":(Bn(y)||"true"===y.contentEditable)&&(hr=y,dr=r,pr=null);break;case"focusout":pr=dr=hr=null;break;case"mousedown":fr=!0;break;case"contextmenu":case"mouseup":case"dragend":fr=!1,gr(o,n,s);break;case"selectionchange":if(cr)break;case"keydown":case"keyup":gr(o,n,s)}var x;if(Rn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Mn?Ln(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(On&&"ko"!==n.locale&&(Mn||"onCompositionStart"!==v?"onCompositionEnd"===v&&Mn&&(x=Jt()):(Yt="value"in(Xt=s)?Xt.value:Xt.textContent,Mn=!0)),0<(y=Jc(r,v)).length&&(v=new bn(v,e,null,n,s),o.push({event:v,listeners:y}),(x||null!==(x=zn(n)))&&(v.data=x))),(x=_n?function(e,t){switch(e){case"compositionend":return zn(t);case"keypress":return 32!==t.which?null:(Fn=!0,Dn);case"textInput":return(e=t.data)===Dn&&Fn?null:e;default:return null}}(e,n):function(e,t){if(Mn)return"compositionend"===e||!Rn&&Ln(e,t)?(e=Jt(),Qt=Yt=Xt=null,Mn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return On&&"ko"!==t.locale?null:t.data}}(e,n))&&0<(v=Jc(r,"onBeforeInput")).length&&(y=new bn("onBeforeInput","beforeinput",null,n,s),o.push({event:y,listeners:v}),y.data=x),function(e,t,n,r,s){if("submit"===t&&n&&n.stateNode===s){var a=Mc((s[Ue]||null).action),i=r.submitter;i&&null!==(t=(t=i[Ue]||null)?Mc(t.formAction):i.getAttribute("formAction"))&&(a=t,i=null);var o=new ln("action","action",null,r,s);e.push({event:o,listeners:[{instance:null,listener:function(){if(r.defaultPrevented){if(0!==$c){var e=i?Pc(s,i):new FormData(s);Mi(n,{pending:!0,data:e,method:s.method,action:a},null,e)}}else"function"==typeof a&&(o.preventDefault(),e=i?Pc(s,i):new FormData(s),Mi(n,{pending:!0,data:e,method:s.method,action:a},a,e))},currentTarget:s}]})}}(o,e,r,n,s)}Gc(o,t)}))}function Qc(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Jc(e,t){for(var n=t+"Capture",r=[];null!==e;){var s=e,a=s.stateNode;if(5!==(s=s.tag)&&26!==s&&27!==s||null===a||(null!=(s=Ht(e,n))&&r.unshift(Qc(e,s,a)),null!=(s=Ht(e,t))&&r.push(Qc(e,s,a))),3===e.tag)return r;e=e.return}return[]}function Zc(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag&&27!==e.tag);return e||null}function eh(e,t,n,r,s){for(var a=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(o=o.tag,null!==l&&l===r)break;5!==o&&26!==o&&27!==o||null===u||(l=u,s?null!=(u=Ht(n,a))&&i.unshift(Qc(n,u,l)):s||null!=(u=Ht(n,a))&&i.push(Qc(n,u,l))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var th=/\r\n?/g,nh=/\u0000|\uFFFD/g;function rh(e){return("string"==typeof e?e:""+e).replace(th,"\n").replace(nh,"")}function sh(e,t){return t=rh(t),rh(e)===t}function ah(){}function ih(e,t,n,s,a,i){switch(n){case"children":"string"==typeof s?"body"===t||"textarea"===t&&""===s||Rt(e,s):("number"==typeof s||"bigint"==typeof s)&&"body"!==t&&Rt(e,""+s);break;case"className":ct(e,"class",s);break;case"tabIndex":ct(e,"tabindex",s);break;case"dir":case"role":case"viewBox":case"width":case"height":ct(e,n,s);break;case"style":Ot(e,s,i);break;case"data":if("object"!==t){ct(e,"data",s);break}case"src":case"href":if(""===s&&("a"!==t||"href"!==n)){e.removeAttribute(n);break}if(null==s||"function"==typeof s||"symbol"==typeof s||"boolean"==typeof s){e.removeAttribute(n);break}s=zt(""+s),e.setAttribute(n,s);break;case"action":case"formAction":if("function"==typeof s){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}if("function"==typeof i&&("formAction"===n?("input"!==t&&ih(e,t,"name",a.name,a,null),ih(e,t,"formEncType",a.formEncType,a,null),ih(e,t,"formMethod",a.formMethod,a,null),ih(e,t,"formTarget",a.formTarget,a,null)):(ih(e,t,"encType",a.encType,a,null),ih(e,t,"method",a.method,a,null),ih(e,t,"target",a.target,a,null))),null==s||"symbol"==typeof s||"boolean"==typeof s){e.removeAttribute(n);break}s=zt(""+s),e.setAttribute(n,s);break;case"onClick":null!=s&&(e.onclick=ah);break;case"onScroll":null!=s&&Hc("scroll",e);break;case"onScrollEnd":null!=s&&Hc("scrollend",e);break;case"dangerouslySetInnerHTML":if(null!=s){if("object"!=typeof s||!("__html"in s))throw Error(r(61));if(null!=(n=s.__html)){if(null!=a.children)throw Error(r(60));e.innerHTML=n}}break;case"multiple":e.multiple=s&&"function"!=typeof s&&"symbol"!=typeof s;break;case"muted":e.muted=s&&"function"!=typeof s&&"symbol"!=typeof s;break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":case"autoFocus":break;case"xlinkHref":if(null==s||"function"==typeof s||"boolean"==typeof s||"symbol"==typeof s){e.removeAttribute("xlink:href");break}n=zt(""+s),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":null!=s&&"function"!=typeof s&&"symbol"!=typeof s?e.setAttribute(n,""+s):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":s&&"function"!=typeof s&&"symbol"!=typeof s?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":!0===s?e.setAttribute(n,""):!1!==s&&null!=s&&"function"!=typeof s&&"symbol"!=typeof s?e.setAttribute(n,s):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":null!=s&&"function"!=typeof s&&"symbol"!=typeof s&&!isNaN(s)&&1<=s?e.setAttribute(n,s):e.removeAttribute(n);break;case"rowSpan":case"start":null==s||"function"==typeof s||"symbol"==typeof s||isNaN(s)?e.removeAttribute(n):e.setAttribute(n,s);break;case"popover":Hc("beforetoggle",e),Hc("toggle",e),ut(e,"popover",s);break;case"xlinkActuate":ht(e,"http://www.w3.org/1999/xlink","xlink:actuate",s);break;case"xlinkArcrole":ht(e,"http://www.w3.org/1999/xlink","xlink:arcrole",s);break;case"xlinkRole":ht(e,"http://www.w3.org/1999/xlink","xlink:role",s);break;case"xlinkShow":ht(e,"http://www.w3.org/1999/xlink","xlink:show",s);break;case"xlinkTitle":ht(e,"http://www.w3.org/1999/xlink","xlink:title",s);break;case"xlinkType":ht(e,"http://www.w3.org/1999/xlink","xlink:type",s);break;case"xmlBase":ht(e,"http://www.w3.org/XML/1998/namespace","xml:base",s);break;case"xmlLang":ht(e,"http://www.w3.org/XML/1998/namespace","xml:lang",s);break;case"xmlSpace":ht(e,"http://www.w3.org/XML/1998/namespace","xml:space",s);break;case"is":ut(e,"is",s);break;case"innerText":case"textContent":break;default:(!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&ut(e,n=Ft.get(n)||n,s)}}function oh(e,t,n,s,a,i){switch(n){case"style":Ot(e,s,i);break;case"dangerouslySetInnerHTML":if(null!=s){if("object"!=typeof s||!("__html"in s))throw Error(r(61));if(null!=(n=s.__html)){if(null!=a.children)throw Error(r(60));e.innerHTML=n}}break;case"children":"string"==typeof s?Rt(e,s):("number"==typeof s||"bigint"==typeof s)&&Rt(e,""+s);break;case"onScroll":null!=s&&Hc("scroll",e);break;case"onScrollEnd":null!=s&&Hc("scrollend",e);break;case"onClick":null!=s&&(e.onclick=ah);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":case"innerText":case"textContent":break;default:tt.hasOwnProperty(n)||("o"!==n[0]||"n"!==n[1]||(a=n.endsWith("Capture"),t=n.slice(2,a?n.length-7:void 0),"function"==typeof(i=null!=(i=e[Ue]||null)?i[n]:null)&&e.removeEventListener(t,i,a),"function"!=typeof s)?n in e?e[n]=s:!0===s?e.setAttribute(n,""):ut(e,n,s):("function"!=typeof i&&null!==i&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,s,a)))}}function lh(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Hc("error",e),Hc("load",e);var s,a=!1,i=!1;for(s in n)if(n.hasOwnProperty(s)){var o=n[s];if(null!=o)switch(s){case"src":a=!0;break;case"srcSet":i=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(r(137,t));default:ih(e,t,s,o,n,null)}}return i&&ih(e,t,"srcSet",n.srcSet,n,null),void(a&&ih(e,t,"src",n.src,n,null));case"input":Hc("invalid",e);var l=s=o=i=null,u=null,c=null;for(a in n)if(n.hasOwnProperty(a)){var h=n[a];if(null!=h)switch(a){case"name":i=h;break;case"type":o=h;break;case"checked":u=h;break;case"defaultChecked":c=h;break;case"value":s=h;break;case"defaultValue":l=h;break;case"children":case"dangerouslySetInnerHTML":if(null!=h)throw Error(r(137,t));break;default:ih(e,t,a,h,n,null)}}return Ct(e,s,l,u,c,o,i,!1),void xt(e);case"select":for(i in Hc("invalid",e),a=o=s=null,n)if(n.hasOwnProperty(i)&&null!=(l=n[i]))switch(i){case"value":s=l;break;case"defaultValue":o=l;break;case"multiple":a=l;default:ih(e,t,i,l,n,null)}return t=s,n=o,e.multiple=!!a,void(null!=t?Nt(e,!!a,t,!1):null!=n&&Nt(e,!!a,n,!0));case"textarea":for(o in Hc("invalid",e),s=i=a=null,n)if(n.hasOwnProperty(o)&&null!=(l=n[o]))switch(o){case"value":a=l;break;case"defaultValue":i=l;break;case"children":s=l;break;case"dangerouslySetInnerHTML":if(null!=l)throw Error(r(91));break;default:ih(e,t,o,l,n,null)}return $t(e,a,i,s),void xt(e);case"option":for(u in n)n.hasOwnProperty(u)&&null!=(a=n[u])&&("selected"===u?e.selected=a&&"function"!=typeof a&&"symbol"!=typeof a:ih(e,t,u,a,n,null));return;case"dialog":Hc("beforetoggle",e),Hc("toggle",e),Hc("cancel",e),Hc("close",e);break;case"iframe":case"object":Hc("load",e);break;case"video":case"audio":for(a=0;a<Wc.length;a++)Hc(Wc[a],e);break;case"image":Hc("error",e),Hc("load",e);break;case"details":Hc("toggle",e);break;case"embed":case"source":case"link":Hc("error",e),Hc("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(c in n)if(n.hasOwnProperty(c)&&null!=(a=n[c]))switch(c){case"children":case"dangerouslySetInnerHTML":throw Error(r(137,t));default:ih(e,t,c,a,n,null)}return;default:if(Dt(t)){for(h in n)n.hasOwnProperty(h)&&void 0!==(a=n[h])&&oh(e,t,h,a,n,void 0);return}}for(l in n)n.hasOwnProperty(l)&&null!=(a=n[l])&&ih(e,t,l,a,n,null)}var uh=null,ch=null;function hh(e){return 9===e.nodeType?e:e.ownerDocument}function dh(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function ph(e,t){if(0===e)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return 1===e&&"foreignObject"===t?0:e}function fh(e,t){return"textarea"===e||"noscript"===e||"string"==typeof t.children||"number"==typeof t.children||"bigint"==typeof t.children||"object"==typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var gh=null,mh="function"==typeof setTimeout?setTimeout:void 0,bh="function"==typeof clearTimeout?clearTimeout:void 0,yh="function"==typeof Promise?Promise:void 0,xh="function"==typeof queueMicrotask?queueMicrotask:void 0!==yh?function(e){return yh.resolve(null).then(e).catch(vh)}:mh;function vh(e){setTimeout((function(){throw e}))}function wh(e){return"head"===e}function kh(e,t){var n=t,r=0,s=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0<r&&8>r){n=r;var i=e.ownerDocument;if(1&n&&$h(i.documentElement),2&n&&$h(i.body),4&n)for($h(n=i.head),i=n.firstChild;i;){var o=i.nextSibling,l=i.nodeName;i[qe]||"SCRIPT"===l||"STYLE"===l||"LINK"===l&&"stylesheet"===i.rel.toLowerCase()||n.removeChild(i),i=o}}if(0===s)return e.removeChild(a),void Fd(t);s--}else"$"===n||"$?"===n||"$!"===n?s++:r=n.charCodeAt(0)-48;else r=0;n=a}while(n);Fd(t)}function Sh(e){var t=e.firstChild;for(t&&10===t.nodeType&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":Sh(n),Ke(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if("stylesheet"===n.rel.toLowerCase())continue}e.removeChild(n)}}function Ih(e){return"$!"===e.data||"$?"===e.data&&"complete"===e.ownerDocument.readyState}function Ch(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t||"F!"===t||"F"===t)break;if("/$"===t)return null}}return e}var Th=null;function Nh(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}function Eh(e,t,n){switch(t=hh(n),e){case"html":if(!(e=t.documentElement))throw Error(r(452));return e;case"head":if(!(e=t.head))throw Error(r(453));return e;case"body":if(!(e=t.body))throw Error(r(454));return e;default:throw Error(r(451))}}function $h(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);Ke(e)}var Rh=new Map,Ah=new Set;function _h(e){return"function"==typeof e.getRootNode?e.getRootNode():9===e.nodeType?e:e.ownerDocument}var Oh=V.d;V.d={f:function(){var e=Oh.f(),t=Xu();return e||t},r:function(e){var t=Ye(e);null!==t&&5===t.tag&&"form"===t.type?Bi(t):Oh.r(e)},D:function(e){Oh.D(e),Fh("dns-prefetch",e,null)},C:function(e,t){Oh.C(e,t),Fh("preconnect",e,t)},L:function(e,t,n){Oh.L(e,t,n);var r=Dh;if(r&&e&&t){var s='link[rel="preload"][as="'+St(t)+'"]';"image"===t&&n&&n.imageSrcSet?(s+='[imagesrcset="'+St(n.imageSrcSet)+'"]',"string"==typeof n.imageSizes&&(s+='[imagesizes="'+St(n.imageSizes)+'"]')):s+='[href="'+St(e)+'"]';var a=s;switch(t){case"style":a=zh(e);break;case"script":a=Bh(e)}Rh.has(a)||(e=u({rel:"preload",href:"image"===t&&n&&n.imageSrcSet?void 0:e,as:t},n),Rh.set(a,e),null!==r.querySelector(s)||"style"===t&&r.querySelector(Mh(a))||"script"===t&&r.querySelector(Uh(a))||(lh(t=r.createElement("link"),"link",e),Ze(t),r.head.appendChild(t)))}},m:function(e,t){Oh.m(e,t);var n=Dh;if(n&&e){var r=t&&"string"==typeof t.as?t.as:"script",s='link[rel="modulepreload"][as="'+St(r)+'"][href="'+St(e)+'"]',a=s;switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":a=Bh(e)}if(!Rh.has(a)&&(e=u({rel:"modulepreload",href:e},t),Rh.set(a,e),null===n.querySelector(s))){switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(Uh(a)))return}lh(r=n.createElement("link"),"link",e),Ze(r),n.head.appendChild(r)}}},X:function(e,t){Oh.X(e,t);var n=Dh;if(n&&e){var r=Je(n).hoistableScripts,s=Bh(e),a=r.get(s);a||((a=n.querySelector(Uh(s)))||(e=u({src:e,async:!0},t),(t=Rh.get(s))&&Hh(e,t),Ze(a=n.createElement("script")),lh(a,"link",e),n.head.appendChild(a)),a={type:"script",instance:a,count:1,state:null},r.set(s,a))}},S:function(e,t,n){Oh.S(e,t,n);var r=Dh;if(r&&e){var s=Je(r).hoistableStyles,a=zh(e);t=t||"default";var i=s.get(a);if(!i){var o={loading:0,preload:null};if(i=r.querySelector(Mh(a)))o.loading=5;else{e=u({rel:"stylesheet",href:e,"data-precedence":t},n),(n=Rh.get(a))&&Gh(e,n);var l=i=r.createElement("link");Ze(l),lh(l,"link",e),l._p=new Promise((function(e,t){l.onload=e,l.onerror=t})),l.addEventListener("load",(function(){o.loading|=1})),l.addEventListener("error",(function(){o.loading|=2})),o.loading|=4,Vh(i,t,r)}i={type:"stylesheet",instance:i,count:1,state:o},s.set(a,i)}}},M:function(e,t){Oh.M(e,t);var n=Dh;if(n&&e){var r=Je(n).hoistableScripts,s=Bh(e),a=r.get(s);a||((a=n.querySelector(Uh(s)))||(e=u({src:e,async:!0,type:"module"},t),(t=Rh.get(s))&&Hh(e,t),Ze(a=n.createElement("script")),lh(a,"link",e),n.head.appendChild(a)),a={type:"script",instance:a,count:1,state:null},r.set(s,a))}}};var Dh="undefined"==typeof document?null:document;function Fh(e,t,n){var r=Dh;if(r&&"string"==typeof t&&t){var s=St(t);s='link[rel="'+e+'"][href="'+s+'"]',"string"==typeof n&&(s+='[crossorigin="'+n+'"]'),Ah.has(s)||(Ah.add(s),e={rel:e,crossOrigin:n,href:t},null===r.querySelector(s)&&(lh(t=r.createElement("link"),"link",e),Ze(t),r.head.appendChild(t)))}}function Lh(e,t,n,s){var a,i,o,l,u=(u=J.current)?_h(u):null;if(!u)throw Error(r(446));switch(e){case"meta":case"title":return null;case"style":return"string"==typeof n.precedence&&"string"==typeof n.href?(t=zh(n.href),(s=(n=Je(u).hoistableStyles).get(t))||(s={type:"style",instance:null,count:0,state:null},n.set(t,s)),s):{type:"void",instance:null,count:0,state:null};case"link":if("stylesheet"===n.rel&&"string"==typeof n.href&&"string"==typeof n.precedence){e=zh(n.href);var c=Je(u).hoistableStyles,h=c.get(e);if(h||(u=u.ownerDocument||u,h={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},c.set(e,h),(c=u.querySelector(Mh(e)))&&!c._p&&(h.instance=c,h.state.loading=5),Rh.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},Rh.set(e,n),c||(a=u,i=e,o=n,l=h.state,a.querySelector('link[rel="preload"][as="style"]['+i+"]")?l.loading=1:(i=a.createElement("link"),l.preload=i,i.addEventListener("load",(function(){return l.loading|=1})),i.addEventListener("error",(function(){return l.loading|=2})),lh(i,"link",o),Ze(i),a.head.appendChild(i))))),t&&null===s)throw Error(r(528,""));return h}if(t&&null!==s)throw Error(r(529,""));return null;case"script":return t=n.async,"string"==typeof(n=n.src)&&t&&"function"!=typeof t&&"symbol"!=typeof t?(t=Bh(n),(s=(n=Je(u).hoistableScripts).get(t))||(s={type:"script",instance:null,count:0,state:null},n.set(t,s)),s):{type:"void",instance:null,count:0,state:null};default:throw Error(r(444,e))}}function zh(e){return'href="'+St(e)+'"'}function Mh(e){return'link[rel="stylesheet"]['+e+"]"}function Ph(e){return u({},e,{"data-precedence":e.precedence,precedence:null})}function Bh(e){return'[src="'+St(e)+'"]'}function Uh(e){return"script[async]"+e}function Wh(e,t,n){if(t.count++,null===t.instance)switch(t.type){case"style":var s=e.querySelector('style[data-href~="'+St(n.href)+'"]');if(s)return t.instance=s,Ze(s),s;var a=u({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return Ze(s=(e.ownerDocument||e).createElement("style")),lh(s,"style",a),Vh(s,n.precedence,e),t.instance=s;case"stylesheet":a=zh(n.href);var i=e.querySelector(Mh(a));if(i)return t.state.loading|=4,t.instance=i,Ze(i),i;s=Ph(n),(a=Rh.get(a))&&Gh(s,a),Ze(i=(e.ownerDocument||e).createElement("link"));var o=i;return o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),lh(i,"link",s),t.state.loading|=4,Vh(i,n.precedence,e),t.instance=i;case"script":return i=Bh(n.src),(a=e.querySelector(Uh(i)))?(t.instance=a,Ze(a),a):(s=n,(a=Rh.get(i))&&Hh(s=u({},n),a),Ze(a=(e=e.ownerDocument||e).createElement("script")),lh(a,"link",s),e.head.appendChild(a),t.instance=a);case"void":return null;default:throw Error(r(443,t.type))}else"stylesheet"===t.type&&!(4&t.state.loading)&&(s=t.instance,t.state.loading|=4,Vh(s,n.precedence,e));return t.instance}function Vh(e,t,n){for(var r=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),s=r.length?r[r.length-1]:null,a=s,i=0;i<r.length;i++){var o=r[i];if(o.dataset.precedence===t)a=o;else if(a!==s)break}a?a.parentNode.insertBefore(e,a.nextSibling):(t=9===n.nodeType?n.head:n).insertBefore(e,t.firstChild)}function Gh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.title&&(e.title=t.title)}function Hh(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.integrity&&(e.integrity=t.integrity)}var jh=null;function qh(e,t,n){if(null===jh){var r=new Map,s=jh=new Map;s.set(n,r)}else(r=(s=jh).get(n))||(r=new Map,s.set(n,r));if(r.has(e))return r;for(r.set(e,null),n=n.getElementsByTagName(e),s=0;s<n.length;s++){var a=n[s];if(!(a[qe]||a[Be]||"link"===e&&"stylesheet"===a.getAttribute("rel"))&&"http://www.w3.org/2000/svg"!==a.namespaceURI){var i=a.getAttribute(t)||"";i=e+i;var o=r.get(i);o?o.push(a):r.set(i,[a])}}return r}function Kh(e,t,n){(e=e.ownerDocument||e).head.insertBefore(n,"title"===t?e.querySelector("head > title"):null)}function Xh(e){return!!("stylesheet"!==e.type||3&e.state.loading)}var Yh=null;function Qh(){}function Jh(){if(this.count--,0===this.count)if(this.stylesheets)ed(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}var Zh=null;function ed(e,t){e.stylesheets=null,null!==e.unsuspend&&(e.count++,Zh=new Map,t.forEach(td,e),Zh=null,Jh.call(e))}function td(e,t){if(!(4&t.state.loading)){var n=Zh.get(e);if(n)var r=n.get(null);else{n=new Map,Zh.set(e,n);for(var s=e.querySelectorAll("link[data-precedence],style[data-precedence]"),a=0;a<s.length;a++){var i=s[a];"LINK"!==i.nodeName&&"not all"===i.getAttribute("media")||(n.set(i.dataset.precedence,i),r=i)}r&&n.set(null,r)}i=(s=t.instance).getAttribute("data-precedence"),(a=n.get(i)||r)===r&&n.set(null,s),n.set(i,s),this.count++,r=Jh.bind(this),s.addEventListener("load",r),s.addEventListener("error",r),a?a.parentNode.insertBefore(s,a.nextSibling):(e=9===e.nodeType?e.head:e).insertBefore(s,e.firstChild),t.state.loading|=4}}var nd={$$typeof:N,Provider:null,Consumer:null,_currentValue:G,_currentValue2:G,_threadCount:0};function rd(e,t,n,r,s,a,i,o){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=_e(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=_e(0),this.hiddenUpdates=_e(null),this.identifierPrefix=r,this.onUncaughtError=s,this.onCaughtError=a,this.onRecoverableError=i,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=o,this.incompleteTransitions=new Map}function sd(e,t,n,r,s,a,i,o,l,u,c,h){return e=new rd(e,t,n,i,o,l,u,h),t=1,!0===a&&(t|=24),a=Gr(3,null,null,t),e.current=a,a.stateNode=e,(t=Us()).refCount++,e.pooledCache=t,t.refCount++,a.memoizedState={element:r,isDehydrated:n,cache:t},ca(a),e}function ad(e){return e?e=Wr:Wr}function id(e,t,n,r,s,a){s=ad(s),null===r.context?r.context=s:r.pendingContext=s,(r=da(t)).payload={element:n},null!==(a=void 0===a?null:a)&&(r.callback=a),null!==(n=pa(e,r,t))&&(Gu(n,0,t),fa(n,e,t))}function od(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function ld(e,t){od(e,t),(e=e.alternate)&&od(e,t)}function ud(e){if(13===e.tag){var t=Pr(e,67108864);null!==t&&Gu(t,0,67108864),ld(e,67108864)}}var cd=!0;function hd(e,t,n,r){var s=W.T;W.T=null;var a=V.p;try{V.p=2,pd(e,t,n,r)}finally{V.p=a,W.T=s}}function dd(e,t,n,r){var s=W.T;W.T=null;var a=V.p;try{V.p=8,pd(e,t,n,r)}finally{V.p=a,W.T=s}}function pd(e,t,n,r){if(cd){var s=fd(r);if(null===s)Yc(e,t,r,gd,n),Td(e,r);else if(function(e,t,n,r,s){switch(t){case"focusin":return xd=Nd(xd,e,t,n,r,s),!0;case"dragenter":return vd=Nd(vd,e,t,n,r,s),!0;case"mouseover":return wd=Nd(wd,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return kd.set(a,Nd(kd.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,Sd.set(a,Nd(Sd.get(a)||null,e,t,n,r,s)),!0}return!1}(s,e,t,n,r))r.stopPropagation();else if(Td(e,r),4&t&&-1<Cd.indexOf(e)){for(;null!==s;){var a=Ye(s);if(null!==a)switch(a.tag){case 3:if((a=a.stateNode).current.memoizedState.isDehydrated){var i=Te(a.pendingLanes);if(0!==i){var o=a;for(o.pendingLanes|=2,o.entangledLanes|=2;i;){var l=1<<31-we(i);o.entanglements[1]|=l,i&=~l}Rc(a),!(6&cu)&&(Ru=ue()+500,Ac(0))}}break;case 13:null!==(o=Pr(a,2))&&Gu(o,0,2),Xu(),ld(a,2)}if(null===(a=fd(r))&&Yc(e,t,r,gd,n),a===s)break;s=a}null!==s&&r.stopPropagation()}else Yc(e,t,r,null,n)}}function fd(e){return md(e=Pt(e))}var gd=null;function md(e){if(gd=null,null!==(e=Xe(e))){var t=a(e);if(null===t)e=null;else{var n=t.tag;if(13===n){if(null!==(e=i(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return gd=e,null}function bd(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ce()){case he:return 2;case de:return 8;case pe:case fe:return 32;case ge:return 268435456;default:return 32}default:return 32}}var yd=!1,xd=null,vd=null,wd=null,kd=new Map,Sd=new Map,Id=[],Cd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function Td(e,t){switch(e){case"focusin":case"focusout":xd=null;break;case"dragenter":case"dragleave":vd=null;break;case"mouseover":case"mouseout":wd=null;break;case"pointerover":case"pointerout":kd.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Sd.delete(t.pointerId)}}function Nd(e,t,n,r,s,a){return null===e||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},null!==t&&null!==(t=Ye(t))&&ud(t),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function Ed(e){var t=Xe(e.target);if(null!==t){var n=a(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=i(n)))return e.blockedOn=t,void function(e){var t=V.p;try{return V.p=e,function(){if(13===n.tag){var e=Wu();e=Le(e);var t=Pr(n,e);null!==t&&Gu(t,0,e),ld(n,e)}}()}finally{V.p=t}}(e.priority)}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function $d(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=fd(e.nativeEvent);if(null!==n)return null!==(t=Ye(n))&&ud(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);Mt=r,n.target.dispatchEvent(r),Mt=null,t.shift()}return!0}function Rd(e,t,n){$d(e)&&n.delete(t)}function Ad(){yd=!1,null!==xd&&$d(xd)&&(xd=null),null!==vd&&$d(vd)&&(vd=null),null!==wd&&$d(wd)&&(wd=null),kd.forEach(Rd),Sd.forEach(Rd)}function _d(t,n){t.blockedOn===n&&(t.blockedOn=null,yd||(yd=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,Ad)))}var Od=null;function Dd(t){Od!==t&&(Od=t,e.unstable_scheduleCallback(e.unstable_NormalPriority,(function(){Od===t&&(Od=null);for(var e=0;e<t.length;e+=3){var n=t[e],r=t[e+1],s=t[e+2];if("function"!=typeof r){if(null===md(r||n))continue;break}var a=Ye(n);null!==a&&(t.splice(e,3),e-=3,Mi(a,{pending:!0,data:s,method:n.method,action:r},r,s))}})))}function Fd(e){function t(t){return _d(t,e)}null!==xd&&_d(xd,e),null!==vd&&_d(vd,e),null!==wd&&_d(wd,e),kd.forEach(t),Sd.forEach(t);for(var n=0;n<Id.length;n++){var r=Id[n];r.blockedOn===e&&(r.blockedOn=null)}for(;0<Id.length&&null===(n=Id[0]).blockedOn;)Ed(n),null===n.blockedOn&&Id.shift();if(null!=(n=(e.ownerDocument||e).$$reactFormReplay))for(r=0;r<n.length;r+=3){var s=n[r],a=n[r+1],i=s[Ue]||null;if("function"==typeof a)i||Dd(n);else if(i){var o=null;if(a&&a.hasAttribute("formAction")){if(s=a,i=a[Ue]||null)o=i.formAction;else if(null!==md(s))continue}else o=i.action;"function"==typeof o?n[r+1]=o:(n.splice(r,3),r-=3),Dd(n)}}}function Ld(e){this._internalRoot=e}function zd(e){this._internalRoot=e}zd.prototype.render=Ld.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(r(409));id(t.current,Wu(),e,t,null,null)},zd.prototype.unmount=Ld.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;id(e.current,2,null,e,null,null),Xu(),t[We]=null}},zd.prototype.unstable_scheduleHydration=function(e){if(e){var t=Me();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Id.length&&0!==t&&t<Id[n].priority;n++);Id.splice(n,0,e),0===n&&Ed(e)}};var Md=t.version;if("19.1.0"!==Md)throw Error(r(527,Md,"19.1.0"));V.findDOMNode=function(e){var t=e._reactInternals;if(void 0===t){if("function"==typeof e.render)throw Error(r(188));throw e=Object.keys(e).join(","),Error(r(268,e))}return e=function(e){var t=e.alternate;if(!t){if(null===(t=a(e)))throw Error(r(188));return t!==e?null:e}for(var n=e,s=t;;){var i=n.return;if(null===i)break;var l=i.alternate;if(null===l){if(null!==(s=i.return)){n=s;continue}break}if(i.child===l.child){for(l=i.child;l;){if(l===n)return o(i),e;if(l===s)return o(i),t;l=l.sibling}throw Error(r(188))}if(n.return!==s.return)n=i,s=l;else{for(var u=!1,c=i.child;c;){if(c===n){u=!0,n=i,s=l;break}if(c===s){u=!0,s=i,n=l;break}c=c.sibling}if(!u){for(c=l.child;c;){if(c===n){u=!0,n=l,s=i;break}if(c===s){u=!0,s=l,n=i;break}c=c.sibling}if(!u)throw Error(r(189))}}if(n.alternate!==s)throw Error(r(190))}if(3!==n.tag)throw Error(r(188));return n.stateNode.current===n?e:t}(t),null===(e=null!==e?l(e):null)?null:e.stateNode};var Pd={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:W,reconcilerVersion:"19.1.0"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var Bd=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Bd.isDisabled&&Bd.supportsFiber)try{ye=Bd.inject(Pd),xe=Bd}catch(Wd){}}return w.createRoot=function(e,t){if(!s(e))throw Error(r(299));var n=!1,a="",i=To,o=No,l=Eo;return null!=t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(a=t.identifierPrefix),void 0!==t.onUncaughtError&&(i=t.onUncaughtError),void 0!==t.onCaughtError&&(o=t.onCaughtError),void 0!==t.onRecoverableError&&(l=t.onRecoverableError),void 0!==t.unstable_transitionCallbacks&&t.unstable_transitionCallbacks),t=sd(e,1,!1,null,0,n,a,i,o,l,0,null),e[We]=t.current,Kc(e),new Ld(t)},w.hydrateRoot=function(e,t,n){if(!s(e))throw Error(r(299));var a=!1,i="",o=To,l=No,u=Eo,c=null;return null!=n&&(!0===n.unstable_strictMode&&(a=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onUncaughtError&&(o=n.onUncaughtError),void 0!==n.onCaughtError&&(l=n.onCaughtError),void 0!==n.onRecoverableError&&(u=n.onRecoverableError),void 0!==n.unstable_transitionCallbacks&&n.unstable_transitionCallbacks,void 0!==n.formState&&(c=n.formState)),(t=sd(e,1,!0,t,0,a,i,o,l,u,0,c)).context=ad(null),n=t.current,(i=da(a=Le(a=Wu()))).callback=null,pa(n,i,a),n=a,t.current.lanes=n,Oe(t,n),Rc(t),e[We]=t.current,Kc(e),new zd(t)},w.version="19.1.0",w}()),v.exports));function A(e,t){return function(){return e.apply(t,arguments)}}const{toString:_}=Object.prototype,{getPrototypeOf:O}=Object,{iterator:D,toStringTag:F}=Symbol,L=(e=>t=>{const n=_.call(t);return e[n]||(e[n]=n.slice(8,-1).toLowerCase())})(Object.create(null)),z=e=>(e=e.toLowerCase(),t=>L(t)===e),M=e=>t=>typeof t===e,{isArray:P}=Array,B=M("undefined");function U(e){return null!==e&&!B(e)&&null!==e.constructor&&!B(e.constructor)&&G(e.constructor.isBuffer)&&e.constructor.isBuffer(e)}const W=z("ArrayBuffer"),V=M("string"),G=M("function"),H=M("number"),j=e=>null!==e&&"object"==typeof e,q=e=>{if("object"!==L(e))return!1;const t=O(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t)||F in e||D in e)},K=z("Date"),X=z("File"),Y=z("Blob"),Q=z("FileList"),J=z("URLSearchParams"),[Z,ee,te,ne]=["ReadableStream","Request","Response","Headers"].map(z);function re(e,t,{allOwnKeys:n=!1}={}){if(null==e)return;let r,s;if("object"!=typeof e&&(e=[e]),P(e))for(r=0,s=e.length;r<s;r++)t.call(null,e[r],r,e);else{if(U(e))return;const s=n?Object.getOwnPropertyNames(e):Object.keys(e),a=s.length;let i;for(r=0;r<a;r++)i=s[r],t.call(null,e[i],i,e)}}function se(e,t){if(U(e))return null;t=t.toLowerCase();const n=Object.keys(e);let r,s=n.length;for(;s-- >0;)if(r=n[s],t===r.toLowerCase())return r;return null}const ae="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:global,ie=e=>!B(e)&&e!==ae,oe=(e=>t=>e&&t instanceof e)("undefined"!=typeof Uint8Array&&O(Uint8Array)),le=z("HTMLFormElement"),ue=(({hasOwnProperty:e})=>(t,n)=>e.call(t,n))(Object.prototype),ce=z("RegExp"),he=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};re(n,((n,s)=>{let a;!1!==(a=t(n,s,e))&&(r[s]=a||n)})),Object.defineProperties(e,r)},de=z("AsyncFunction"),pe=(fe="function"==typeof setImmediate,ge=G(ae.postMessage),fe?setImmediate:ge?(me=`axios@${Math.random()}`,be=[],ae.addEventListener("message",(({source:e,data:t})=>{e===ae&&t===me&&be.length&&be.shift()()}),!1),e=>{be.push(e),ae.postMessage(me,"*")}):e=>setTimeout(e));var fe,ge,me,be;const ye="undefined"!=typeof queueMicrotask?queueMicrotask.bind(ae):"undefined"!=typeof process&&process.nextTick||pe,xe={isArray:P,isArrayBuffer:W,isBuffer:U,isFormData:e=>{let t;return e&&("function"==typeof FormData&&e instanceof FormData||G(e.append)&&("formdata"===(t=L(e))||"object"===t&&G(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){let t;return t="undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&W(e.buffer),t},isString:V,isNumber:H,isBoolean:e=>!0===e||!1===e,isObject:j,isPlainObject:q,isEmptyObject:e=>{if(!j(e)||U(e))return!1;try{return 0===Object.keys(e).length&&Object.getPrototypeOf(e)===Object.prototype}catch(t){return!1}},isReadableStream:Z,isRequest:ee,isResponse:te,isHeaders:ne,isUndefined:B,isDate:K,isFile:X,isBlob:Y,isRegExp:ce,isFunction:G,isStream:e=>j(e)&&G(e.pipe),isURLSearchParams:J,isTypedArray:oe,isFileList:Q,forEach:re,merge:function e(){const{caseless:t}=ie(this)&&this||{},n={},r=(r,s)=>{const a=t&&se(n,s)||s;q(n[a])&&q(r)?n[a]=e(n[a],r):q(r)?n[a]=e({},r):P(r)?n[a]=r.slice():n[a]=r};for(let s=0,a=arguments.length;s<a;s++)arguments[s]&&re(arguments[s],r);return n},extend:(e,t,n,{allOwnKeys:r}={})=>(re(t,((t,r)=>{n&&G(t)?e[r]=A(t,n):e[r]=t}),{allOwnKeys:r}),e),trim:e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:e=>(65279===e.charCodeAt(0)&&(e=e.slice(1)),e),inherits:(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:(e,t,n,r)=>{let s,a,i;const o={};if(t=t||{},null==e)return t;do{for(s=Object.getOwnPropertyNames(e),a=s.length;a-- >0;)i=s[a],r&&!r(i,e,t)||o[i]||(t[i]=e[i],o[i]=!0);e=!1!==n&&O(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:L,kindOfTest:z,endsWith:(e,t,n)=>{e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return-1!==r&&r===n},toArray:e=>{if(!e)return null;if(P(e))return e;let t=e.length;if(!H(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},forEachEntry:(e,t)=>{const n=(e&&e[D]).call(e);let r;for(;(r=n.next())&&!r.done;){const n=r.value;t.call(e,n[0],n[1])}},matchAll:(e,t)=>{let n;const r=[];for(;null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:le,hasOwnProperty:ue,hasOwnProp:ue,reduceDescriptors:he,freezeMethods:e=>{he(e,((t,n)=>{if(G(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=e[n];G(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:(e,t)=>{const n={},r=e=>{e.forEach((e=>{n[e]=!0}))};return P(e)?r(e):r(String(e).split(t)),n},toCamelCase:e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n})),noop:()=>{},toFiniteNumber:(e,t)=>null!=e&&Number.isFinite(e=+e)?e:t,findKey:se,global:ae,isContextDefined:ie,isSpecCompliantForm:function(e){return!!(e&&G(e.append)&&"FormData"===e[F]&&e[D])},toJSONObject:e=>{const t=new Array(10),n=(e,r)=>{if(j(e)){if(t.indexOf(e)>=0)return;if(U(e))return e;if(!("toJSON"in e)){t[r]=e;const s=P(e)?[]:{};return re(e,((e,t)=>{const a=n(e,r+1);!B(a)&&(s[t]=a)})),t[r]=void 0,s}}return e};return n(e,0)},isAsyncFn:de,isThenable:e=>e&&(j(e)||G(e))&&G(e.then)&&G(e.catch),setImmediate:pe,asap:ye,isIterable:e=>null!=e&&G(e[D])};function ve(e,t,n,r,s){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),s&&(this.response=s,this.status=s.status?s.status:null)}xe.inherits(ve,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:xe.toJSONObject(this.config),code:this.code,status:this.status}}});const we=ve.prototype,ke={};function Se(e){return xe.isPlainObject(e)||xe.isArray(e)}function Ie(e){return xe.endsWith(e,"[]")?e.slice(0,-2):e}function Ce(e,t,n){return e?e.concat(t).map((function(e,t){return e=Ie(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((e=>{ke[e]={value:e}})),Object.defineProperties(ve,ke),Object.defineProperty(we,"isAxiosError",{value:!0}),ve.from=(e,t,n,r,s,a)=>{const i=Object.create(we);return xe.toFlatObject(e,i,(function(e){return e!==Error.prototype}),(e=>"isAxiosError"!==e)),ve.call(i,e.message,t,n,r,s),i.cause=e,i.name=e.name,a&&Object.assign(i,a),i};const Te=xe.toFlatObject(xe,{},null,(function(e){return/^is[A-Z]/.test(e)}));function Ne(e,t,n){if(!xe.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;const r=(n=xe.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!xe.isUndefined(t[e])}))).metaTokens,s=n.visitor||u,a=n.dots,i=n.indexes,o=(n.Blob||"undefined"!=typeof Blob&&Blob)&&xe.isSpecCompliantForm(t);if(!xe.isFunction(s))throw new TypeError("visitor must be a function");function l(e){if(null===e)return"";if(xe.isDate(e))return e.toISOString();if(xe.isBoolean(e))return e.toString();if(!o&&xe.isBlob(e))throw new ve("Blob is not supported. Use a Buffer instead.");return xe.isArrayBuffer(e)||xe.isTypedArray(e)?o&&"function"==typeof Blob?new Blob([e]):Buffer.from(e):e}function u(e,n,s){let o=e;if(e&&!s&&"object"==typeof e)if(xe.endsWith(n,"{}"))n=r?n:n.slice(0,-2),e=JSON.stringify(e);else if(xe.isArray(e)&&function(e){return xe.isArray(e)&&!e.some(Se)}(e)||(xe.isFileList(e)||xe.endsWith(n,"[]"))&&(o=xe.toArray(e)))return n=Ie(n),o.forEach((function(e,r){!xe.isUndefined(e)&&null!==e&&t.append(!0===i?Ce([n],r,a):null===i?n:n+"[]",l(e))})),!1;return!!Se(e)||(t.append(Ce(s,n,a),l(e)),!1)}const c=[],h=Object.assign(Te,{defaultVisitor:u,convertValue:l,isVisitable:Se});if(!xe.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!xe.isUndefined(n)){if(-1!==c.indexOf(n))throw Error("Circular reference detected in "+r.join("."));c.push(n),xe.forEach(n,(function(n,a){!0===(!(xe.isUndefined(n)||null===n)&&s.call(t,n,xe.isString(a)?a.trim():a,r,h))&&e(n,r?r.concat(a):[a])})),c.pop()}}(e),t}function Ee(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function $e(e,t){this._pairs=[],e&&Ne(e,this,t)}const Re=$e.prototype;function Ae(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function _e(e,t,n){if(!t)return e;const r=n&&n.encode||Ae;xe.isFunction(n)&&(n={serialize:n});const s=n&&n.serialize;let a;if(a=s?s(t,n):xe.isURLSearchParams(t)?t.toString():new $e(t,n).toString(r),a){const t=e.indexOf("#");-1!==t&&(e=e.slice(0,t)),e+=(-1===e.indexOf("?")?"?":"&")+a}return e}Re.append=function(e,t){this._pairs.push([e,t])},Re.toString=function(e){const t=e?function(t){return e.call(this,t,Ee)}:Ee;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};class Oe{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){xe.forEach(this.handlers,(function(t){null!==t&&e(t)}))}}const De={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},Fe={isBrowser:!0,classes:{URLSearchParams:"undefined"!=typeof URLSearchParams?URLSearchParams:$e,FormData:"undefined"!=typeof FormData?FormData:null,Blob:"undefined"!=typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},Le="undefined"!=typeof window&&"undefined"!=typeof document,ze="object"==typeof navigator&&navigator||void 0,Me=Le&&(!ze||["ReactNative","NativeScript","NS"].indexOf(ze.product)<0),Pe="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"==typeof self.importScripts,Be=Le&&window.location.href||"http://localhost",Ue={...Object.freeze(Object.defineProperty({__proto__:null,hasBrowserEnv:Le,hasStandardBrowserEnv:Me,hasStandardBrowserWebWorkerEnv:Pe,navigator:ze,origin:Be},Symbol.toStringTag,{value:"Module"})),...Fe};function We(e){function t(e,n,r,s){let a=e[s++];if("__proto__"===a)return!0;const i=Number.isFinite(+a),o=s>=e.length;return a=!a&&xe.isArray(r)?r.length:a,o?(xe.hasOwnProp(r,a)?r[a]=[r[a],n]:r[a]=n,!i):(r[a]&&xe.isObject(r[a])||(r[a]=[]),t(e,n,r[a],s)&&xe.isArray(r[a])&&(r[a]=function(e){const t={},n=Object.keys(e);let r;const s=n.length;let a;for(r=0;r<s;r++)a=n[r],t[a]=e[a];return t}(r[a])),!i)}if(xe.isFormData(e)&&xe.isFunction(e.entries)){const n={};return xe.forEachEntry(e,((e,r)=>{t(function(e){return xe.matchAll(/\w+|\[(\w*)]/g,e).map((e=>"[]"===e[0]?"":e[1]||e[0]))}(e),r,n,0)})),n}return null}const Ve={transitional:De,adapter:["xhr","http","fetch"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,s=xe.isObject(e);if(s&&xe.isHTMLForm(e)&&(e=new FormData(e)),xe.isFormData(e))return r?JSON.stringify(We(e)):e;if(xe.isArrayBuffer(e)||xe.isBuffer(e)||xe.isStream(e)||xe.isFile(e)||xe.isBlob(e)||xe.isReadableStream(e))return e;if(xe.isArrayBufferView(e))return e.buffer;if(xe.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let a;if(s){if(n.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return Ne(e,new Ue.classes.URLSearchParams,{visitor:function(e,t,n,r){return Ue.isNode&&xe.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)},...t})}(e,this.formSerializer).toString();if((a=xe.isFileList(e))||n.indexOf("multipart/form-data")>-1){const t=this.env&&this.env.FormData;return Ne(a?{"files[]":e}:e,t&&new t,this.formSerializer)}}return s||r?(t.setContentType("application/json",!1),function(e){if(xe.isString(e))try{return(0,JSON.parse)(e),xe.trim(e)}catch(t){if("SyntaxError"!==t.name)throw t}return(0,JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){const t=this.transitional||Ve.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(xe.isResponse(e)||xe.isReadableStream(e))return e;if(e&&xe.isString(e)&&(n&&!this.responseType||r)){const n=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(s){if(n){if("SyntaxError"===s.name)throw ve.from(s,ve.ERR_BAD_RESPONSE,this,null,this.response);throw s}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Ue.classes.FormData,Blob:Ue.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};xe.forEach(["delete","get","head","post","put","patch"],(e=>{Ve.headers[e]={}}));const Ge=xe.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),He=Symbol("internals");function je(e){return e&&String(e).trim().toLowerCase()}function qe(e){return!1===e||null==e?e:xe.isArray(e)?e.map(qe):String(e)}function Ke(e,t,n,r,s){return xe.isFunction(r)?r.call(this,t,n):(s&&(t=n),xe.isString(t)?xe.isString(r)?-1!==t.indexOf(r):xe.isRegExp(r)?r.test(t):void 0:void 0)}let Xe=class{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function s(e,t,n){const s=je(t);if(!s)throw new Error("header name must be a non-empty string");const a=xe.findKey(r,s);(!a||void 0===r[a]||!0===n||void 0===n&&!1!==r[a])&&(r[a||t]=qe(e))}const a=(e,t)=>xe.forEach(e,((e,n)=>s(e,n,t)));if(xe.isPlainObject(e)||e instanceof this.constructor)a(e,t);else if(xe.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))a((e=>{const t={};let n,r,s;return e&&e.split("\n").forEach((function(e){s=e.indexOf(":"),n=e.substring(0,s).trim().toLowerCase(),r=e.substring(s+1).trim(),!n||t[n]&&Ge[n]||("set-cookie"===n?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)})),t})(e),t);else if(xe.isObject(e)&&xe.isIterable(e)){let n,r,s={};for(const t of e){if(!xe.isArray(t))throw TypeError("Object iterator must return a key-value pair");s[r=t[0]]=(n=s[r])?xe.isArray(n)?[...n,t[1]]:[n,t[1]]:t[1]}a(s,t)}else null!=e&&s(t,e,n);return this}get(e,t){if(e=je(e)){const n=xe.findKey(this,e);if(n){const e=this[n];if(!t)return e;if(!0===t)return function(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}(e);if(xe.isFunction(t))return t.call(this,e,n);if(xe.isRegExp(t))return t.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=je(e)){const n=xe.findKey(this,e);return!(!n||void 0===this[n]||t&&!Ke(0,this[n],n,t))}return!1}delete(e,t){const n=this;let r=!1;function s(e){if(e=je(e)){const s=xe.findKey(n,e);!s||t&&!Ke(0,n[s],s,t)||(delete n[s],r=!0)}}return xe.isArray(e)?e.forEach(s):s(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;for(;n--;){const s=t[n];e&&!Ke(0,this[s],s,e,!0)||(delete this[s],r=!0)}return r}normalize(e){const t=this,n={};return xe.forEach(this,((r,s)=>{const a=xe.findKey(n,s);if(a)return t[a]=qe(r),void delete t[s];const i=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((e,t,n)=>t.toUpperCase()+n))}(s):String(s).trim();i!==s&&delete t[s],t[i]=qe(r),n[i]=!0})),this}concat(...e){return this.constructor.concat(this,...e)}toJSON(e){const t=Object.create(null);return xe.forEach(this,((n,r)=>{null!=n&&!1!==n&&(t[r]=e&&xe.isArray(n)?n.join(", "):n)})),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((([e,t])=>e+": "+t)).join("\n")}getSetCookie(){return this.get("set-cookie")||[]}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e,...t){const n=new this(e);return t.forEach((e=>n.set(e))),n}static accessor(e){const t=(this[He]=this[He]={accessors:{}}).accessors,n=this.prototype;function r(e){const r=je(e);t[r]||(function(e,t){const n=xe.toCamelCase(" "+t);["get","set","has"].forEach((r=>{Object.defineProperty(e,r+n,{value:function(e,n,s){return this[r].call(this,t,e,n,s)},configurable:!0})}))}(n,e),t[r]=!0)}return xe.isArray(e)?e.forEach(r):r(e),this}};function Ye(e,t){const n=this||Ve,r=t||n,s=Xe.from(r.headers);let a=r.data;return xe.forEach(e,(function(e){a=e.call(n,a,s.normalize(),t?t.status:void 0)})),s.normalize(),a}function Qe(e){return!(!e||!e.__CANCEL__)}function Je(e,t,n){ve.call(this,null==e?"canceled":e,ve.ERR_CANCELED,t,n),this.name="CanceledError"}function Ze(e,t,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new ve("Request failed with status code "+n.status,[ve.ERR_BAD_REQUEST,ve.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}Xe.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),xe.reduceDescriptors(Xe.prototype,(({value:e},t)=>{let n=t[0].toUpperCase()+t.slice(1);return{get:()=>e,set(e){this[n]=e}}})),xe.freezeMethods(Xe),xe.inherits(Je,ve,{__CANCEL__:!0});const et=(e,t,n=3)=>{let r=0;const s=function(e,t){e=e||10;const n=new Array(e),r=new Array(e);let s,a=0,i=0;return t=void 0!==t?t:1e3,function(o){const l=Date.now(),u=r[i];s||(s=l),n[a]=o,r[a]=l;let c=i,h=0;for(;c!==a;)h+=n[c++],c%=e;if(a=(a+1)%e,a===i&&(i=(i+1)%e),l-s<t)return;const d=u&&l-u;return d?Math.round(1e3*h/d):void 0}}(50,250);return function(n,a){let i,o,l=0,u=1e3/a;const c=(n,a=Date.now())=>{l=a,i=null,o&&(clearTimeout(o),o=null),(n=>{const a=n.loaded,i=n.lengthComputable?n.total:void 0,o=a-r,l=s(o);r=a,e({loaded:a,total:i,progress:i?a/i:void 0,bytes:o,rate:l||void 0,estimated:l&&i&&a<=i?(i-a)/l:void 0,event:n,lengthComputable:null!=i,[t?"download":"upload"]:!0})})(...n)};return[(...e)=>{const t=Date.now(),n=t-l;n>=u?c(e,t):(i=e,o||(o=setTimeout((()=>{o=null,c(i)}),u-n)))},()=>i&&c(i)]}(0,n)},tt=(e,t)=>{const n=null!=e;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},nt=e=>(...t)=>xe.asap((()=>e(...t))),rt=Ue.hasStandardBrowserEnv?((e,t)=>n=>(n=new URL(n,Ue.origin),e.protocol===n.protocol&&e.host===n.host&&(t||e.port===n.port)))(new URL(Ue.origin),Ue.navigator&&/(msie|trident)/i.test(Ue.navigator.userAgent)):()=>!0,st=Ue.hasStandardBrowserEnv?{write(e,t,n,r,s,a){const i=[e+"="+encodeURIComponent(t)];xe.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),xe.isString(r)&&i.push("path="+r),xe.isString(s)&&i.push("domain="+s),!0===a&&i.push("secure"),document.cookie=i.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function at(e,t,n){let r=!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);return e&&(r||0==n)?function(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}const it=e=>e instanceof Xe?{...e}:e;function ot(e,t){t=t||{};const n={};function r(e,t,n,r){return xe.isPlainObject(e)&&xe.isPlainObject(t)?xe.merge.call({caseless:r},e,t):xe.isPlainObject(t)?xe.merge({},t):xe.isArray(t)?t.slice():t}function s(e,t,n,s){return xe.isUndefined(t)?xe.isUndefined(e)?void 0:r(void 0,e,0,s):r(e,t,0,s)}function a(e,t){if(!xe.isUndefined(t))return r(void 0,t)}function i(e,t){return xe.isUndefined(t)?xe.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function o(n,s,a){return a in t?r(n,s):a in e?r(void 0,n):void 0}const l={url:a,method:a,data:a,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,withXSRFToken:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(e,t,n)=>s(it(e),it(t),0,!0)};return xe.forEach(Object.keys({...e,...t}),(function(r){const a=l[r]||s,i=a(e[r],t[r],r);xe.isUndefined(i)&&a!==o||(n[r]=i)})),n}const lt=e=>{const t=ot({},e);let n,{data:r,withXSRFToken:s,xsrfHeaderName:a,xsrfCookieName:i,headers:o,auth:l}=t;if(t.headers=o=Xe.from(o),t.url=_e(at(t.baseURL,t.url,t.allowAbsoluteUrls),e.params,e.paramsSerializer),l&&o.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):""))),xe.isFormData(r))if(Ue.hasStandardBrowserEnv||Ue.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0);else if(!1!==(n=o.getContentType())){const[e,...t]=n?n.split(";").map((e=>e.trim())).filter(Boolean):[];o.setContentType([e||"multipart/form-data",...t].join("; "))}if(Ue.hasStandardBrowserEnv&&(s&&xe.isFunction(s)&&(s=s(t)),s||!1!==s&&rt(t.url))){const e=a&&i&&st.read(i);e&&o.set(a,e)}return t},ut="undefined"!=typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){const r=lt(e);let s=r.data;const a=Xe.from(r.headers).normalize();let i,o,l,u,c,{responseType:h,onUploadProgress:d,onDownloadProgress:p}=r;function f(){u&&u(),c&&c(),r.cancelToken&&r.cancelToken.unsubscribe(i),r.signal&&r.signal.removeEventListener("abort",i)}let g=new XMLHttpRequest;function m(){if(!g)return;const r=Xe.from("getAllResponseHeaders"in g&&g.getAllResponseHeaders());Ze((function(e){t(e),f()}),(function(e){n(e),f()}),{data:h&&"text"!==h&&"json"!==h?g.response:g.responseText,status:g.status,statusText:g.statusText,headers:r,config:e,request:g}),g=null}g.open(r.method.toUpperCase(),r.url,!0),g.timeout=r.timeout,"onloadend"in g?g.onloadend=m:g.onreadystatechange=function(){g&&4===g.readyState&&(0!==g.status||g.responseURL&&0===g.responseURL.indexOf("file:"))&&setTimeout(m)},g.onabort=function(){g&&(n(new ve("Request aborted",ve.ECONNABORTED,e,g)),g=null)},g.onerror=function(){n(new ve("Network Error",ve.ERR_NETWORK,e,g)),g=null},g.ontimeout=function(){let t=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const s=r.transitional||De;r.timeoutErrorMessage&&(t=r.timeoutErrorMessage),n(new ve(t,s.clarifyTimeoutError?ve.ETIMEDOUT:ve.ECONNABORTED,e,g)),g=null},void 0===s&&a.setContentType(null),"setRequestHeader"in g&&xe.forEach(a.toJSON(),(function(e,t){g.setRequestHeader(t,e)})),xe.isUndefined(r.withCredentials)||(g.withCredentials=!!r.withCredentials),h&&"json"!==h&&(g.responseType=r.responseType),p&&([l,c]=et(p,!0),g.addEventListener("progress",l)),d&&g.upload&&([o,u]=et(d),g.upload.addEventListener("progress",o),g.upload.addEventListener("loadend",u)),(r.cancelToken||r.signal)&&(i=t=>{g&&(n(!t||t.type?new Je(null,e,g):t),g.abort(),g=null)},r.cancelToken&&r.cancelToken.subscribe(i),r.signal&&(r.signal.aborted?i():r.signal.addEventListener("abort",i)));const b=function(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}(r.url);b&&-1===Ue.protocols.indexOf(b)?n(new ve("Unsupported protocol "+b+":",ve.ERR_BAD_REQUEST,e)):g.send(s||null)}))},ct=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let n,r=new AbortController;const s=function(e){if(!n){n=!0,i();const t=e instanceof Error?e:this.reason;r.abort(t instanceof ve?t:new Je(t instanceof Error?t.message:t))}};let a=t&&setTimeout((()=>{a=null,s(new ve(`timeout ${t} of ms exceeded`,ve.ETIMEDOUT))}),t);const i=()=>{e&&(a&&clearTimeout(a),a=null,e.forEach((e=>{e.unsubscribe?e.unsubscribe(s):e.removeEventListener("abort",s)})),e=null)};e.forEach((e=>e.addEventListener("abort",s)));const{signal:o}=r;return o.unsubscribe=()=>xe.asap(i),o}},ht=function*(e,t){let n=e.byteLength;if(n<t)return void(yield e);let r,s=0;for(;s<n;)r=s+t,yield e.slice(s,r),s=r},dt=(e,t,n,r)=>{const s=async function*(e,t){for await(const n of async function*(e){if(e[Symbol.asyncIterator])return void(yield*e);const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)break;yield n}}finally{await t.cancel()}}(e))yield*ht(n,t)}(e,t);let a,i=0,o=e=>{a||(a=!0,r&&r(e))};return new ReadableStream({async pull(e){try{const{done:t,value:r}=await s.next();if(t)return o(),void e.close();let a=r.byteLength;if(n){let e=i+=a;n(e)}e.enqueue(new Uint8Array(r))}catch(t){throw o(t),t}},cancel:e=>(o(e),s.return())},{highWaterMark:2})},pt="function"==typeof fetch&&"function"==typeof Request&&"function"==typeof Response,ft=pt&&"function"==typeof ReadableStream,gt=pt&&("function"==typeof TextEncoder?(e=>t=>e.encode(t))(new TextEncoder):async e=>new Uint8Array(await new Response(e).arrayBuffer())),mt=(e,...t)=>{try{return!!e(...t)}catch(n){return!1}},bt=ft&&mt((()=>{let e=!1;const t=new Request(Ue.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t})),yt=ft&&mt((()=>xe.isReadableStream(new Response("").body))),xt={stream:yt&&(e=>e.body)};var vt;pt&&(vt=new Response,["text","arrayBuffer","blob","formData","stream"].forEach((e=>{!xt[e]&&(xt[e]=xe.isFunction(vt[e])?t=>t[e]():(t,n)=>{throw new ve(`Response type '${e}' is not supported`,ve.ERR_NOT_SUPPORT,n)})})));const wt={http:null,xhr:ut,fetch:pt&&(async e=>{let{url:t,method:n,data:r,signal:s,cancelToken:a,timeout:i,onDownloadProgress:o,onUploadProgress:l,responseType:u,headers:c,withCredentials:h="same-origin",fetchOptions:d}=lt(e);u=u?(u+"").toLowerCase():"text";let p,f=ct([s,a&&a.toAbortSignal()],i);const g=f&&f.unsubscribe&&(()=>{f.unsubscribe()});let m;try{if(l&&bt&&"get"!==n&&"head"!==n&&0!==(m=await(async(e,t)=>{const n=xe.toFiniteNumber(e.getContentLength());return null==n?(async e=>{if(null==e)return 0;if(xe.isBlob(e))return e.size;if(xe.isSpecCompliantForm(e)){const t=new Request(Ue.origin,{method:"POST",body:e});return(await t.arrayBuffer()).byteLength}return xe.isArrayBufferView(e)||xe.isArrayBuffer(e)?e.byteLength:(xe.isURLSearchParams(e)&&(e+=""),xe.isString(e)?(await gt(e)).byteLength:void 0)})(t):n})(c,r))){let e,n=new Request(t,{method:"POST",body:r,duplex:"half"});if(xe.isFormData(r)&&(e=n.headers.get("content-type"))&&c.setContentType(e),n.body){const[e,t]=tt(m,et(nt(l)));r=dt(n.body,65536,e,t)}}xe.isString(h)||(h=h?"include":"omit");const s="credentials"in Request.prototype;p=new Request(t,{...d,signal:f,method:n.toUpperCase(),headers:c.normalize().toJSON(),body:r,duplex:"half",credentials:s?h:void 0});let a=await fetch(p,d);const i=yt&&("stream"===u||"response"===u);if(yt&&(o||i&&g)){const e={};["status","statusText","headers"].forEach((t=>{e[t]=a[t]}));const t=xe.toFiniteNumber(a.headers.get("content-length")),[n,r]=o&&tt(t,et(nt(o),!0))||[];a=new Response(dt(a.body,65536,n,(()=>{r&&r(),g&&g()})),e)}u=u||"text";let b=await xt[xe.findKey(xt,u)||"text"](a,e);return!i&&g&&g(),await new Promise(((t,n)=>{Ze(t,n,{data:b,headers:Xe.from(a.headers),status:a.status,statusText:a.statusText,config:e,request:p})}))}catch(b){if(g&&g(),b&&"TypeError"===b.name&&/Load failed|fetch/i.test(b.message))throw Object.assign(new ve("Network Error",ve.ERR_NETWORK,e,p),{cause:b.cause||b});throw ve.from(b,b&&b.code,e,p)}})};xe.forEach(wt,((e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch(n){}Object.defineProperty(e,"adapterName",{value:t})}}));const kt=e=>`- ${e}`,St=e=>xe.isFunction(e)||null===e||!1===e,It=e=>{e=xe.isArray(e)?e:[e];const{length:t}=e;let n,r;const s={};for(let a=0;a<t;a++){let t;if(n=e[a],r=n,!St(n)&&(r=wt[(t=String(n)).toLowerCase()],void 0===r))throw new ve(`Unknown adapter '${t}'`);if(r)break;s[t||"#"+a]=r}if(!r){const e=Object.entries(s).map((([e,t])=>`adapter ${e} `+(!1===t?"is not supported by the environment":"is not available in the build")));throw new ve("There is no suitable adapter to dispatch the request "+(t?e.length>1?"since :\n"+e.map(kt).join("\n"):" "+kt(e[0]):"as no adapter specified"),"ERR_NOT_SUPPORT")}return r};function Ct(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new Je(null,e)}function Tt(e){return Ct(e),e.headers=Xe.from(e.headers),e.data=Ye.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1),It(e.adapter||Ve.adapter)(e).then((function(t){return Ct(e),t.data=Ye.call(e,e.transformResponse,t),t.headers=Xe.from(t.headers),t}),(function(t){return Qe(t)||(Ct(e),t&&t.response&&(t.response.data=Ye.call(e,e.transformResponse,t.response),t.response.headers=Xe.from(t.response.headers))),Promise.reject(t)}))}const Nt="1.11.0",Et={};["object","boolean","number","function","string","symbol"].forEach(((e,t)=>{Et[e]=function(n){return typeof n===e||"a"+(t<1?"n ":" ")+e}}));const $t={};Et.transitional=function(e,t,n){function r(e,t){return"[Axios v"+Nt+"] Transitional option '"+e+"'"+t+(n?". "+n:"")}return(n,s,a)=>{if(!1===e)throw new ve(r(s," has been removed"+(t?" in "+t:"")),ve.ERR_DEPRECATED);return t&&!$t[s]&&($t[s]=!0,console.warn(r(s," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,s,a)}},Et.spelling=function(e){return(t,n)=>(console.warn(`${n} is likely a misspelling of ${e}`),!0)};const Rt={assertOptions:function(e,t,n){if("object"!=typeof e)throw new ve("options must be an object",ve.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let s=r.length;for(;s-- >0;){const a=r[s],i=t[a];if(i){const t=e[a],n=void 0===t||i(t,a,e);if(!0!==n)throw new ve("option "+a+" must be "+n,ve.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new ve("Unknown option "+a,ve.ERR_BAD_OPTION)}},validators:Et},At=Rt.validators;let _t=class{constructor(e){this.defaults=e||{},this.interceptors={request:new Oe,response:new Oe}}async request(e,t){try{return await this._request(e,t)}catch(n){if(n instanceof Error){let e={};Error.captureStackTrace?Error.captureStackTrace(e):e=new Error;const t=e.stack?e.stack.replace(/^.+\n/,""):"";try{n.stack?t&&!String(n.stack).endsWith(t.replace(/^.+\n.+\n/,""))&&(n.stack+="\n"+t):n.stack=t}catch(r){}}throw n}}_request(e,t){"string"==typeof e?(t=t||{}).url=e:t=e||{},t=ot(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:s}=t;void 0!==n&&Rt.assertOptions(n,{silentJSONParsing:At.transitional(At.boolean),forcedJSONParsing:At.transitional(At.boolean),clarifyTimeoutError:At.transitional(At.boolean)},!1),null!=r&&(xe.isFunction(r)?t.paramsSerializer={serialize:r}:Rt.assertOptions(r,{encode:At.function,serialize:At.function},!0)),void 0!==t.allowAbsoluteUrls||(void 0!==this.defaults.allowAbsoluteUrls?t.allowAbsoluteUrls=this.defaults.allowAbsoluteUrls:t.allowAbsoluteUrls=!0),Rt.assertOptions(t,{baseUrl:At.spelling("baseURL"),withXsrfToken:At.spelling("withXSRFToken")},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase();let a=s&&xe.merge(s.common,s[t.method]);s&&xe.forEach(["delete","get","head","post","put","patch","common"],(e=>{delete s[e]})),t.headers=Xe.concat(a,s);const i=[];let o=!0;this.interceptors.request.forEach((function(e){"function"==typeof e.runWhen&&!1===e.runWhen(t)||(o=o&&e.synchronous,i.unshift(e.fulfilled,e.rejected))}));const l=[];let u;this.interceptors.response.forEach((function(e){l.push(e.fulfilled,e.rejected)}));let c,h=0;if(!o){const e=[Tt.bind(this),void 0];for(e.unshift(...i),e.push(...l),c=e.length,u=Promise.resolve(t);h<c;)u=u.then(e[h++],e[h++]);return u}c=i.length;let d=t;for(h=0;h<c;){const e=i[h++],t=i[h++];try{d=e(d)}catch(p){t.call(this,p);break}}try{u=Tt.call(this,d)}catch(p){return Promise.reject(p)}for(h=0,c=l.length;h<c;)u=u.then(l[h++],l[h++]);return u}getUri(e){return _e(at((e=ot(this.defaults,e)).baseURL,e.url,e.allowAbsoluteUrls),e.params,e.paramsSerializer)}};xe.forEach(["delete","get","head","options"],(function(e){_t.prototype[e]=function(t,n){return this.request(ot(n||{},{method:e,url:t,data:(n||{}).data}))}})),xe.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,s){return this.request(ot(s||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}_t.prototype[e]=t(),_t.prototype[e+"Form"]=t(!0)}));const Ot={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Ot).forEach((([e,t])=>{Ot[t]=e}));const Dt=function e(t){const n=new _t(t),r=A(_t.prototype.request,n);return xe.extend(r,_t.prototype,n,{allOwnKeys:!0}),xe.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(ot(t,n))},r}(Ve);Dt.Axios=_t,Dt.CanceledError=Je,Dt.CancelToken=class e{constructor(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");let t;this.promise=new Promise((function(e){t=e}));const n=this;this.promise.then((e=>{if(!n._listeners)return;let t=n._listeners.length;for(;t-- >0;)n._listeners[t](e);n._listeners=null})),this.promise.then=e=>{let t;const r=new Promise((e=>{n.subscribe(e),t=e})).then(e);return r.cancel=function(){n.unsubscribe(t)},r},e((function(e,r,s){n.reason||(n.reason=new Je(e,r,s),t(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}toAbortSignal(){const e=new AbortController,t=t=>{e.abort(t)};return this.subscribe(t),e.signal.unsubscribe=()=>this.unsubscribe(t),e.signal}static source(){let t;return{token:new e((function(e){t=e})),cancel:t}}},Dt.isCancel=Qe,Dt.VERSION=Nt,Dt.toFormData=Ne,Dt.AxiosError=ve,Dt.Cancel=Dt.CanceledError,Dt.all=function(e){return Promise.all(e)},Dt.spread=function(e){return function(t){return e.apply(null,t)}},Dt.isAxiosError=function(e){return xe.isObject(e)&&!0===e.isAxiosError},Dt.mergeConfig=ot,Dt.AxiosHeaders=Xe,Dt.formToJSON=e=>We(xe.isHTMLForm(e)?new FormData(e):e),Dt.getAdapter=It,Dt.HttpStatusCode=Ot,Dt.default=Dt;const{Axios:Ft,AxiosError:Lt,CanceledError:zt,isCancel:Mt,CancelToken:Pt,VERSION:Bt,all:Ut,Cancel:Wt,isAxiosError:Vt,spread:Gt,toFormData:Ht,AxiosHeaders:jt,HttpStatusCode:qt,formToJSON:Kt,getAdapter:Xt,mergeConfig:Yt}=Dt;var Qt=n();const Jt=t(Qt);class Zt extends Qt.Scene{constructor(){super("Boot")}preload(){this.load.image("background","/assets/bg.png")}create(){this.scene.start("Preloader")}}class en extends Qt.Scene{constructor(){super("Preloader")}preload(){const e=this.cameras.main.width,t=this.cameras.main.height,n=this.add.graphics(),r=this.add.graphics();n.fillStyle(2236962,.8),n.fillRect(e/2-160,t/2-25,320,50);const s=this.add.text(e/2,t/2-50,"Loading...",{fontSize:"24px",color:"#ffffff"}).setOrigin(.5);this.load.on("progress",(n=>{r.clear(),r.fillStyle(16777215,1),r.fillRect(e/2-150,t/2-15,300*n,30)})),this.load.on("complete",(()=>{r.destroy(),n.destroy(),s.destroy()})),this.load.setPath("assets"),this.load.image("star","star.png"),this.load.image("logo","logo.png"),this.load.image("storymode","storymode.png"),this.load.image("multimode","multimode.png")}create(){this.scene.start("MainMenu")}}const tn=new Jt.Events.EventEmitter;class nn extends Qt.Scene{constructor(){var t,n;super("MainMenu"),((t,n,r)=>{n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[n]=r})(this,"symbol"!=typeof(t="logoTween")?t+"":t,n)}preload(){this.load.image("magnifying","/assets/magnifying.png"),this.load.image("5.png","/assets/5.png"),this.load.image("6.png","/assets/6.png"),this.load.image("7.png","/assets/7.png"),this.load.image("8.png","/assets/8.png"),this.load.image("9.png","/assets/9.png"),this.load.image("star","/assets/star.png")}create(){this.scene.restart("MainMenu"),this.cameras.main.setBackgroundColor("#91e3ff"),this.logo=this.add.image(this.cameras.main.centerX,300,"logo").setDepth(100).setScale(.4);let e=null;try{e=JSON.parse(localStorage.getItem("currentUser"))}catch(a){e=null}if(e&&e.name){const t=10,n=32,r=this.cameras.main.height,s=this.add.image(30,r-50,"star").setOrigin(0,1).setDisplaySize(n,n).setDepth(110).setInteractive({useHandCursor:!0});[s,this.add.text(s.x+n+t,r-50,`Welcome, ${e.name}!`,{fontSize:"25px",color:"#000000ff",fontStyle:"bold",fontWeight:"600",align:"left",strokeThickness:0}).setOrigin(0,1).setDepth(110).setInteractive({useHandCursor:!0})].forEach((e=>{e.on("pointerdown",(()=>{this.scene.start("Dashboard")}))}))}if(e&&e.name){const e=this.add.rectangle(this.cameras.main.centerX,550,260,56,6318078,1).setOrigin(.5).setInteractive({useHandCursor:!0});e.setStrokeStyle(2,4966128);const t=this.add.text(this.cameras.main.centerX,550,"Play Game",{fontSize:"28px",color:"#ffffffff"}).setOrigin(.5).setDepth(1).setInteractive({useHandCursor:!0}),n=()=>this.scene.start("Mode");e.on("pointerdown",n),t.on("pointerdown",n),e.on("pointerover",(()=>e.setFillStyle(4966128))),e.on("pointerout",(()=>e.setFillStyle(6318078)))}const t=["Signin","Login","Logout"],n=[()=>{tn.emit("show-signin"),tn.once("signin-success",(()=>this.scene.start("Mode")))},()=>{tn.emit("show-login"),tn.once("login-success",(()=>this.scene.start("Mode")))},()=>{localStorage.clear(),this.scene.restart()}],r=this.cameras.main.height-50,s=this.cameras.main.width-120*t.length-10;t.forEach(((e,t)=>{const a=s+120*t;this.add.text(a,r,e,{fontSize:"26px",color:"#000000ff",fontStyle:"bold"}).setOrigin(0,1).setInteractive({useHandCursor:!0}).on("pointerdown",n[t])})),this.add.image(this.cameras.main.width-60,80,"magnifying").setOrigin(.5).setScale(.1).setDepth(120).setInteractive({useHandCursor:!0}).on("pointerdown",(()=>{if(this.popupContainer)return;this.popupContainer=this.add.rectangle(512,360,1024,800,0,.69).setOrigin(.5).setDepth(199).setInteractive();const e=this.add.rectangle(512,370,850,550,16777215,1).setOrigin(.5).setDepth(200),t=["5.png","6.png","7.png","8.png","9.png"];let n=0,r=this.add.image(512,370,t[n]).setDisplaySize(850,550).setDepth(201);const s=this.add.text(192,680,"Previous",{fontSize:"28px",color:"#fff"}).setOrigin(.5).setDepth(202).setInteractive({useHandCursor:!0}),a=this.add.text(832,680,"Next",{fontSize:"28px",color:"#fff"}).setOrigin(.5).setDepth(202).setInteractive({useHandCursor:!0}),i=()=>{this.popupContainer.destroy(),e.destroy(),r.destroy(),s.destroy(),a.destroy(),this.popupContainer=null};function o(){r.setTexture(t[n]),s.setAlpha(0===n?.5:1),s.disableInteractive(),a.setAlpha(n===t.length-1?.5:1),a.disableInteractive(),n>0&&s.setInteractive({useHandCursor:!0}),n<t.length-1&&a.setInteractive({useHandCursor:!0})}s.on("pointerdown",(()=>{n>0&&(n--,o())})),a.on("pointerdown",(()=>{n<t.length-1?(n++,o()):i()})),o(),this.popupContainer.on("pointerdown",(t=>{const n=e.getBounds();(t.x<n.left||t.x>n.right||t.y<n.top||t.y>n.bottom)&&i()}))})),tn.emit("current-scene-ready",this)}changeScene(){this.logoTween&&(this.logoTween.stop(),this.logoTween=null),this.scene.start("Game")}enterButtonHoverState(){this.clickButton.setStyle({fill:"#ff0"})}enterButtonRestState(){this.clickButton.setStyle({fill:"#0f0"})}moveLogo(e){this.logoTween?this.logoTween.isPlaying()?this.logoTween.pause():this.logoTween.play():this.logoTween=this.tweens.add({targets:this.logo,x:{value:750,duration:3e3,ease:"Back.easeInOut"},y:{value:80,duration:1500,ease:"Sine.easeOut"},yoyo:!0,repeat:-1,onUpdate:()=>{e&&e({x:Math.floor(this.logo.x),y:Math.floor(this.logo.y)})}})}}const rn=Object.create(null);rn.open="0",rn.close="1",rn.ping="2",rn.pong="3",rn.message="4",rn.upgrade="5",rn.noop="6";const sn=Object.create(null);Object.keys(rn).forEach((e=>{sn[rn[e]]=e}));const an={type:"error",data:"parser error"},on="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===Object.prototype.toString.call(Blob),ln="function"==typeof ArrayBuffer,un=e=>"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer instanceof ArrayBuffer,cn=({type:e,data:t},n,r)=>on&&t instanceof Blob?n?r(t):hn(t,r):ln&&(t instanceof ArrayBuffer||un(t))?n?r(t):hn(new Blob([t]),r):r(rn[e]+(t||"")),hn=(e,t)=>{const n=new FileReader;return n.onload=function(){const e=n.result.split(",")[1];t("b"+(e||""))},n.readAsDataURL(e)};function dn(e){return e instanceof Uint8Array?e:e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}let pn;const fn="undefined"==typeof Uint8Array?[]:new Uint8Array(256);for(let FP=0;FP<64;FP++)fn["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(FP)]=FP;const gn="function"==typeof ArrayBuffer,mn=(e,t)=>{if("string"!=typeof e)return{type:"message",data:yn(e,t)};const n=e.charAt(0);return"b"===n?{type:"message",data:bn(e.substring(1),t)}:sn[n]?e.length>1?{type:sn[n],data:e.substring(1)}:{type:sn[n]}:an},bn=(e,t)=>{if(gn){const n=(e=>{let t,n,r,s,a,i=.75*e.length,o=e.length,l=0;"="===e[e.length-1]&&(i--,"="===e[e.length-2]&&i--);const u=new ArrayBuffer(i),c=new Uint8Array(u);for(t=0;t<o;t+=4)n=fn[e.charCodeAt(t)],r=fn[e.charCodeAt(t+1)],s=fn[e.charCodeAt(t+2)],a=fn[e.charCodeAt(t+3)],c[l++]=n<<2|r>>4,c[l++]=(15&r)<<4|s>>2,c[l++]=(3&s)<<6|63&a;return u})(e);return yn(n,t)}return{base64:!0,data:e}},yn=(e,t)=>"blob"===t?e instanceof Blob?e:new Blob([e]):e instanceof ArrayBuffer?e:e.buffer,xn=String.fromCharCode(30);let vn;function wn(e){return e.reduce(((e,t)=>e+t.length),0)}function kn(e,t){if(e[0].length===t)return e.shift();const n=new Uint8Array(t);let r=0;for(let s=0;s<t;s++)n[s]=e[0][r++],r===e[0].length&&(e.shift(),r=0);return e.length&&r<e[0].length&&(e[0]=e[0].slice(r)),n}function Sn(e){if(e)return function(e){for(var t in Sn.prototype)e[t]=Sn.prototype[t];return e}(e)}Sn.prototype.on=Sn.prototype.addEventListener=function(e,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this},Sn.prototype.once=function(e,t){function n(){this.off(e,n),t.apply(this,arguments)}return n.fn=t,this.on(e,n),this},Sn.prototype.off=Sn.prototype.removeListener=Sn.prototype.removeAllListeners=Sn.prototype.removeEventListener=function(e,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n,r=this._callbacks["$"+e];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var s=0;s<r.length;s++)if((n=r[s])===t||n.fn===t){r.splice(s,1);break}return 0===r.length&&delete this._callbacks["$"+e],this},Sn.prototype.emit=function(e){this._callbacks=this._callbacks||{};for(var t=new Array(arguments.length-1),n=this._callbacks["$"+e],r=1;r<arguments.length;r++)t[r-1]=arguments[r];if(n){r=0;for(var s=(n=n.slice(0)).length;r<s;++r)n[r].apply(this,t)}return this},Sn.prototype.emitReserved=Sn.prototype.emit,Sn.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},Sn.prototype.hasListeners=function(e){return!!this.listeners(e).length};const In="function"==typeof Promise&&"function"==typeof Promise.resolve?e=>Promise.resolve().then(e):(e,t)=>t(e,0),Cn="undefined"!=typeof self?self:"undefined"!=typeof window?window:Function("return this")();function Tn(e,...t){return t.reduce(((t,n)=>(e.hasOwnProperty(n)&&(t[n]=e[n]),t)),{})}const Nn=Cn.setTimeout,En=Cn.clearTimeout;function $n(e,t){t.useNativeTimers?(e.setTimeoutFn=Nn.bind(Cn),e.clearTimeoutFn=En.bind(Cn)):(e.setTimeoutFn=Cn.setTimeout.bind(Cn),e.clearTimeoutFn=Cn.clearTimeout.bind(Cn))}function Rn(){return Date.now().toString(36).substring(3)+Math.random().toString(36).substring(2,5)}class An extends Error{constructor(e,t,n){super(e),this.description=t,this.context=n,this.type="TransportError"}}class _n extends Sn{constructor(e){super(),this.writable=!1,$n(this,e),this.opts=e,this.query=e.query,this.socket=e.socket,this.supportsBinary=!e.forceBase64}onError(e,t,n){return super.emitReserved("error",new An(e,t,n)),this}open(){return this.readyState="opening",this.doOpen(),this}close(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this}send(e){"open"===this.readyState&&this.write(e)}onOpen(){this.readyState="open",this.writable=!0,super.emitReserved("open")}onData(e){const t=mn(e,this.socket.binaryType);this.onPacket(t)}onPacket(e){super.emitReserved("packet",e)}onClose(e){this.readyState="closed",super.emitReserved("close",e)}pause(e){}createUri(e,t={}){return e+"://"+this._hostname()+this._port()+this.opts.path+this._query(t)}_hostname(){const e=this.opts.hostname;return-1===e.indexOf(":")?e:"["+e+"]"}_port(){return this.opts.port&&(this.opts.secure&&Number(443!==this.opts.port)||!this.opts.secure&&80!==Number(this.opts.port))?":"+this.opts.port:""}_query(e){const t=function(e){let t="";for(let n in e)e.hasOwnProperty(n)&&(t.length&&(t+="&"),t+=encodeURIComponent(n)+"="+encodeURIComponent(e[n]));return t}(e);return t.length?"?"+t:""}}class On extends _n{constructor(){super(...arguments),this._polling=!1}get name(){return"polling"}doOpen(){this._poll()}pause(e){this.readyState="pausing";const t=()=>{this.readyState="paused",e()};if(this._polling||!this.writable){let e=0;this._polling&&(e++,this.once("pollComplete",(function(){--e||t()}))),this.writable||(e++,this.once("drain",(function(){--e||t()})))}else t()}_poll(){this._polling=!0,this.doPoll(),this.emitReserved("poll")}onData(e){((e,t)=>{const n=e.split(xn),r=[];for(let s=0;s<n.length;s++){const e=mn(n[s],t);if(r.push(e),"error"===e.type)break}return r})(e,this.socket.binaryType).forEach((e=>{if("opening"===this.readyState&&"open"===e.type&&this.onOpen(),"close"===e.type)return this.onClose({description:"transport closed by the server"}),!1;this.onPacket(e)})),"closed"!==this.readyState&&(this._polling=!1,this.emitReserved("pollComplete"),"open"===this.readyState&&this._poll())}doClose(){const e=()=>{this.write([{type:"close"}])};"open"===this.readyState?e():this.once("open",e)}write(e){this.writable=!1,((e,t)=>{const n=e.length,r=new Array(n);let s=0;e.forEach(((e,a)=>{cn(e,!1,(e=>{r[a]=e,++s===n&&t(r.join(xn))}))}))})(e,(e=>{this.doWrite(e,(()=>{this.writable=!0,this.emitReserved("drain")}))}))}uri(){const e=this.opts.secure?"https":"http",t=this.query||{};return!1!==this.opts.timestampRequests&&(t[this.opts.timestampParam]=Rn()),this.supportsBinary||t.sid||(t.b64=1),this.createUri(e,t)}}let Dn=!1;try{Dn="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(DP){}const Fn=Dn;function Ln(){}class zn extends On{constructor(e){if(super(e),"undefined"!=typeof location){const t="https:"===location.protocol;let n=location.port;n||(n=t?"443":"80"),this.xd="undefined"!=typeof location&&e.hostname!==location.hostname||n!==e.port}}doWrite(e,t){const n=this.request({method:"POST",data:e});n.on("success",t),n.on("error",((e,t)=>{this.onError("xhr post error",e,t)}))}doPoll(){const e=this.request();e.on("data",this.onData.bind(this)),e.on("error",((e,t)=>{this.onError("xhr poll error",e,t)})),this.pollXhr=e}}let Mn=class e extends Sn{constructor(e,t,n){super(),this.createRequest=e,$n(this,n),this._opts=n,this._method=n.method||"GET",this._uri=t,this._data=void 0!==n.data?n.data:null,this._create()}_create(){var t;const n=Tn(this._opts,"agent","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","autoUnref");n.xdomain=!!this._opts.xd;const r=this._xhr=this.createRequest(n);try{r.open(this._method,this._uri,!0);try{if(this._opts.extraHeaders){r.setDisableHeaderCheck&&r.setDisableHeaderCheck(!0);for(let e in this._opts.extraHeaders)this._opts.extraHeaders.hasOwnProperty(e)&&r.setRequestHeader(e,this._opts.extraHeaders[e])}}catch(s){}if("POST"===this._method)try{r.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(s){}try{r.setRequestHeader("Accept","*/*")}catch(s){}null===(t=this._opts.cookieJar)||void 0===t||t.addCookies(r),"withCredentials"in r&&(r.withCredentials=this._opts.withCredentials),this._opts.requestTimeout&&(r.timeout=this._opts.requestTimeout),r.onreadystatechange=()=>{var e;3===r.readyState&&(null===(e=this._opts.cookieJar)||void 0===e||e.parseCookies(r.getResponseHeader("set-cookie"))),4===r.readyState&&(200===r.status||1223===r.status?this._onLoad():this.setTimeoutFn((()=>{this._onError("number"==typeof r.status?r.status:0)}),0))},r.send(this._data)}catch(s){return void this.setTimeoutFn((()=>{this._onError(s)}),0)}"undefined"!=typeof document&&(this._index=e.requestsCount++,e.requests[this._index]=this)}_onError(e){this.emitReserved("error",e,this._xhr),this._cleanup(!0)}_cleanup(t){if(void 0!==this._xhr&&null!==this._xhr){if(this._xhr.onreadystatechange=Ln,t)try{this._xhr.abort()}catch(n){}"undefined"!=typeof document&&delete e.requests[this._index],this._xhr=null}}_onLoad(){const e=this._xhr.responseText;null!==e&&(this.emitReserved("data",e),this.emitReserved("success"),this._cleanup())}abort(){this._cleanup()}};function Pn(){for(let e in Mn.requests)Mn.requests.hasOwnProperty(e)&&Mn.requests[e].abort()}Mn.requestsCount=0,Mn.requests={},"undefined"!=typeof document&&("function"==typeof attachEvent?attachEvent("onunload",Pn):"function"==typeof addEventListener&&addEventListener("onpagehide"in Cn?"pagehide":"unload",Pn,!1));const Bn=function(){const e=Un({xdomain:!1});return e&&null!==e.responseType}();function Un(e){const t=e.xdomain;try{if("undefined"!=typeof XMLHttpRequest&&(!t||Fn))return new XMLHttpRequest}catch(n){}if(!t)try{return new(Cn[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(n){}}const Wn="undefined"!=typeof navigator&&"string"==typeof navigator.product&&"reactnative"===navigator.product.toLowerCase();class Vn extends _n{get name(){return"websocket"}doOpen(){const e=this.uri(),t=this.opts.protocols,n=Wn?{}:Tn(this.opts,"agent","perMessageDeflate","pfx","key","passphrase","cert","ca","ciphers","rejectUnauthorized","localAddress","protocolVersion","origin","maxPayload","family","checkServerIdentity");this.opts.extraHeaders&&(n.headers=this.opts.extraHeaders);try{this.ws=this.createSocket(e,t,n)}catch(DP){return this.emitReserved("error",DP)}this.ws.binaryType=this.socket.binaryType,this.addEventListeners()}addEventListeners(){this.ws.onopen=()=>{this.opts.autoUnref&&this.ws._socket.unref(),this.onOpen()},this.ws.onclose=e=>this.onClose({description:"websocket connection closed",context:e}),this.ws.onmessage=e=>this.onData(e.data),this.ws.onerror=e=>this.onError("websocket error",e)}write(e){this.writable=!1;for(let t=0;t<e.length;t++){const n=e[t],r=t===e.length-1;cn(n,this.supportsBinary,(e=>{try{this.doWrite(n,e)}catch(t){}r&&In((()=>{this.writable=!0,this.emitReserved("drain")}),this.setTimeoutFn)}))}}doClose(){void 0!==this.ws&&(this.ws.onerror=()=>{},this.ws.close(),this.ws=null)}uri(){const e=this.opts.secure?"wss":"ws",t=this.query||{};return this.opts.timestampRequests&&(t[this.opts.timestampParam]=Rn()),this.supportsBinary||(t.b64=1),this.createUri(e,t)}}const Gn=Cn.WebSocket||Cn.MozWebSocket,Hn={websocket:class extends Vn{createSocket(e,t,n){return Wn?new Gn(e,t,n):t?new Gn(e,t):new Gn(e)}doWrite(e,t){this.ws.send(t)}},webtransport:class extends _n{get name(){return"webtransport"}doOpen(){try{this._transport=new WebTransport(this.createUri("https"),this.opts.transportOptions[this.name])}catch(DP){return this.emitReserved("error",DP)}this._transport.closed.then((()=>{this.onClose()})).catch((e=>{this.onError("webtransport error",e)})),this._transport.ready.then((()=>{this._transport.createBidirectionalStream().then((e=>{const t=function(e,t){vn||(vn=new TextDecoder);const n=[];let r=0,s=-1,a=!1;return new TransformStream({transform(i,o){for(n.push(i);;){if(0===r){if(wn(n)<1)break;const e=kn(n,1);a=!(128&~e[0]),s=127&e[0],r=s<126?3:126===s?1:2}else if(1===r){if(wn(n)<2)break;const e=kn(n,2);s=new DataView(e.buffer,e.byteOffset,e.length).getUint16(0),r=3}else if(2===r){if(wn(n)<8)break;const e=kn(n,8),t=new DataView(e.buffer,e.byteOffset,e.length),a=t.getUint32(0);if(a>Math.pow(2,21)-1){o.enqueue(an);break}s=a*Math.pow(2,32)+t.getUint32(4),r=3}else{if(wn(n)<s)break;const e=kn(n,s);o.enqueue(mn(a?e:vn.decode(e),t)),r=0}if(0===s||s>e){o.enqueue(an);break}}}})}(Number.MAX_SAFE_INTEGER,this.socket.binaryType),n=e.readable.pipeThrough(t).getReader(),r=new TransformStream({transform(e,t){!function(e,t){on&&e.data instanceof Blob?e.data.arrayBuffer().then(dn).then(t):ln&&(e.data instanceof ArrayBuffer||un(e.data))?t(dn(e.data)):cn(e,!1,(e=>{pn||(pn=new TextEncoder),t(pn.encode(e))}))}(e,(n=>{const r=n.length;let s;if(r<126)s=new Uint8Array(1),new DataView(s.buffer).setUint8(0,r);else if(r<65536){s=new Uint8Array(3);const e=new DataView(s.buffer);e.setUint8(0,126),e.setUint16(1,r)}else{s=new Uint8Array(9);const e=new DataView(s.buffer);e.setUint8(0,127),e.setBigUint64(1,BigInt(r))}e.data&&"string"!=typeof e.data&&(s[0]|=128),t.enqueue(s),t.enqueue(n)}))}});r.readable.pipeTo(e.writable),this._writer=r.writable.getWriter();const s=()=>{n.read().then((({done:e,value:t})=>{e||(this.onPacket(t),s())})).catch((e=>{}))};s();const a={type:"open"};this.query.sid&&(a.data=`{"sid":"${this.query.sid}"}`),this._writer.write(a).then((()=>this.onOpen()))}))}))}write(e){this.writable=!1;for(let t=0;t<e.length;t++){const n=e[t],r=t===e.length-1;this._writer.write(n).then((()=>{r&&In((()=>{this.writable=!0,this.emitReserved("drain")}),this.setTimeoutFn)}))}}doClose(){var e;null===(e=this._transport)||void 0===e||e.close()}},polling:class extends zn{constructor(e){super(e);const t=e&&e.forceBase64;this.supportsBinary=Bn&&!t}request(e={}){return Object.assign(e,{xd:this.xd},this.opts),new Mn(Un,this.uri(),e)}}},jn=/^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,qn=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];function Kn(e){if(e.length>8e3)throw"URI too long";const t=e,n=e.indexOf("["),r=e.indexOf("]");-1!=n&&-1!=r&&(e=e.substring(0,n)+e.substring(n,r).replace(/:/g,";")+e.substring(r,e.length));let s=jn.exec(e||""),a={},i=14;for(;i--;)a[qn[i]]=s[i]||"";return-1!=n&&-1!=r&&(a.source=t,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a.pathNames=function(e,t){const n=t.replace(/\/{2,9}/g,"/").split("/");return"/"!=t.slice(0,1)&&0!==t.length||n.splice(0,1),"/"==t.slice(-1)&&n.splice(n.length-1,1),n}(0,a.path),a.queryKey=function(e,t){const n={};return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g,(function(e,t,r){t&&(n[t]=r)})),n}(0,a.query),a}const Xn="function"==typeof addEventListener&&"function"==typeof removeEventListener,Yn=[];Xn&&addEventListener("offline",(()=>{Yn.forEach((e=>e()))}),!1);class Qn extends Sn{constructor(e,t){if(super(),this.binaryType="arraybuffer",this.writeBuffer=[],this._prevBufferLen=0,this._pingInterval=-1,this._pingTimeout=-1,this._maxPayload=-1,this._pingTimeoutTime=1/0,e&&"object"==typeof e&&(t=e,e=null),e){const n=Kn(e);t.hostname=n.host,t.secure="https"===n.protocol||"wss"===n.protocol,t.port=n.port,n.query&&(t.query=n.query)}else t.host&&(t.hostname=Kn(t.host).host);$n(this,t),this.secure=null!=t.secure?t.secure:"undefined"!=typeof location&&"https:"===location.protocol,t.hostname&&!t.port&&(t.port=this.secure?"443":"80"),this.hostname=t.hostname||("undefined"!=typeof location?location.hostname:"localhost"),this.port=t.port||("undefined"!=typeof location&&location.port?location.port:this.secure?"443":"80"),this.transports=[],this._transportsByName={},t.transports.forEach((e=>{const t=e.prototype.name;this.transports.push(t),this._transportsByName[t]=e})),this.opts=Object.assign({path:"/engine.io",agent:!1,withCredentials:!1,upgrade:!0,timestampParam:"t",rememberUpgrade:!1,addTrailingSlash:!0,rejectUnauthorized:!0,perMessageDeflate:{threshold:1024},transportOptions:{},closeOnBeforeunload:!1},t),this.opts.path=this.opts.path.replace(/\/$/,"")+(this.opts.addTrailingSlash?"/":""),"string"==typeof this.opts.query&&(this.opts.query=function(e){let t={},n=e.split("&");for(let r=0,s=n.length;r<s;r++){let e=n[r].split("=");t[decodeURIComponent(e[0])]=decodeURIComponent(e[1])}return t}(this.opts.query)),Xn&&(this.opts.closeOnBeforeunload&&(this._beforeunloadEventListener=()=>{this.transport&&(this.transport.removeAllListeners(),this.transport.close())},addEventListener("beforeunload",this._beforeunloadEventListener,!1)),"localhost"!==this.hostname&&(this._offlineEventListener=()=>{this._onClose("transport close",{description:"network connection lost"})},Yn.push(this._offlineEventListener))),this.opts.withCredentials&&(this._cookieJar=void 0),this._open()}createTransport(e){const t=Object.assign({},this.opts.query);t.EIO=4,t.transport=e,this.id&&(t.sid=this.id);const n=Object.assign({},this.opts,{query:t,socket:this,hostname:this.hostname,secure:this.secure,port:this.port},this.opts.transportOptions[e]);return new this._transportsByName[e](n)}_open(){if(0===this.transports.length)return void this.setTimeoutFn((()=>{this.emitReserved("error","No transports available")}),0);const e=this.opts.rememberUpgrade&&Qn.priorWebsocketSuccess&&-1!==this.transports.indexOf("websocket")?"websocket":this.transports[0];this.readyState="opening";const t=this.createTransport(e);t.open(),this.setTransport(t)}setTransport(e){this.transport&&this.transport.removeAllListeners(),this.transport=e,e.on("drain",this._onDrain.bind(this)).on("packet",this._onPacket.bind(this)).on("error",this._onError.bind(this)).on("close",(e=>this._onClose("transport close",e)))}onOpen(){this.readyState="open",Qn.priorWebsocketSuccess="websocket"===this.transport.name,this.emitReserved("open"),this.flush()}_onPacket(e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emitReserved("packet",e),this.emitReserved("heartbeat"),e.type){case"open":this.onHandshake(JSON.parse(e.data));break;case"ping":this._sendPacket("pong"),this.emitReserved("ping"),this.emitReserved("pong"),this._resetPingTimeout();break;case"error":const t=new Error("server error");t.code=e.data,this._onError(t);break;case"message":this.emitReserved("data",e.data),this.emitReserved("message",e.data)}}onHandshake(e){this.emitReserved("handshake",e),this.id=e.sid,this.transport.query.sid=e.sid,this._pingInterval=e.pingInterval,this._pingTimeout=e.pingTimeout,this._maxPayload=e.maxPayload,this.onOpen(),"closed"!==this.readyState&&this._resetPingTimeout()}_resetPingTimeout(){this.clearTimeoutFn(this._pingTimeoutTimer);const e=this._pingInterval+this._pingTimeout;this._pingTimeoutTime=Date.now()+e,this._pingTimeoutTimer=this.setTimeoutFn((()=>{this._onClose("ping timeout")}),e),this.opts.autoUnref&&this._pingTimeoutTimer.unref()}_onDrain(){this.writeBuffer.splice(0,this._prevBufferLen),this._prevBufferLen=0,0===this.writeBuffer.length?this.emitReserved("drain"):this.flush()}flush(){if("closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){const e=this._getWritablePackets();this.transport.send(e),this._prevBufferLen=e.length,this.emitReserved("flush")}}_getWritablePackets(){if(!(this._maxPayload&&"polling"===this.transport.name&&this.writeBuffer.length>1))return this.writeBuffer;let e=1;for(let n=0;n<this.writeBuffer.length;n++){const r=this.writeBuffer[n].data;if(r&&(e+="string"==typeof(t=r)?function(e){let t=0,n=0;for(let r=0,s=e.length;r<s;r++)t=e.charCodeAt(r),t<128?n+=1:t<2048?n+=2:t<55296||t>=57344?n+=3:(r++,n+=4);return n}(t):Math.ceil(1.33*(t.byteLength||t.size))),n>0&&e>this._maxPayload)return this.writeBuffer.slice(0,n);e+=2}var t;return this.writeBuffer}_hasPingExpired(){if(!this._pingTimeoutTime)return!0;const e=Date.now()>this._pingTimeoutTime;return e&&(this._pingTimeoutTime=0,In((()=>{this._onClose("ping timeout")}),this.setTimeoutFn)),e}write(e,t,n){return this._sendPacket("message",e,t,n),this}send(e,t,n){return this._sendPacket("message",e,t,n),this}_sendPacket(e,t,n,r){if("function"==typeof t&&(r=t,t=void 0),"function"==typeof n&&(r=n,n=null),"closing"===this.readyState||"closed"===this.readyState)return;(n=n||{}).compress=!1!==n.compress;const s={type:e,data:t,options:n};this.emitReserved("packetCreate",s),this.writeBuffer.push(s),r&&this.once("flush",r),this.flush()}close(){const e=()=>{this._onClose("forced close"),this.transport.close()},t=()=>{this.off("upgrade",t),this.off("upgradeError",t),e()},n=()=>{this.once("upgrade",t),this.once("upgradeError",t)};return"opening"!==this.readyState&&"open"!==this.readyState||(this.readyState="closing",this.writeBuffer.length?this.once("drain",(()=>{this.upgrading?n():e()})):this.upgrading?n():e()),this}_onError(e){if(Qn.priorWebsocketSuccess=!1,this.opts.tryAllTransports&&this.transports.length>1&&"opening"===this.readyState)return this.transports.shift(),this._open();this.emitReserved("error",e),this._onClose("transport error",e)}_onClose(e,t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){if(this.clearTimeoutFn(this._pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),Xn&&(this._beforeunloadEventListener&&removeEventListener("beforeunload",this._beforeunloadEventListener,!1),this._offlineEventListener)){const e=Yn.indexOf(this._offlineEventListener);-1!==e&&Yn.splice(e,1)}this.readyState="closed",this.id=null,this.emitReserved("close",e,t),this.writeBuffer=[],this._prevBufferLen=0}}}Qn.protocol=4;class Jn extends Qn{constructor(){super(...arguments),this._upgrades=[]}onOpen(){if(super.onOpen(),"open"===this.readyState&&this.opts.upgrade)for(let e=0;e<this._upgrades.length;e++)this._probe(this._upgrades[e])}_probe(e){let t=this.createTransport(e),n=!1;Qn.priorWebsocketSuccess=!1;const r=()=>{n||(t.send([{type:"ping",data:"probe"}]),t.once("packet",(e=>{if(!n)if("pong"===e.type&&"probe"===e.data){if(this.upgrading=!0,this.emitReserved("upgrading",t),!t)return;Qn.priorWebsocketSuccess="websocket"===t.name,this.transport.pause((()=>{n||"closed"!==this.readyState&&(u(),this.setTransport(t),t.send([{type:"upgrade"}]),this.emitReserved("upgrade",t),t=null,this.upgrading=!1,this.flush())}))}else{const e=new Error("probe error");e.transport=t.name,this.emitReserved("upgradeError",e)}})))};function s(){n||(n=!0,u(),t.close(),t=null)}const a=e=>{const n=new Error("probe error: "+e);n.transport=t.name,s(),this.emitReserved("upgradeError",n)};function i(){a("transport closed")}function o(){a("socket closed")}function l(e){t&&e.name!==t.name&&s()}const u=()=>{t.removeListener("open",r),t.removeListener("error",a),t.removeListener("close",i),this.off("close",o),this.off("upgrading",l)};t.once("open",r),t.once("error",a),t.once("close",i),this.once("close",o),this.once("upgrading",l),-1!==this._upgrades.indexOf("webtransport")&&"webtransport"!==e?this.setTimeoutFn((()=>{n||t.open()}),200):t.open()}onHandshake(e){this._upgrades=this._filterUpgrades(e.upgrades),super.onHandshake(e)}_filterUpgrades(e){const t=[];for(let n=0;n<e.length;n++)~this.transports.indexOf(e[n])&&t.push(e[n]);return t}}let Zn=class extends Jn{constructor(e,t={}){const n="object"==typeof e?e:t;(!n.transports||n.transports&&"string"==typeof n.transports[0])&&(n.transports=(n.transports||["polling","websocket","webtransport"]).map((e=>Hn[e])).filter((e=>!!e))),super(e,n)}};const er="function"==typeof ArrayBuffer,tr=Object.prototype.toString,nr="function"==typeof Blob||"undefined"!=typeof Blob&&"[object BlobConstructor]"===tr.call(Blob),rr="function"==typeof File||"undefined"!=typeof File&&"[object FileConstructor]"===tr.call(File);function sr(e){return er&&(e instanceof ArrayBuffer||(e=>"function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(e):e.buffer instanceof ArrayBuffer)(e))||nr&&e instanceof Blob||rr&&e instanceof File}function ar(e,t){if(!e||"object"!=typeof e)return!1;if(Array.isArray(e)){for(let t=0,n=e.length;t<n;t++)if(ar(e[t]))return!0;return!1}if(sr(e))return!0;if(e.toJSON&&"function"==typeof e.toJSON&&1===arguments.length)return ar(e.toJSON(),!0);for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)&&ar(e[n]))return!0;return!1}function ir(e){const t=[],n=e.data,r=e;return r.data=or(n,t),r.attachments=t.length,{packet:r,buffers:t}}function or(e,t){if(!e)return e;if(sr(e)){const n={_placeholder:!0,num:t.length};return t.push(e),n}if(Array.isArray(e)){const n=new Array(e.length);for(let r=0;r<e.length;r++)n[r]=or(e[r],t);return n}if("object"==typeof e&&!(e instanceof Date)){const n={};for(const r in e)Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=or(e[r],t));return n}return e}function lr(e,t){return e.data=ur(e.data,t),delete e.attachments,e}function ur(e,t){if(!e)return e;if(e&&!0===e._placeholder){if("number"==typeof e.num&&e.num>=0&&e.num<t.length)return t[e.num];throw new Error("illegal attachments")}if(Array.isArray(e))for(let n=0;n<e.length;n++)e[n]=ur(e[n],t);else if("object"==typeof e)for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&(e[n]=ur(e[n],t));return e}const cr=["connect","connect_error","disconnect","disconnecting","newListener","removeListener"];var hr,dr;function pr(e){return"[object Object]"===Object.prototype.toString.call(e)}(dr=hr||(hr={}))[dr.CONNECT=0]="CONNECT",dr[dr.DISCONNECT=1]="DISCONNECT",dr[dr.EVENT=2]="EVENT",dr[dr.ACK=3]="ACK",dr[dr.CONNECT_ERROR=4]="CONNECT_ERROR",dr[dr.BINARY_EVENT=5]="BINARY_EVENT",dr[dr.BINARY_ACK=6]="BINARY_ACK";class fr extends Sn{constructor(e){super(),this.reviver=e}add(e){let t;if("string"==typeof e){if(this.reconstructor)throw new Error("got plaintext data when reconstructing a packet");t=this.decodeString(e);const n=t.type===hr.BINARY_EVENT;n||t.type===hr.BINARY_ACK?(t.type=n?hr.EVENT:hr.ACK,this.reconstructor=new gr(t),0===t.attachments&&super.emitReserved("decoded",t)):super.emitReserved("decoded",t)}else{if(!sr(e)&&!e.base64)throw new Error("Unknown type: "+e);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");t=this.reconstructor.takeBinaryData(e),t&&(this.reconstructor=null,super.emitReserved("decoded",t))}}decodeString(e){let t=0;const n={type:Number(e.charAt(0))};if(void 0===hr[n.type])throw new Error("unknown packet type "+n.type);if(n.type===hr.BINARY_EVENT||n.type===hr.BINARY_ACK){const r=t+1;for(;"-"!==e.charAt(++t)&&t!=e.length;);const s=e.substring(r,t);if(s!=Number(s)||"-"!==e.charAt(t))throw new Error("Illegal attachments");n.attachments=Number(s)}if("/"===e.charAt(t+1)){const r=t+1;for(;++t&&","!==e.charAt(t)&&t!==e.length;);n.nsp=e.substring(r,t)}else n.nsp="/";const r=e.charAt(t+1);if(""!==r&&Number(r)==r){const r=t+1;for(;++t;){const n=e.charAt(t);if(null==n||Number(n)!=n){--t;break}if(t===e.length)break}n.id=Number(e.substring(r,t+1))}if(e.charAt(++t)){const r=this.tryParse(e.substr(t));if(!fr.isPayloadValid(n.type,r))throw new Error("invalid payload");n.data=r}return n}tryParse(e){try{return JSON.parse(e,this.reviver)}catch(t){return!1}}static isPayloadValid(e,t){switch(e){case hr.CONNECT:return pr(t);case hr.DISCONNECT:return void 0===t;case hr.CONNECT_ERROR:return"string"==typeof t||pr(t);case hr.EVENT:case hr.BINARY_EVENT:return Array.isArray(t)&&("number"==typeof t[0]||"string"==typeof t[0]&&-1===cr.indexOf(t[0]));case hr.ACK:case hr.BINARY_ACK:return Array.isArray(t)}}destroy(){this.reconstructor&&(this.reconstructor.finishedReconstruction(),this.reconstructor=null)}}class gr{constructor(e){this.packet=e,this.buffers=[],this.reconPack=e}takeBinaryData(e){if(this.buffers.push(e),this.buffers.length===this.reconPack.attachments){const e=lr(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null}finishedReconstruction(){this.reconPack=null,this.buffers=[]}}const mr=Object.freeze(Object.defineProperty({__proto__:null,Decoder:fr,Encoder:class{constructor(e){this.replacer=e}encode(e){return e.type!==hr.EVENT&&e.type!==hr.ACK||!ar(e)?[this.encodeAsString(e)]:this.encodeAsBinary({type:e.type===hr.EVENT?hr.BINARY_EVENT:hr.BINARY_ACK,nsp:e.nsp,data:e.data,id:e.id})}encodeAsString(e){let t=""+e.type;return e.type!==hr.BINARY_EVENT&&e.type!==hr.BINARY_ACK||(t+=e.attachments+"-"),e.nsp&&"/"!==e.nsp&&(t+=e.nsp+","),null!=e.id&&(t+=e.id),null!=e.data&&(t+=JSON.stringify(e.data,this.replacer)),t}encodeAsBinary(e){const t=ir(e),n=this.encodeAsString(t.packet),r=t.buffers;return r.unshift(n),r}},get PacketType(){return hr},protocol:5},Symbol.toStringTag,{value:"Module"}));function br(e,t,n){return e.on(t,n),function(){e.off(t,n)}}const yr=Object.freeze({connect:1,connect_error:1,disconnect:1,disconnecting:1,newListener:1,removeListener:1});class xr extends Sn{constructor(e,t,n){super(),this.connected=!1,this.recovered=!1,this.receiveBuffer=[],this.sendBuffer=[],this._queue=[],this._queueSeq=0,this.ids=0,this.acks={},this.flags={},this.io=e,this.nsp=t,n&&n.auth&&(this.auth=n.auth),this._opts=Object.assign({},n),this.io._autoConnect&&this.open()}get disconnected(){return!this.connected}subEvents(){if(this.subs)return;const e=this.io;this.subs=[br(e,"open",this.onopen.bind(this)),br(e,"packet",this.onpacket.bind(this)),br(e,"error",this.onerror.bind(this)),br(e,"close",this.onclose.bind(this))]}get active(){return!!this.subs}connect(){return this.connected||(this.subEvents(),this.io._reconnecting||this.io.open(),"open"===this.io._readyState&&this.onopen()),this}open(){return this.connect()}send(...e){return e.unshift("message"),this.emit.apply(this,e),this}emit(e,...t){var n,r,s;if(yr.hasOwnProperty(e))throw new Error('"'+e.toString()+'" is a reserved event name');if(t.unshift(e),this._opts.retries&&!this.flags.fromQueue&&!this.flags.volatile)return this._addToQueue(t),this;const a={type:hr.EVENT,data:t,options:{}};if(a.options.compress=!1!==this.flags.compress,"function"==typeof t[t.length-1]){const e=this.ids++,n=t.pop();this._registerAckCallback(e,n),a.id=e}const i=null===(r=null===(n=this.io.engine)||void 0===n?void 0:n.transport)||void 0===r?void 0:r.writable,o=this.connected&&!(null===(s=this.io.engine)||void 0===s?void 0:s._hasPingExpired());return this.flags.volatile&&!i||(o?(this.notifyOutgoingListeners(a),this.packet(a)):this.sendBuffer.push(a)),this.flags={},this}_registerAckCallback(e,t){var n;const r=null!==(n=this.flags.timeout)&&void 0!==n?n:this._opts.ackTimeout;if(void 0===r)return void(this.acks[e]=t);const s=this.io.setTimeoutFn((()=>{delete this.acks[e];for(let t=0;t<this.sendBuffer.length;t++)this.sendBuffer[t].id===e&&this.sendBuffer.splice(t,1);t.call(this,new Error("operation has timed out"))}),r),a=(...e)=>{this.io.clearTimeoutFn(s),t.apply(this,e)};a.withError=!0,this.acks[e]=a}emitWithAck(e,...t){return new Promise(((n,r)=>{const s=(e,t)=>e?r(e):n(t);s.withError=!0,t.push(s),this.emit(e,...t)}))}_addToQueue(e){let t;"function"==typeof e[e.length-1]&&(t=e.pop());const n={id:this._queueSeq++,tryCount:0,pending:!1,args:e,flags:Object.assign({fromQueue:!0},this.flags)};e.push(((e,...r)=>{if(n===this._queue[0])return null!==e?n.tryCount>this._opts.retries&&(this._queue.shift(),t&&t(e)):(this._queue.shift(),t&&t(null,...r)),n.pending=!1,this._drainQueue()})),this._queue.push(n),this._drainQueue()}_drainQueue(e=!1){if(!this.connected||0===this._queue.length)return;const t=this._queue[0];t.pending&&!e||(t.pending=!0,t.tryCount++,this.flags=t.flags,this.emit.apply(this,t.args))}packet(e){e.nsp=this.nsp,this.io._packet(e)}onopen(){"function"==typeof this.auth?this.auth((e=>{this._sendConnectPacket(e)})):this._sendConnectPacket(this.auth)}_sendConnectPacket(e){this.packet({type:hr.CONNECT,data:this._pid?Object.assign({pid:this._pid,offset:this._lastOffset},e):e})}onerror(e){this.connected||this.emitReserved("connect_error",e)}onclose(e,t){this.connected=!1,delete this.id,this.emitReserved("disconnect",e,t),this._clearAcks()}_clearAcks(){Object.keys(this.acks).forEach((e=>{if(!this.sendBuffer.some((t=>String(t.id)===e))){const t=this.acks[e];delete this.acks[e],t.withError&&t.call(this,new Error("socket has been disconnected"))}}))}onpacket(e){if(e.nsp===this.nsp)switch(e.type){case hr.CONNECT:e.data&&e.data.sid?this.onconnect(e.data.sid,e.data.pid):this.emitReserved("connect_error",new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));break;case hr.EVENT:case hr.BINARY_EVENT:this.onevent(e);break;case hr.ACK:case hr.BINARY_ACK:this.onack(e);break;case hr.DISCONNECT:this.ondisconnect();break;case hr.CONNECT_ERROR:this.destroy();const t=new Error(e.data.message);t.data=e.data.data,this.emitReserved("connect_error",t)}}onevent(e){const t=e.data||[];null!=e.id&&t.push(this.ack(e.id)),this.connected?this.emitEvent(t):this.receiveBuffer.push(Object.freeze(t))}emitEvent(e){if(this._anyListeners&&this._anyListeners.length){const t=this._anyListeners.slice();for(const n of t)n.apply(this,e)}super.emit.apply(this,e),this._pid&&e.length&&"string"==typeof e[e.length-1]&&(this._lastOffset=e[e.length-1])}ack(e){const t=this;let n=!1;return function(...r){n||(n=!0,t.packet({type:hr.ACK,id:e,data:r}))}}onack(e){const t=this.acks[e.id];"function"==typeof t&&(delete this.acks[e.id],t.withError&&e.data.unshift(null),t.apply(this,e.data))}onconnect(e,t){this.id=e,this.recovered=t&&this._pid===t,this._pid=t,this.connected=!0,this.emitBuffered(),this.emitReserved("connect"),this._drainQueue(!0)}emitBuffered(){this.receiveBuffer.forEach((e=>this.emitEvent(e))),this.receiveBuffer=[],this.sendBuffer.forEach((e=>{this.notifyOutgoingListeners(e),this.packet(e)})),this.sendBuffer=[]}ondisconnect(){this.destroy(),this.onclose("io server disconnect")}destroy(){this.subs&&(this.subs.forEach((e=>e())),this.subs=void 0),this.io._destroy(this)}disconnect(){return this.connected&&this.packet({type:hr.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this}close(){return this.disconnect()}compress(e){return this.flags.compress=e,this}get volatile(){return this.flags.volatile=!0,this}timeout(e){return this.flags.timeout=e,this}onAny(e){return this._anyListeners=this._anyListeners||[],this._anyListeners.push(e),this}prependAny(e){return this._anyListeners=this._anyListeners||[],this._anyListeners.unshift(e),this}offAny(e){if(!this._anyListeners)return this;if(e){const t=this._anyListeners;for(let n=0;n<t.length;n++)if(e===t[n])return t.splice(n,1),this}else this._anyListeners=[];return this}listenersAny(){return this._anyListeners||[]}onAnyOutgoing(e){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.push(e),this}prependAnyOutgoing(e){return this._anyOutgoingListeners=this._anyOutgoingListeners||[],this._anyOutgoingListeners.unshift(e),this}offAnyOutgoing(e){if(!this._anyOutgoingListeners)return this;if(e){const t=this._anyOutgoingListeners;for(let n=0;n<t.length;n++)if(e===t[n])return t.splice(n,1),this}else this._anyOutgoingListeners=[];return this}listenersAnyOutgoing(){return this._anyOutgoingListeners||[]}notifyOutgoingListeners(e){if(this._anyOutgoingListeners&&this._anyOutgoingListeners.length){const t=this._anyOutgoingListeners.slice();for(const n of t)n.apply(this,e.data)}}}function vr(e){e=e||{},this.ms=e.min||100,this.max=e.max||1e4,this.factor=e.factor||2,this.jitter=e.jitter>0&&e.jitter<=1?e.jitter:0,this.attempts=0}vr.prototype.duration=function(){var e=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var t=Math.random(),n=Math.floor(t*this.jitter*e);e=1&Math.floor(10*t)?e+n:e-n}return 0|Math.min(e,this.max)},vr.prototype.reset=function(){this.attempts=0},vr.prototype.setMin=function(e){this.ms=e},vr.prototype.setMax=function(e){this.max=e},vr.prototype.setJitter=function(e){this.jitter=e};class wr extends Sn{constructor(e,t){var n;super(),this.nsps={},this.subs=[],e&&"object"==typeof e&&(t=e,e=void 0),(t=t||{}).path=t.path||"/socket.io",this.opts=t,$n(this,t),this.reconnection(!1!==t.reconnection),this.reconnectionAttempts(t.reconnectionAttempts||1/0),this.reconnectionDelay(t.reconnectionDelay||1e3),this.reconnectionDelayMax(t.reconnectionDelayMax||5e3),this.randomizationFactor(null!==(n=t.randomizationFactor)&&void 0!==n?n:.5),this.backoff=new vr({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==t.timeout?2e4:t.timeout),this._readyState="closed",this.uri=e;const r=t.parser||mr;this.encoder=new r.Encoder,this.decoder=new r.Decoder,this._autoConnect=!1!==t.autoConnect,this._autoConnect&&this.open()}reconnection(e){return arguments.length?(this._reconnection=!!e,e||(this.skipReconnect=!0),this):this._reconnection}reconnectionAttempts(e){return void 0===e?this._reconnectionAttempts:(this._reconnectionAttempts=e,this)}reconnectionDelay(e){var t;return void 0===e?this._reconnectionDelay:(this._reconnectionDelay=e,null===(t=this.backoff)||void 0===t||t.setMin(e),this)}randomizationFactor(e){var t;return void 0===e?this._randomizationFactor:(this._randomizationFactor=e,null===(t=this.backoff)||void 0===t||t.setJitter(e),this)}reconnectionDelayMax(e){var t;return void 0===e?this._reconnectionDelayMax:(this._reconnectionDelayMax=e,null===(t=this.backoff)||void 0===t||t.setMax(e),this)}timeout(e){return arguments.length?(this._timeout=e,this):this._timeout}maybeReconnectOnOpen(){!this._reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()}open(e){if(~this._readyState.indexOf("open"))return this;this.engine=new Zn(this.uri,this.opts);const t=this.engine,n=this;this._readyState="opening",this.skipReconnect=!1;const r=br(t,"open",(function(){n.onopen(),e&&e()})),s=t=>{this.cleanup(),this._readyState="closed",this.emitReserved("error",t),e?e(t):this.maybeReconnectOnOpen()},a=br(t,"error",s);if(!1!==this._timeout){const e=this._timeout,n=this.setTimeoutFn((()=>{r(),s(new Error("timeout")),t.close()}),e);this.opts.autoUnref&&n.unref(),this.subs.push((()=>{this.clearTimeoutFn(n)}))}return this.subs.push(r),this.subs.push(a),this}connect(e){return this.open(e)}onopen(){this.cleanup(),this._readyState="open",this.emitReserved("open");const e=this.engine;this.subs.push(br(e,"ping",this.onping.bind(this)),br(e,"data",this.ondata.bind(this)),br(e,"error",this.onerror.bind(this)),br(e,"close",this.onclose.bind(this)),br(this.decoder,"decoded",this.ondecoded.bind(this)))}onping(){this.emitReserved("ping")}ondata(e){try{this.decoder.add(e)}catch(t){this.onclose("parse error",t)}}ondecoded(e){In((()=>{this.emitReserved("packet",e)}),this.setTimeoutFn)}onerror(e){this.emitReserved("error",e)}socket(e,t){let n=this.nsps[e];return n?this._autoConnect&&!n.active&&n.connect():(n=new xr(this,e,t),this.nsps[e]=n),n}_destroy(e){const t=Object.keys(this.nsps);for(const n of t)if(this.nsps[n].active)return;this._close()}_packet(e){const t=this.encoder.encode(e);for(let n=0;n<t.length;n++)this.engine.write(t[n],e.options)}cleanup(){this.subs.forEach((e=>e())),this.subs.length=0,this.decoder.destroy()}_close(){this.skipReconnect=!0,this._reconnecting=!1,this.onclose("forced close")}disconnect(){return this._close()}onclose(e,t){var n;this.cleanup(),null===(n=this.engine)||void 0===n||n.close(),this.backoff.reset(),this._readyState="closed",this.emitReserved("close",e,t),this._reconnection&&!this.skipReconnect&&this.reconnect()}reconnect(){if(this._reconnecting||this.skipReconnect)return this;const e=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitReserved("reconnect_failed"),this._reconnecting=!1;else{const t=this.backoff.duration();this._reconnecting=!0;const n=this.setTimeoutFn((()=>{e.skipReconnect||(this.emitReserved("reconnect_attempt",e.backoff.attempts),e.skipReconnect||e.open((t=>{t?(e._reconnecting=!1,e.reconnect(),this.emitReserved("reconnect_error",t)):e.onreconnect()})))}),t);this.opts.autoUnref&&n.unref(),this.subs.push((()=>{this.clearTimeoutFn(n)}))}}onreconnect(){const e=this.backoff.attempts;this._reconnecting=!1,this.backoff.reset(),this.emitReserved("reconnect",e)}}const kr={};function Sr(e,t){"object"==typeof e&&(t=e,e=void 0);const n=function(e,t="",n){let r=e;n=n||"undefined"!=typeof location&&location,null==e&&(e=n.protocol+"//"+n.host),"string"==typeof e&&("/"===e.charAt(0)&&(e="/"===e.charAt(1)?n.protocol+e:n.host+e),/^(https?|wss?):\/\//.test(e)||(e=void 0!==n?n.protocol+"//"+e:"https://"+e),r=Kn(e)),r.port||(/^(http|ws)$/.test(r.protocol)?r.port="80":/^(http|ws)s$/.test(r.protocol)&&(r.port="443")),r.path=r.path||"/";const s=-1!==r.host.indexOf(":")?"["+r.host+"]":r.host;return r.id=r.protocol+"://"+s+":"+r.port+t,r.href=r.protocol+"://"+s+(n&&n.port===r.port?"":":"+r.port),r}(e,(t=t||{}).path||"/socket.io"),r=n.source,s=n.id,a=n.path,i=kr[s]&&a in kr[s].nsps;let o;return t.forceNew||t["force new connection"]||!1===t.multiplex||i?o=new wr(r,t):(kr[s]||(kr[s]=new wr(r,t)),o=kr[s]),n.query&&!t.query&&(t.query=n.queryKey),o.socket(n.path,t)}Object.assign(Sr,{Manager:wr,Socket:xr,io:Sr,connect:Sr});const Ir=Sr("https://cellvivor-backend.onrender.com");class Cr extends Qt.Scene{constructor(){super("Mode")}preload(){this.load.image("magnifying","/assets/magnifying.png"),this.load.image("storymode","/assets/storymode.png"),this.load.image("multimode","/assets/multimode.png"),this.load.image("NewgameButton","/assets/NewgameButton.png"),this.load.image("ContinueButton","/assets/ContinueButton.png"),this.load.image("5.png","/assets/5.png"),this.load.image("6.png","/assets/6.png"),this.load.image("7.png","/assets/7.png"),this.load.image("8.png","/assets/8.png"),this.load.image("9.png","/assets/9.png"),this.load.image("star","/assets/star.png")}create(){this.scene.restart("Mode");const e=JSON.parse(localStorage.getItem("currentUser"))||JSON.parse(localStorage.getItem("user")),t=(null==e?void 0:e.name)||"Anonymous";this.cameras.main.setBackgroundColor("#fa821a");const n=.22*this.cameras.main.height,r=this.add.text(this.cameras.main.width/2,n,"MODE",{fontSize:"68px",color:"#fff",fontStyle:"bold",align:"center"}).setOrigin(.5).setDepth(100);this.add.image(r.x-126,n,"star").setOrigin(.5).setScale(.13).setDepth(101),this.add.image(r.x+126,n,"star").setOrigin(.5).setScale(.13).setDepth(101);const s=.55*this.cameras.main.height;this.add.image(.265*this.cameras.main.width,s,"storymode").setOrigin(.5).setScale(.145).setInteractive({useHandCursor:!0}).setDepth(50).on("pointerdown",(()=>{if(this.popupContainer)return;this.popupContainer=this.add.rectangle(512,360,1024,800,0,.5).setOrigin(.5).setDepth(299);const t=this.add.rectangle(512,320,500,250,16777215,1).setOrigin(.5).setDepth(300),n=this.add.text(512,270,"Continue the story or start again?",{fontSize:"28px",color:"#222",wordWrap:{width:440},align:"center"}).setOrigin(.5).setDepth(301),r=this.add.image(400,390,"NewgameButton").setOrigin(.5).setScale(.1).setDepth(335).setInteractive({useHandCursor:!0}),s=this.add.image(624,390,"ContinueButton").setOrigin(.5).setScale(.1).setDepth(335).setInteractive({useHandCursor:!0}),a=this.add.text(750,208,"✕",{fontSize:"32px",color:"#888",fontStyle:"bold",backgroundColor:"#fff",padding:{left:8,right:8,top:2,bottom:2},borderRadius:16,align:"center"}).setOrigin(.5).setDepth(302).setInteractive({useHandCursor:!0});r.on("pointerdown",(async()=>{(null==e?void 0:e._id)&&(await fetch("progress/save",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:e._id,scene:"Chapter1"})}),this.scene.launch("LoadingOverlay"),this.scene.start("Chapter1"))})),s.on("pointerdown",(async()=>{try{const e=localStorage.getItem("currentUser")||localStorage.getItem("user");if(!e)throw new Error("No user data in localStorage");const t=JSON.parse(e),n=null==t?void 0:t._id;if(!n)throw new Error("User ID missing");const r=await fetch(`/progress/load/${n}`);if(!r.ok)throw new Error(`Failed to load progress: ${r.statusText}`);const s=(await r.json()).lastScene||"Chapter1",a=sceneMap[s]||"Chapter1";console.log("Continuing to:",a),this.scene.start(a)}catch(DP){console.error("Error loading progress:",DP),this.scene.launch("LoadingOverlay"),this.scene.start("Chapter1")}})),a.on("pointerdown",(()=>{[t,n,r,s,a,this.popupContainer].forEach((e=>null==e?void 0:e.destroy())),this.popupContainer=null}))})),this.add.image(.715*this.cameras.main.width,s,"multimode").setOrigin(.5).setScale(.145).setInteractive({useHandCursor:!0}).setDepth(50).on("pointerdown",(()=>{if(this.popupContainer)return;this.popupContainer=this.add.rectangle(512,360,1024,800,0,.7).setOrigin(.5).setDepth(299),this.add.rectangle(512,380,600,540,16777215,1).setOrigin(.5).setDepth(300),this.add.text(512,208,"Multiplayer Mode",{fontSize:"45px",color:"#fa821a",fontStyle:"bold",align:"center"}).setOrigin(.5).setDepth(301);let e=this.add.text(512,260,"",{fontSize:"22px",color:"#333",align:"center",wordWrap:{width:540}}).setOrigin(.5).setDepth(303);const n={fontSize:"28px",color:"#fff",backgroundColor:"#fa821a",padding:{left:32,right:32,top:12,bottom:12},borderRadius:12},r=this.add.text(512,300,"   Create Room   ",n).setOrigin(.5).setDepth(302).setInteractive(),s=this.add.text(512,358,"    Join Room    ",n).setOrigin(.5).setDepth(302).setInteractive();let a,i,o,l;const u=()=>{this.myRole=null,this.roles={guesser:[],hinter:[]},a?(a.setVisible(!0),i.setVisible(!0),o.setVisible(!0),l.setVisible(!0)):(a=this.add.text(512,464,"Choose your role:",{fontSize:"24px",color:"#fa821a",align:"center"}).setOrigin(.5).setDepth(304),i=this.add.text(422,507,"Guesser",n).setOrigin(.5).setDepth(305).setInteractive(),o=this.add.text(602,507,"Hinter",n).setOrigin(.5).setDepth(305).setInteractive(),i.on("pointerdown",(()=>{this.myRole||(this.myRole="guesser",Ir.emit("setRole","guesser"),e.setText(`${t} — Role: Guesser — Room: ${this.currentRoom}`))})),o.on("pointerdown",(()=>{this.myRole||(this.myRole="hinter",Ir.emit("setRole","hinter"),e.setText(`${t} — Role: Hinter — Room: ${this.currentRoom}`))})),l=this.add.text(512,588,"Start Game",{fontSize:"28px",color:"#fff",backgroundColor:"#2ecc40",padding:{left:32,right:32,top:12,bottom:12},borderRadius:12}).setOrigin(.5).setDepth(306).setAlpha(.5).setInteractive(),l.disableInteractive(),l.on("pointerdown",(()=>{this.roles.guesser.length&&this.roles.hinter.length&&this.isHost?Ir.emit("start-game",{roomCode:this.currentRoom,role:this.myRole}):e.setText("Both roles must be filled and only host can start.")}))),c()},c=()=>{this.roles.guesser.length&&this.roles.hinter.length&&this.isHost?(l.setAlpha(1),l.setInteractive({useHandCursor:!0})):(l.setAlpha(.5),l.disableInteractive())};r.on("pointerdown",(()=>{this.isHost=!0;const n=Math.random().toString(36).substr(2,5).toUpperCase();this.currentRoom=n,Ir.emit("createRoom",n),e.setText(`${t} — Role: None — Room: ${n} (Host)`),u()})),s.on("pointerdown",(()=>{this.isHost=!1;const n=window.prompt("Enter room code to join:");n&&(this.currentRoom=n,Ir.emit("joinRoom",n),e.setText(`${t} — Role: None — Room: ${n}`),u())})),Ir.on("roleUpdate",(({guesser:e,hinter:t})=>{this.roles={guesser:e,hinter:t},c()})),Ir.on("player-left",(({name:e,role:t,userId:n})=>{this.roles[t]&&(this.roles[t]=this.roles[t].filter((e=>e!==n)));const r=this.add.text(512,500,`⚠ Player ${e} left as ${t}`,{fontSize:"20px",color:"#ff4d4d",align:"center"}).setOrigin(.5).setDepth(310);this.time.delayedCall(3e3,(()=>r.destroy())),c()})),Ir.on("game-started",(({startTime:e})=>{var t;null==(t=this.popupContainer)||t.destroy(),this.scene.start("Game",{roomCode:this.currentRoom,role:this.myRole,startTime:e})}))})),this.add.text(60,90,"<",{fontSize:"48px",color:"#ffffffff",align:"Left"}).setOrigin(.5).setDepth(200).setInteractive().on("pointerdown",(()=>{this.scene.stop(),this.children.removeAll(),this.scene.start("MainMenu")}))}}class Tr{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Nr{refCount(e){return Er("refCount")}incRef(e){return Er("incRef")}timerAvailable(){return!0}time(e){return Er("time")}read(e){return Er("read")}readSync(e){return Er("readSync")}readToGPU(e,t){return Er("readToGPU")}numDataIds(){return Er("numDataIds")}disposeData(e,t){return Er("disposeData")}write(e,t,n){return Er("write")}move(e,t,n,r,s){return Er("move")}createTensorFromGPUData(e,t,n){return Er("createTensorFromGPUData")}memory(){return Er("memory")}floatPrecision(){return Er("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Er("dispose")}}function Er(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function $r(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,_r(e,t,n)}function Rr(e,t,n){return Math.max(e,Math.min(t,n))}function Ar(e){return e%2==0?e:e+1}function _r(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Or(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function Dr(e,t,n=""){Or(zr(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function Fr(e){Or(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Lr(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function zr(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Mr(e){return e%1==0}function Pr(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Br(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Ur(e,t=e=>0,n,r){return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function Wr(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Vr(e,t){const n=t.length;return Or((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Or(e.every((e=>Mr(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Gr(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:Vr(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Hr(e,t){return jr(e,t)}function jr(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function qr(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Kr(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Xr(e){return"string"==typeof e||e instanceof String}function Yr(e){return"number"==typeof e}function Qr(e){return Array.isArray(e)?Qr(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Yr(e)?"float32":Xr(e)?"string":"boolean"==typeof e?"bool":"float32"}function Jr(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Zr(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function es(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function ts(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=ts(e+t*o,i,n,r)}return s}function ns(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return ts(0,e,t,n)}function rs(e,t){const n=ss(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function ss(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function as(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return ns(e,new Float32Array(n));if("int32"===t)return ns(e,new Int32Array(n));if("bool"===t)return ns(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function is(e){e.forEach((t=>{Or(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function os(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function ls(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function us(e){return e&&e.then&&"function"==typeof e.then}const cs="tfjsflags";class hs{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ds,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(ps().getBool("IS_TEST")||ps().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];ps().getBool("IS_TEST")||ps().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(us(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);cs in e&&e[cs].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}function ds(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function ps(){return gs}let fs,gs=null;function ms(){if(null==fs){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}fs=e}return fs}function bs(e,t){const n=function(){const e=ms();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const ys="Abs",xs="Acos",vs="Acosh",ws="Add",ks="AddN",Ss="All",Is="Any",Cs="ArgMax",Ts="ArgMin",Ns="Asin",Es="Asinh",$s="Atan",Rs="Atanh",As="Atan2",_s="AvgPool",Os="AvgPoolGrad",Ds="AvgPool3D",Fs="AvgPool3DGrad",Ls="BatchMatMul",zs="BatchToSpaceND",Ms="Bincount",Ps="BitwiseAnd",Bs="BroadcastArgs",Us="Cast",Ws="Ceil",Vs="ClipByValue",Gs="Complex",Hs="ComplexAbs",js="Concat",qs="Conv2D",Ks="Conv2DBackpropFilter",Xs="Conv2DBackpropInput",Ys="Conv3D",Qs="Conv3DBackpropFilterV2",Js="Conv3DBackpropInputV2",Zs="Cos",ea="Cosh",ta="Cumprod",na="Cumsum",ra="CropAndResize",sa="DenseBincount",aa="DepthToSpace",ia="DepthwiseConv2dNative",oa="DepthwiseConv2dNativeBackpropFilter",la="DepthwiseConv2dNativeBackpropInput",ua="Diag",ca="Dilation2D",ha="Dilation2DBackpropInput",da="Dilation2DBackpropFilter",pa="RealDiv",fa="Einsum",ga="Elu",ma="EluGrad",ba="Erf",ya="Equal",xa="Exp",va="ExpandDims",wa="Expm1",ka="FFT",Sa="Fill",Ia="FlipLeftRight",Ca="Floor",Ta="FloorDiv",Na="FusedBatchNorm",Ea="GatherV2",$a="GatherNd",Ra="Greater",Aa="GreaterEqual",_a="Identity",Oa="IFFT",Da="Imag",Fa="IsFinite",La="IsInf",za="IsNan",Ma="LeakyRelu",Pa="Less",Ba="LessEqual",Ua="LinSpace",Wa="Log",Va="Log1p",Ga="LogicalAnd",Ha="LogicalNot",ja="LogicalOr",qa="LRN",Ka="LRNGrad",Xa="Max",Ya="Maximum",Qa="MaxPool",Ja="MaxPoolGrad",Za="MaxPool3D",ei="MaxPool3DGrad",ti="MaxPoolWithArgmax",ni="Mean",ri="Min",si="Minimum",ai="MirrorPad",ii="Mod",oi="Multinomial",li="Multiply",ui="Neg",ci="NotEqual",hi="NonMaxSuppressionV3",di="NonMaxSuppressionV4",pi="NonMaxSuppressionV5",fi="OnesLike",gi="OneHot",mi="Pack",bi="PadV2",yi="Pow",xi="Prelu",vi="Prod",wi="RaggedGather",ki="RaggedRange",Si="RaggedTensorToTensor",Ii="Range",Ci="Real",Ti="Reciprocal",Ni="Relu",Ei="Reshape",$i="ResizeNearestNeighbor",Ri="ResizeNearestNeighborGrad",Ai="ResizeBilinear",_i="ResizeBilinearGrad",Oi="Relu6",Di="Reverse",Fi="Round",Li="Rsqrt",zi="ScatterNd",Mi="TensorScatterUpdate",Pi="SearchSorted",Bi="Select",Ui="Selu",Wi="Slice",Vi="Sin",Gi="Sinh",Hi="Sign",ji="Sigmoid",qi="Softplus",Ki="Sqrt",Xi="Sum",Yi="SpaceToBatchND",Qi="SplitV",Ji="Softmax",Zi="SparseFillEmptyRows",eo="SparseReshape",to="SparseSegmentMean",no="SparseSegmentSum",ro="SparseToDense",so="SquaredDifference",ao="Square",io="StaticRegexReplace",oo="StridedSlice",lo="StringNGrams",uo="StringSplit",co="StringToHashBucketFast",ho="Sub",po="Tan",fo="Tanh",go="Tile",mo="TopK",bo="Transform",yo="Transpose",xo="Unique",vo="Unpack",wo="UnsortedSegmentSum",ko="ZerosLike",So="Step",Io="RotateWithOffset",Co="_FusedMatMul",To="FusedConv2D",No="FusedDepthwiseConv2D";function Eo(...e){ps().getBool("IS_TEST")||ps().getBool("PROD")||console.warn(...e)}const $o=bs("kernelRegistry",(()=>new Map)),Ro=bs("gradRegistry",(()=>new Map));function Ao(e,t){const n=Lo(e,t);return $o.get(n)}function _o(e){return Ro.get(e)}function Oo(e){const t=$o.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function Do(e){const{kernelName:t,backendName:n}=e,r=Lo(t,n);$o.has(r)&&Eo(`The kernel '${t}' for backend '${n}' is already registered`),$o.set(r,e)}function Fo(e){const{kernelName:t}=e;Ro.has(t)&&ps().getBool("DEBUG")&&Eo(`Overriding the gradient for '${t}'`),Ro.set(t,e)}function Lo(e,t){return`${t}_${e}`}function zo(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Mo,Po,Bo=function(){if(Po)return Mo;Po=1,Mo=t;var e=null;try{e=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(I){}function t(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function n(e){return!0===(e&&e.__isLong__)}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=n;var r={},s={};function a(e,t){var n,a,i;return t?(i=0<=(e>>>=0)&&e<256)&&(a=s[e])?a:(n=o(e,(0|e)<0?-1:0,!0),i&&(s[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(a=r[e])?a:(n=o(e,e<0?-1:0,!1),i&&(r[e]=n),n)}function i(e,t){if(isNaN(e))return t?m:g;if(t){if(e<0)return m;if(e>=d)return w}else{if(e<=-p)return k;if(e+1>=p)return v}return e<0?i(-e,t).neg():o(e%h|0,e/h|0,t)}function o(e,n,r){return new t(e,n,r)}t.fromInt=a,t.fromNumber=i,t.fromBits=o;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return u(e.substring(1),t,n).neg();for(var s=i(l(n,8)),a=g,o=0;o<e.length;o+=8){var c=Math.min(8,e.length-o),h=parseInt(e.substring(o,o+c),n);if(c<8){var d=i(l(n,c));a=a.mul(d).add(i(h))}else a=(a=a.mul(s)).add(i(h))}return a.unsigned=t,a}function c(e,t){return"number"==typeof e?i(e,t):"string"==typeof e?u(e,t):o(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}t.fromString=u,t.fromValue=c;var h=4294967296,d=h*h,p=d/2,f=a(1<<24),g=a(0);t.ZERO=g;var m=a(0,!0);t.UZERO=m;var b=a(1);t.ONE=b;var y=a(1,!0);t.UONE=y;var x=a(-1);t.NEG_ONE=x;var v=o(-1,2147483647,!1);t.MAX_VALUE=v;var w=o(-1,-1,!0);t.MAX_UNSIGNED_VALUE=w;var k=o(0,-2147483648,!1);t.MIN_VALUE=k;var S=t.prototype;return S.toInt=function(){return this.unsigned?this.low>>>0:this.low},S.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},S.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=i(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=i(l(e,6),this.unsigned),a=this,o="";;){var u=a.div(s),c=(a.sub(u.mul(s)).toInt()>>>0).toString(e);if((a=u).isZero())return c+o;for(;c.length<6;)c="0"+c;o=""+c+o}},S.getHighBits=function(){return this.high},S.getHighBitsUnsigned=function(){return this.high>>>0},S.getLowBits=function(){return this.low},S.getLowBitsUnsigned=function(){return this.low>>>0},S.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},S.isZero=function(){return 0===this.high&&0===this.low},S.eqz=S.isZero,S.isNegative=function(){return!this.unsigned&&this.high<0},S.isPositive=function(){return this.unsigned||this.high>=0},S.isOdd=function(){return!(1&~this.low)},S.isEven=function(){return!(1&this.low)},S.equals=function(e){return n(e)||(e=c(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},S.eq=S.equals,S.notEquals=function(e){return!this.eq(e)},S.neq=S.notEquals,S.ne=S.notEquals,S.lessThan=function(e){return this.comp(e)<0},S.lt=S.lessThan,S.lessThanOrEqual=function(e){return this.comp(e)<=0},S.lte=S.lessThanOrEqual,S.le=S.lessThanOrEqual,S.greaterThan=function(e){return this.comp(e)>0},S.gt=S.greaterThan,S.greaterThanOrEqual=function(e){return this.comp(e)>=0},S.gte=S.greaterThanOrEqual,S.ge=S.greaterThanOrEqual,S.compare=function(e){if(n(e)||(e=c(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},S.comp=S.compare,S.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(b)},S.neg=S.negate,S.add=function(e){n(e)||(e=c(e));var t=this.high>>>16,r=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,l=65535&e.high,u=e.low>>>16,h=0,d=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,d+=(p+=s+u)>>>16,h+=(d+=r+l)>>>16,h+=t+i,o((p&=65535)<<16|(f&=65535),(h&=65535)<<16|(d&=65535),this.unsigned)},S.subtract=function(e){return n(e)||(e=c(e)),this.add(e.neg())},S.sub=S.subtract,S.multiply=function(t){if(this.isZero())return g;if(n(t)||(t=c(t)),e)return o(e.mul(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned);if(t.isZero())return g;if(this.eq(k))return t.isOdd()?k:g;if(t.eq(k))return this.isOdd()?k:g;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(f)&&t.lt(f))return i(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16,s=65535&this.high,a=this.low>>>16,l=65535&this.low,u=t.high>>>16,h=65535&t.high,d=t.low>>>16,p=65535&t.low,m=0,b=0,y=0,x=0;return y+=(x+=l*p)>>>16,b+=(y+=a*p)>>>16,y&=65535,b+=(y+=l*d)>>>16,m+=(b+=s*p)>>>16,b&=65535,m+=(b+=a*d)>>>16,b&=65535,m+=(b+=l*h)>>>16,m+=r*p+s*d+a*h+l*u,o((y&=65535)<<16|(x&=65535),(m&=65535)<<16|(b&=65535),this.unsigned)},S.mul=S.multiply,S.divide=function(t){if(n(t)||(t=c(t)),t.isZero())throw Error("division by zero");var r,s,a;if(e)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?o((this.unsigned?e.div_u:e.div_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?m:g;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return m;if(t.gt(this.shru(1)))return y;a=m}else{if(this.eq(k))return t.eq(b)||t.eq(x)?k:t.eq(k)?b:(r=this.shr(1).div(t).shl(1)).eq(g)?t.isNegative()?b:x:(s=this.sub(t.mul(r)),a=r.add(s.div(t)));if(t.eq(k))return this.unsigned?m:g;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();a=g}for(s=this;s.gte(t);){r=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var u=Math.ceil(Math.log(r)/Math.LN2),h=u<=48?1:l(2,u-48),d=i(r),p=d.mul(t);p.isNegative()||p.gt(s);)p=(d=i(r-=h,this.unsigned)).mul(t);d.isZero()&&(d=b),a=a.add(d),s=s.sub(p)}return a},S.div=S.divide,S.modulo=function(t){return n(t)||(t=c(t)),e?o((this.unsigned?e.rem_u:e.rem_s)(this.low,this.high,t.low,t.high),e.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},S.mod=S.modulo,S.rem=S.modulo,S.not=function(){return o(~this.low,~this.high,this.unsigned)},S.and=function(e){return n(e)||(e=c(e)),o(this.low&e.low,this.high&e.high,this.unsigned)},S.or=function(e){return n(e)||(e=c(e)),o(this.low|e.low,this.high|e.high,this.unsigned)},S.xor=function(e){return n(e)||(e=c(e)),o(this.low^e.low,this.high^e.high,this.unsigned)},S.shiftLeft=function(e){return n(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?o(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):o(0,this.low<<e-32,this.unsigned)},S.shl=S.shiftLeft,S.shiftRight=function(e){return n(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?o(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):o(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},S.shr=S.shiftRight,S.shiftRightUnsigned=function(e){if(n(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?o(this.low>>>e|t<<32-e,t>>>e,this.unsigned):o(32===e?t:t>>>e-32,0,this.unsigned)},S.shru=S.shiftRightUnsigned,S.shr_u=S.shiftRightUnsigned,S.toSigned=function(){return this.unsigned?o(this.low,this.high,!1):this},S.toUnsigned=function(){return this.unsigned?this:o(this.low,this.high,!0)},S.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},S.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},S.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},t.fromBytes=function(e,n,r){return r?t.fromBytesLE(e,n):t.fromBytesBE(e,n)},t.fromBytesLE=function(e,n){return new t(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)},t.fromBytesBE=function(e,n){return new t(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)},Mo}();const Uo=t(Bo),Wo=Uo||s({__proto__:null,default:Uo},[Bo]);function Vo(e){return Wo.fromString(e,!0,16)}const Go=Vo("c3a5c85c97cb3127"),Ho=Vo("b492b66fbe98f273"),jo=Vo("9ae16a3b2f90404f");function qo(e){return e.xor(e.shru(47))}function Ko(e,t,n){const r=e.slice(t,t+n);return Wo.fromBytes(Array.from(r),!0,!0)}function Xo(e,t){return Ko(e,t,8)}function Yo(e,t){return Ko(e,t,4)}function Qo(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Jo(e,t,n=Vo("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Zo(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=Qo(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(Qo(s,44)),[s.add(r),a.add(i)]}(Xo(e,t),Xo(e,t+8),Xo(e,t+16),Xo(e,t+24),n,r)}function el(e,t=e.length){const n=Wo.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=jo.add(2*t),r=Xo(e,0).add(jo),s=Xo(e,t-8);return Jo(Qo(s,37).mul(n).add(r),Qo(r,25).add(s).mul(n),n)}if(t>=4){const n=jo.add(2*t);return Jo(Yo(e,0).shl(3).add(t),Yo(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return qo(jo.mul(n).xor(Go.mul(r))).mul(jo)}return jo}(e,t):function(e,t=e.length){const n=jo.add(2*t),r=Xo(e,0).mul(Ho),s=Xo(e,8),a=Xo(e,t-8).mul(n),i=Xo(e,t-16).mul(jo);return Jo(Qo(r.add(s),43).add(Qo(a,30)).add(i),r.add(Qo(s.add(jo),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=jo.add(2*t),r=Xo(e,0).mul(jo),s=Xo(e,8),a=Xo(e,t-8).mul(n),i=Xo(e,t-16).mul(jo),o=Qo(r.add(s),43).add(Qo(a,30)).add(i),l=Jo(o,r.add(Qo(s.add(jo),18)).add(a),n),u=Xo(e,16).mul(n),c=Xo(e,24),h=o.add(Xo(e,t-32)).mul(n),d=l.add(Xo(e,t-24)).mul(n);return Jo(Qo(u.add(c),43).add(Qo(h,30)).add(d),u.add(Qo(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(Ho).add(113),a=qo(s.mul(jo).add(113)).mul(jo),i=[Wo.UZERO,Wo.UZERO],o=[Wo.UZERO,Wo.UZERO];r=r.mul(jo).add(Xo(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Qo(r.add(s).add(i[0]).add(Xo(e,l+8)),37).mul(Ho),s=Qo(s.add(i[1]).add(Xo(e,l+48)),42).mul(Ho),r=r.xor(o[1]),s=s.add(i[0]).add(Xo(e,l+40)),a=Qo(a.add(o[0]),33).mul(Ho),i=Zo(e,l,i[1].mul(Ho),r.add(o[0])),o=Zo(e,l+32,a.add(o[1]),s.add(Xo(e,l+16))),[a,r]=[r,a],l+=64}while(l!==u);const h=Ho.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Qo(r.add(s).add(i[0]).add(Xo(e,l+8)),37).mul(h),s=Qo(s.add(i[1]).add(Xo(e,l+48)),42).mul(h),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Xo(e,l+40))),a=Qo(a.add(o[0]),33).mul(h),i=Zo(e,l,i[1].mul(h),r.add(o[0])),o=Zo(e,l+32,a.add(o[1]),s.add(Xo(e,l+16))),[a,r]=[r,a],Jo(Jo(i[0],o[0],h).add(qo(s).mul(Go)).add(a),Jo(i[1],o[1],h).add(r),h)}function tl(e,t){return"string"===t?sl(e):nl([e],t)}function nl(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ol(e)),ps().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function rl(){return ps().platform.now()}function sl(e,t="utf-8"){return t=t||"utf-8",ps().platform.encode(e,t)}function al(e,t="utf-8"){return t=t||"utf-8",ps().platform.decode(e,t)}function il(e){return null!=ps().platform.isTypedArray?ps().platform.isTypedArray(e):zo(e)}function ol(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||us(e)||null==e||il(e)&&n)t.push(e);else if(Array.isArray(e)||il(e))for(let r=0;r<e.length;++r)ol(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)ol(e[s],t,n)}return t}class ll{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new cl)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=rl();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:rl()-i})}if(ps().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{ul(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function ul(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class cl{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?Br(`${r}ms`,9):r.error,o=Br(e,25),l=t.rank,u=t.size,c=Br(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function hl(e,t,n,r){const s=es(t),a=function(e,t,n,r){const s=Lr(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l="complex64"===n?gl(e):e;if(o>1)for(let u=0;u<s/a;u++){const e=u*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],dl(l[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=fl(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function dl(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Xr(e)?`'${e}'`:"bool"===n?pl(e):parseFloat(e.toFixed(7)).toString(),Br(r,t)}function pl(e){return 0===e?"false":"true"}function fl(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l)return"complex64"===n?[dl(gl(e)[0],0,n)]:"bool"===n?[pl(e[0])]:[e[0].toString()];if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=gl(r),a=gl(a)),["["+r.map(((e,t)=>dl(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>dl(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?gl(e):Array.from(e)).map(((e,t)=>dl(e,s[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*h,a=r+h;d.push(...fl(e.slice(r,a),u,n,c,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*h,a=r+h;d.push(...fl(e.slice(r,a),u,n,c,s,t===o-1))}}else for(let g=0;g<o;g++){const t=g*h,r=t+h;d.push(...fl(e.slice(t,r),u,n,c,s,g===o-1))}const p=2===l?",":"";d[0]="["+(o>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function gl(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class ml{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Lr(e),null!=n){const e=n.length;Or(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||jr(t,this.size),this.strides=es(e)}set(e,...t){0===t.length&&(t=[0]),Or(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return bl().makeTensor(this.values,this.shape,this.dtype)}}let bl=null,yl=null;class xl{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Lr(e),this.strides=es(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return yl.buffer(this.shape,this.dtype,e)}bufferSync(){return yl.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ns(this.shape,e,"complex64"===this.dtype)}arraySync(){return ns(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=bl().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>al(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),bl().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=bl().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>al(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await bl().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),bl().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return yl.print(this,e)}clone(){return this.throwIfDisposed(),yl.clone(this)}toString(e=!1){return hl(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),yl.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),bl().makeVariable(this,e,t,n)}}function vl(){return bs("Tensor",(()=>xl))}Object.defineProperty(xl,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),vl();class wl extends xl{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!zr(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);bl().disposeTensor(this),this.dataId=e.dataId,bl().incRef(this,null)}dispose(){bl().disposeVariable(this),this.isDisposedInternal=!0}}var kl,Sl,Il,Cl,Tl,Nl,El,$l,Rl,Al;Object.defineProperty(wl,Symbol.hasInstance,{value:e=>e instanceof xl&&null!=e.assign&&e.assign instanceof Function}),(Sl=kl||(kl={})).R0="R0",Sl.R1="R1",Sl.R2="R2",Sl.R3="R3",Sl.R4="R4",Sl.R5="R5",Sl.R6="R6",(Cl=Il||(Il={})).float32="float32",Cl.int32="int32",Cl.bool="int32",Cl.complex64="complex64",(Nl=Tl||(Tl={})).float32="float32",Nl.int32="int32",Nl.bool="bool",Nl.complex64="complex64",($l=El||(El={})).float32="float32",$l.int32="float32",$l.bool="float32",$l.complex64="complex64",(Al=Rl||(Rl={})).float32="complex64",Al.int32="complex64",Al.bool="complex64",Al.complex64="complex64";const _l={float32:El,int32:Il,bool:Tl,complex64:Rl};function Ol(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return _l[e][t]}function Dl(e){return Ol(e,"int32")}function Fl(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Ll(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function zl(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ol(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ml(e){const t=[];return Pl(e,t,new Set),t}function Pl(e,t,n){if(null==e)return;if(e instanceof xl)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const a in s){const e=s[a];n.has(e)||(n.add(e),Pl(e,t,n))}}function Bl(e){return null!=e.kernelName}class Ul{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Wl{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ul}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void(await this.setBackend(n))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Eo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ll(this.backendInstance),!0}setupRegisteredKernels(){Oo(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Oo(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof Nr||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0)))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Eo(`Initialization of backend ${e} failed`),Eo(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(DP){return Eo(`Initialization of backend ${e} failed`),Eo(DP.stack||DP.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Wl.nextTensorId++}nextVariableId(){return Wl.nextVariableId++}clone(e){const t=Gl.runKernel(_a,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e};return Gl.runKernel(Us,t,{dtype:"float32"})}})),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==Ao(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=Bl(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Bl(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const l=Ao(t,this.backendName);Or(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,h=Bl(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()})),r&&this.addTapeNode(l,u,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const r=_o(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(Or(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&Xr(e[0])&&(s=e.map((e=>sl(e))));const a=r.write(s,t,n),i=new xl(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new xl(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new wl(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Kr(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof wl||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Kr(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=_o(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=ss(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Ml(e),n=new Set(t.map((e=>e.id)));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(Or(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Or(s instanceof xl,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=rs(Lr(e),"float32");return Gl.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!zr(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),Hl);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){return Or(Jr(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;Or(t.every((e=>e instanceof xl)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};return t.forEach(((e,t)=>{r[t]=e})),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Or(n.value instanceof xl,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Or(Jr(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];Or(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Or(a.every((e=>e instanceof xl)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=rl(),n=await this.backend.time(e);return n.wallMs=rl()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ul;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Vl(){const e=ms();if(null==e._tfengine){const t=new hs(e);e._tfengine=new Wl(t)}var t;return t=e._tfengine.ENV,gs=t,bl=()=>e._tfengine,e._tfengine}Wl.nextTensorId=0,Wl.nextVariableId=0;const Gl=Vl();function Hl(e,t){const n={a:e,b:t};return Gl.runKernel(ws,n)}function jl(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function ql(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Kl=ps();function Xl(e,t){let n=e;if(il(e))return"string"===t?[]:[e.length];if(Fl(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Ll(e))return[e.buffer.size/(null==t?4:Kr(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||il(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&ps().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Yl(e,r,[]),r}function Yl(e,t,n){if(n=n||[],!Array.isArray(e)&&!il(e))return void Or(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Or(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Or(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let s=0;s<e.length;++s)Yl(e[s],r,n.concat(s))}function Ql(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Jl(e,t,n,r="numeric"){if(e instanceof vl())return Ql(r,e.dtype,t,n),e;let s=Qr(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Ql(r,s,t,n),null==e||!il(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Xl(e,s);il(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?nl(e,s):ol(e,[],!0);return Gl.makeTensor(i,a,s)}function Zl(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>Jl(e,`${t}[${s}]`,n,r)))}function eu(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...e)=>{Gl.startScope(n);try{const t=r(...e);return us(t)&&console.error("Cannot return a Promise inside of tidy."),Gl.endScope(t),t}catch(t){throw Gl.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}Kl.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Kl.registerFlag("IS_BROWSER",(()=>ql())),Kl.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),Kl.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Kl.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Kl.registerFlag("PROD",(()=>!1)),Kl.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Kl.getBool("DEBUG"))),Kl.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Kl.registerFlag("IS_TEST",(()=>!1)),Kl.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Kl.getBool("DEBUG"))),Kl.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Kl.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Kl.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const tu=eu({complex_:function(e,t){const n=Jl(e,"real","complex"),r=Jl(t,"imag","complex");Dr(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return Gl.runKernel(Gs,s)}});function nu(e,t,n,r){if(null==r)r=Qr(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Ll(e)||Fl(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Gl.backend.createTensorFromGPUData(e,t||n,r)}if(!il(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){is(t);const e=Lr(t),r=Lr(n);Or(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Lr(t.slice(s));Or(n[s]===t[s]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return il(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?nl(e,r):ol(e,[],!0),Gl.makeTensor(e,t,r)}function ru(e,t,n){return nu(e,t,Xl(e,n),n)}const su={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class au{static join(e){return new au(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>il(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(s.set(u,o),a+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function iu(){return Gl}function ou(){return Gl.memory()}function lu(e,t){return Gl.tidy(e,t)}function uu(e){Ml(e).forEach((e=>e.dispose()))}function cu(e){return Gl.keep(e)}function hu(e,t,n=1){return Gl.registerBackend(e,t,n)}async function du(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,r=new Uint8Array(n);let s=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=4,r.set(e,s),s+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:gu(await Promise.all(r)),specs:n}}function pu(e,t){const n=Lr(e.shape);let r;if("quantization"in e){const t=e.quantization;r=su[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=4+new Uint32Array(t(e,e+4))[0];return e}r=su[e.dtype]}return n*r}function fu(e,t){const n=e.name,r=e.dtype,s=e.shape,a=Lr(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const l=su[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];a[i]=o}return new Float32Array(s)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*l}else if("string"===r){const n=Lr(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+4))[0];o+=4;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=su[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=ru(e,s,"float32"),a=ru(n,s,"float32"),o=tu(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return ru(i,s,r)}function gu(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const mu="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function bu(e){return mu?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function yu(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:bu(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:bu(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new au(e.weightData).byteLength}}function xu(e){const t=[];for(const n of e)t.push(...n.weights);return t}class vu{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==vu.instance&&(vu.instance=new vu),vu.instance}static registerSaveRouter(e){vu.getInstance().saveRouters.push(e)}static registerLoadRouter(e){vu.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return vu.getHandlers(e,"save")}static getLoadHandlers(e,t){return vu.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?vu.getInstance().loadRouters:vu.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const wu="tensorflowjs",ku="models_store",Su="model_info_store";function Iu(){if(!ps().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Cu(e){const t=e.result;t.createObjectStore(ku,{keyPath:"modelPath"}),t.createObjectStore(Su,{keyPath:"modelPath"})}class Tu{constructor(e){if(this.indexedDB=Iu(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(wu,1);r.onupgradeneeded=()=>Cu(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(ku,"readonly"),r=t.objectStore(ku).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=au.join(t.weightData);const r=yu(t),i=s.transaction(Su,"readwrite");let o,l,u=i.objectStore(Su);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(a){return n(a)}o.onsuccess=()=>{l=s.transaction(ku,"readwrite");const o=l.objectStore(ku);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(a){return n(a)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore(Su);const t=u.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(c.error)),t.onerror=e=>(s.close(),n(c.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}Tu.URL_SCHEME="indexeddb://";const Nu=e=>{return ps().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Tu.URL_SCHEME)?(t=e.slice(Tu.URL_SCHEME.length),new Tu(t)):null;var t};vu.registerSaveRouter(Nu),vu.registerLoadRouter(Nu);class Eu{constructor(){this.indexedDB=Iu()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(wu,1);n.onupgradeneeded=()=>Cu(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(Su,"readonly"),a=s.objectStore(Su).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Tu.URL_SCHEME)?t.slice(Tu.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(wu,1);r.onupgradeneeded=()=>Cu(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(Su,"readwrite"),i=a.objectStore(Su),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(ku,"readwrite");const r=l.objectStore(ku).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const $u="/",Ru="tensorflowjs_models",Au="info",_u="model_topology",Ou="weight_specs",Du="weight_data",Fu="model_metadata";function Lu(e){return{info:[Ru,e,Au].join($u),topology:[Ru,e,_u].join($u),weightSpecs:[Ru,e,Ou].join($u),weightData:[Ru,e,Du].join($u),modelMetadata:[Ru,e,Fu].join($u)}}function zu(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Mu(e){const t=e.split($u);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join($u)}class Pu{constructor(e){if(!ps().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Lu(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=yu(e),s=au.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(mu)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(DP){throw zu(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(mu){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(a),t}}Pu.URL_SCHEME="localstorage://";const Bu=e=>{return ps().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Pu.URL_SCHEME)?(t=e.slice(Pu.URL_SCHEME.length),new Pu(t)):null;var t};vu.registerSaveRouter(Bu),vu.registerLoadRouter(Bu);class Uu{constructor(){Or(ps().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Or("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Ru+$u,n=$u+Au;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(t)&&s.endsWith(n)&&(e[Mu(s)]=JSON.parse(this.LS.getItem(s)))}return e}async removeModel(e){var t;const n=Lu(e=(t=e).startsWith(Pu.URL_SCHEME)?t.slice(Pu.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return zu(n),r}}class Wu{constructor(){this.managers={}}static getInstance(){return null==Wu.instance&&(Wu.instance=new Wu),Wu.instance}static registerManager(e,t){Or(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Or(e.length>0,(()=>"scheme must not be an empty string."));const n=Wu.getInstance();Or(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Wu.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Wu.getInstance().managers)}}class Vu{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&ps().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))}),!0))):setTimeout(e,t)}isTypedArray(e){return zo(e)}}if(ps().get("IS_BROWSER")){ps().setPlatform("browser",new Vu);try{Wu.registerManager(Pu.URL_SCHEME,new Uu)}catch(DP){}try{Wu.registerManager(Tu.URL_SCHEME,new Eu)}catch(DP){}}let Gu;function Hu(e,t="float32",n){return t=t||"float32",is(e),new ml(e,t,n)}ps().get("IS_NODE")&&!ps().get("IS_BROWSER")&&ps().setPlatform("node",new class{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=ps().global.fetch?ps().global.fetch(e,t):(null==Gu&&(Gu=require("node-fetch")),Gu(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});const ju=eu({cast_:function(e,t){const n=Jl(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return Gl.runKernel(Us,r,s)}}),qu=eu({clone_:function(e){const t={x:Jl(e,"x","clone","string_or_numeric")};return Gl.runKernel(_a,t)}});Vl(),yl={buffer:Hu,cast:ju,clone:qu,print:function(e,t=!1){console.log(e.toString(t))}};const Ku=eu({add_:function(e,t){let n=Jl(e,"a","add"),r=Jl(t,"b","add");[n,r]=zl(n,r);const s={a:n,b:r};return Gl.runKernel(ws,s)}}),Xu=eu({floorDiv_:function(e,t){let n=Jl(e,"a","floorDiv"),r=Jl(t,"b","floorDiv");[n,r]=zl(n,r);const s={a:n,b:r};return Gl.runKernel(Ta,s)}}),Yu=eu({div_:function(e,t){let n=Jl(e,"a","div"),r=Jl(t,"b","div");if([n,r]=zl(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Xu(n,r);const s={a:n,b:r};return Gl.runKernel(pa,s,{})}}),Qu=eu({mul_:function(e,t){let n=Jl(e,"a","mul"),r=Jl(t,"b","mul");[n,r]=zl(n,r);const s={a:n,b:r};return Gl.runKernel(li,s)}}),Ju=eu({abs_:function(e){const t=Jl(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Gl.runKernel(Hs,e)}{const e={x:t};return Gl.runKernel(ys,e)}}}),Zu=eu({acos_:function(e){const t={x:Jl(e,"x","acos")};return Gl.runKernel(xs,t)}}),ec=eu({acosh_:function(e){const t={x:Jl(e,"x","acosh")};return Gl.runKernel(vs,t)}}),tc=eu({all_:function(e,t=null,n=!1){const r={x:Jl(e,"x","all","bool")},s={axis:t,keepDims:n};return Gl.runKernel(Ss,r,s)}}),nc=eu({any_:function(e,t=null,n=!1){const r={x:Jl(e,"x","any","bool")},s={axis:t,keepDims:n};return Gl.runKernel(Is,r,s)}}),rc=eu({argMax_:function(e,t=0){const n={x:Jl(e,"x","argMax")},r={axis:t};return Gl.runKernel(Cs,n,r)}}),sc=eu({argMin_:function(e,t=0){const n={x:Jl(e,"x","argMin")},r={axis:t};return Gl.runKernel(Ts,n,r)}}),ac=eu({asin_:function(e){const t={x:Jl(e,"x","asin")};return Gl.runKernel(Ns,t)}}),ic=eu({asinh_:function(e){const t={x:Jl(e,"x","asinh")};return Gl.runKernel(Es,t)}}),oc=eu({atan_:function(e){const t={x:Jl(e,"x","atan")};return Gl.runKernel($s,t)}}),lc=eu({atan2_:function(e,t){let n=Jl(e,"a","atan2"),r=Jl(t,"b","atan2");[n,r]=zl(n,r);const s={a:n,b:r};return Gl.runKernel(As,s)}}),uc=eu({atanh_:function(e){const t={x:Jl(e,"x","atanh")};return Gl.runKernel(Rs,t)}});function cc(e,t,n,r,s="NHWC",a){return pc(e,[...t,e[3]],n,a,r,null,null,Sc(s))}function hc(e,t,n,r,s,a,i="channelsLast"){const[o,l]=mc(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return pc(e,u,n,r,s,a,!1,i)}function dc(e,t,n,r,s,a,i="NDHWC"){const[o,l,u]=bc(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[o,l,u,e[1],e[1]]}return fc(e,c,n,r,s,!1,h,a)}function pc(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=e}const[d,p,,f]=t,[g,m]=mc(n),[b,y]=mc(r),x=yc(d,b),v=yc(p,y),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,s,a,i,o,l){let u,c,h;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=gc(e,t,n));const a=e[1];return[xc((e[0]-t+2*r)/n+1,s),xc((a-t+2*r)/n+1,s)]}([t,n],a,r,e,o);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(h-1)*s+i-n),l=Math.floor(e/2),d=e-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],g="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},c=xc((t-a+d+p)/r+1,o),h=xc((n-i+f+g)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(s,u,c,g,m,x,v,a,o),I=i?f*h:f;let C;return"channelsFirst"===o?C=[l,I,k,S]:"channelsLast"===o&&(C=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:y,inShape:e,outShape:C,filterShape:t}}function fc(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c,h]=e}const[p,f,g,,m]=t,[b,y,x]=bc(n),[v,w,k]=bc(r),S=yc(p,v),I=yc(f,w),C=yc(g,k),{padInfo:T,outDepth:N,outHeight:E,outWidth:$}=function(e,t,n,r,s,a,i,o,l,u,c){let h,d,p,f;if("valid"===e&&(e=0),"number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const g=function(e,t,n,r,s,a){null==s&&(s=gc(e,t[0],r[0]));const i=[0,0,0,1];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=xc((e[o]-t[o]+2*s)/r[o]+1,a));return i}([t,n,r,1],[o,l,u],0,[s,a,i],e,c);d=g[0],p=g[1],f=g[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(d-1)*s+o-t,c=(p-1)*a+l-n,g=(f-1)*i+u-r,m=Math.floor(e/2),b=e-m,y=Math.floor(c/2),x=c-y,v=Math.floor(g/2);h={top:y,bottom:x,left:v,right:g-v,front:m,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,u,c,h,b,y,x,S,I,C,o),R=a?m*d:m;let A;return"channelsFirst"===i?A=[l,R,N,E,$]:"channelsLast"===i&&(A=[l,N,E,$,R]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:N,outHeight:E,outWidth:$,outChannels:R,padInfo:T,strideDepth:b,strideHeight:y,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:C,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function gc(e,t,n,r=1){const s=yc(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function mc(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function bc(e){return"number"==typeof e?[e,e,e]:e}function yc(e,t){return t<=1?e:e+(e-1)*(t-1)}function xc(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function vc(e){const[t,n,r]=mc(e);return 1===t&&1===n&&1===r}function wc(e,t){return vc(e)||vc(t)}function kc(e){return mc(e).every((e=>e>0))}function Sc(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Ic(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Or(Mr(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Or(Mr(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Cc=eu({reshape_:function(e,t){const n={x:Jl(e,"x","reshape","string_or_numeric")},r={shape:t};return Gl.runKernel(Ei,n,r)}}),Tc=eu({avgPool_:function(e,t,n,r,s){const a=Jl(e,"x","avgPool","float32");Or(wc(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,o=!1;3===a.rank&&(o=!0,i=Cc(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Or(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),Ic("avgPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=Gl.runKernel(_s,l,u);return c=ju(c,a.dtype),o?Cc(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Nc=eu({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=Jl(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=Cc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Or(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Or("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Or("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Ic("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let h=Gl.runKernel(Ds,u,c);return h=ju(h,o.dtype),l?Cc(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),Ec=eu({concat_:function(e,t=0){Or(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Zl(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return qu(n[0]);const r=n,s={axis:t};return Gl.runKernel(js,r,s)}}),$c=eu({matMul_:function(e,t,n=!1,r=!1){let s=Jl(e,"a","matMul"),a=Jl(t,"b","matMul");[s,a]=zl(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return Gl.runKernel(Ls,i,o)}}),Rc=eu({sigmoid_:function(e){const t={x:Jl(e,"x","sigmoid","float32")};return Gl.runKernel(ji,t)}}),Ac=eu({slice_:function(e,t,n){const r=Jl(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return Gl.runKernel(Wi,s,a)}}),_c=eu({tanh_:function(e){const t={x:Jl(e,"x","tanh","float32")};return Gl.runKernel(fo,t)}}),Oc=eu({batchToSpaceND_:function(e,t,n){const r=Jl(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));Or(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Or(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Or(r.shape[0]%s==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return Gl.runKernel(zs,a,i)}}),Dc=eu({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=Jl(e,"x","batchNorm"),o=Jl(t,"mean","batchNorm"),l=Jl(n,"variance","batchNorm");let u,c;null!=s&&(u=Jl(s,"scale","batchNorm")),null!=r&&(c=Jl(r,"offset","batchNorm")),Or(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Or(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Or(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Cc(e,[1,1,1,e.size]):2===e.rank?Cc(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Cc(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:u,offset:c,mean:o,variance:l},d={varianceEpsilon:a},p=Gl.runKernel(Na,h,d);return Cc(p,i.shape)}}),Fc=eu({batchNorm2d_:function(e,t,n,r,s,a){const i=Jl(e,"x","batchNorm"),o=Jl(t,"mean","batchNorm"),l=Jl(n,"variance","batchNorm");let u,c;return null!=s&&(u=Jl(s,"scale","batchNorm")),null!=r&&(c=Jl(r,"offset","batchNorm")),Or(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Or(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Or(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Or(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&Or(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),Dc(i,o,l,c,u,a)}}),Lc=eu({batchNorm3d_:function(e,t,n,r,s,a){const i=Jl(e,"x","batchNorm"),o=Jl(t,"mean","batchNorm"),l=Jl(n,"variance","batchNorm");let u,c;return null!=s&&(u=Jl(s,"scale","batchNorm")),null!=r&&(c=Jl(r,"offset","batchNorm")),Or(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Or(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Or(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Or(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&Or(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),Dc(i,o,l,c,u,a)}}),zc=eu({batchNorm4d_:function(e,t,n,r,s,a){const i=Jl(e,"x","batchNorm"),o=Jl(t,"mean","batchNorm"),l=Jl(n,"variance","batchNorm");let u,c;return null!=s&&(u=Jl(s,"scale","batchNorm")),null!=r&&(c=Jl(r,"offset","batchNorm")),Or(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Or(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Or(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Or(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&Or(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),Dc(i,o,l,c,u,a)}}),Mc=eu({bincount_:function(e,t,n){const r=Jl(e,"x","bincount"),s=Jl(t,"weights","bincount");Or("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Or(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Or(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return Gl.runKernel(Ms,a,i)}}),Pc=eu({broadcastTo_:function(e,t){let n=Jl(e,"broadcastTo","x");const r=n.shape;if(is(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Cc(n,e)}const s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return qu(n);const i={x:n},o={reps:a};return Gl.runKernel(go,i,o)}}),Bc=eu({ceil_:function(e){const t={x:Jl(e,"x","ceil","float32")};return Gl.runKernel(Ws,t)}});function Uc(e,t,n){is(e);const r={shape:e,value:t,dtype:n=n||Qr(t)};return Gl.runKernel(Sa,{},r)}const Wc=eu({clipByValue_:function(e,t,n){const r=Jl(e,"x","clipByValue");if(Or(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return Uc(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return Gl.runKernel(Vs,s,a)}}),Vc=eu({concat1d_:function(e){return Ec(e,0)}}),Gc=eu({concat2d_:function(e,t){return Ec(e,t)}}),Hc=eu({concat3d_:function(e,t){return Ec(e,t)}}),jc=eu({concat4d_:function(e,t){return Ec(e,t)}}),qc=eu({conv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=Jl(e,"x","conv2d","float32"),l=Jl(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Cc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Or(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Or(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Ic("conv2d",r,i);const h="NHWC"===s?u.shape[3]:u.shape[1];Or(h===l.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`)),Or(wc(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Or(kc(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Or(kc(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=Gl.runKernel(qs,d,p);return c?Cc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Kc=eu({conv1d_:function(e,t,n,r,s="NWC",a=1,i){const o=Jl(e,"x","conv1d"),l=Jl(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Cc(o,[1,o.shape[0],o.shape[1]])),Or(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Or(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Ic("conv1d",r,i),Or(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Or(wc(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),Or(kc(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Or(kc(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Or("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const h=Cc(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Cc(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=qc(d,h,[1,n],r,"NHWC",[1,a],i);return Cc(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),Xc=eu({conv2DBackpropInput_:function(e,t,n,r,s,a="NHWC",i){Or(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Cc(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Or(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Or(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Or(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===a?o[3]:o[1],h="NHWC"===a?l.shape[3]:l.shape[1];Or(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Or(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),Ic("conv2dDerInput",s,i);const d={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=Gl.runKernel(Xs,d,p);return u?Cc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Yc=eu({conv2dTranspose_:function(e,t,n,r,s,a){const i=Jl(e,"x","conv2dTranspose"),o=Jl(t,"filter","conv2dTranspose");return Xc(n,i,o,r,s,"NHWC",a)}}),Qc=eu({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=Jl(e,"x","conv3d"),o=Jl(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=Cc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Or(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Or(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Or(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Or(wc(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Or("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),Or(kc(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Or(kc(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},h={strides:n,pad:r,dataFormat:s,dilations:a},d=Gl.runKernel(Ys,c,h);return u?Cc(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Jc=eu({conv3DBackpropInput_:function(e,t,n,r,s){Or(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Cc(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];Or(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),Or(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Or(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Or(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Or(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},h={pad:s,strides:r,inputShape:a},d=Gl.runKernel(Js,c,h);return o?Cc(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Zc=eu({conv3dTranspose_:function(e,t,n,r,s){const a=Jl(e,"x","conv3dTranspose"),i=Jl(t,"filter","conv3dTranspose");return Jc(n,a,i,r,s)}}),eh=eu({cos_:function(e){const t={x:Jl(e,"x","cos","float32")};return Gl.runKernel(Zs,t)}}),th=eu({cosh_:function(e){const t={x:Jl(e,"x","cosh","float32")};return Gl.runKernel(ea,t)}}),nh=eu({cumprod_:function(e,t=0,n=!1,r=!1){const s={x:Jl(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return Gl.runKernel(ta,s,a)}}),rh=eu({cumsum_:function(e,t=0,n=!1,r=!1){const s={x:Jl(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return Gl.runKernel(na,s,a)}}),sh=eu({denseBincount_:function(e,t,n,r=!1){const s=Jl(e,"x","denseBincount"),a=Jl(t,"weights","denseBincount");Or("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),Or(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),Or(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Or(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return Gl.runKernel(sa,i,o)}}),ah=eu({depthToSpace_:function(e,t,n="NHWC"){const r=Jl(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Or(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Or(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Or(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Or(i%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return Gl.runKernel(aa,o,l)}}),ih=eu({depthwiseConv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=Jl(e,"x","depthwiseConv2d","float32"),l=Jl(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Cc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Or(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Or(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const h="NHWC"===s?u.shape[3]:u.shape[1];Or(h===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Ic("depthwiseConv2d",r,i);const d={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=Gl.runKernel(ia,d,p);return c?Cc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),oh=eu({dilation2d_:function(e,t,n,r,s=[1,1],a="NHWC"){const i=Jl(e,"x","dilation2d"),o=Jl(t,"filter","dilation2d");Or(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Or(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Or("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let l=i,u=!1;3===i.rank&&(l=Cc(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Or(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},h={strides:n,pad:r,dilations:s},d=Gl.runKernel(ca,c,h);return u?Cc(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});function lh(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function uh(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function ch(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-s-1]=a}}return r}const hh=eu({equal_:function(e,t){let n=Jl(e,"a","equal","string_or_numeric"),r=Jl(t,"b","equal","string_or_numeric");[n,r]=zl(n,r),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(ya,s)}}),dh=eu({where_:function(e,t,n){const r=Jl(t,"a","where"),s=Jl(n,"b","where"),a=Jl(e,"condition","where","bool"),i=ch(ch(a.shape,r.shape),s.shape),o={condition:Pc(a,i),t:Pc(r,i),e:Pc(s,i)};return Gl.runKernel(Bi,o)}}),ph=eu({zerosLike_:function(e){const t={x:Jl(e,"x","zerosLike")};return Gl.runKernel(ko,t)}}),fh=eu({divNoNan_:function(e,t){let n=Jl(e,"a","div"),r=Jl(t,"b","div");[n,r]=zl(n,r);const s=Yu(n,r),a=ph(s),i=hh(r,a);return dh(i,a,s)}}),gh=eu({dot_:function(e,t){const n=Jl(e,"t1","dot"),r=Jl(t,"t2","dot");Or(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(Or(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=Cc(n,[1,-1]),t=Cc(r,[-1,1]),s=$c(e,t);return Cc(s,[])}if(1===n.rank&&2===r.rank){const e=Cc(n,[1,-1]),t=Cc(r,[r.shape[0],r.shape[1]]),s=$c(e,t);return Cc(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Cc(r,[-1,1]),t=$c(n,e);return Cc(t,[t.size])}{const e=Cc(r,[r.shape[0],r.shape[1]]);return $c(n,e)}}}),mh=eu({einsum_:function(e,...t){const n=t.map(((e,t)=>Jl(e,`tensors${t}`,"einsum"))),r={equation:e};return Gl.runKernel(fa,n,r)}}),bh=eu({elu_:function(e){const t={x:Jl(e,"x","elu","float32")};return Gl.runKernel(ga,t)}}),yh=eu({erf_:function(e){let t=Jl(e,"x","erf");Or("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=ju(t,"float32"));const n={x:t};return Gl.runKernel(ba,n)}});function xh(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function vh(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function wh(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function kh(e,t){return vh(e,t.map((e=>1)),t)}function Sh(e,t,n){Or(xh(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Ih(e,t){if(xh(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Ch(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Th(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Nh=eu({max_:function(e,t=null,n=!1){const r={x:Jl(e,"x","max")},s={reductionIndices:t,keepDims:n};return Gl.runKernel(Xa,r,s)}}),Eh=eu({min_:function(e,t=null,n=!1){const r={x:Jl(e,"x","min")},s={axis:t,keepDims:n};return Gl.runKernel(ri,r,s)}}),$h=eu({pow_:function(e,t){let n=Jl(e,"base","pow"),r=Jl(t,"exp","pow");[n,r]=zl(n,r);const s={a:n,b:r};return Gl.runKernel(yi,s)}});function Rh(e,t){if((il(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&il(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return nu(e,[],[],t)}const Ah=eu({sqrt_:function(e){const t={x:Jl(e,"x","sqrt","float32")};return Gl.runKernel(Ki,t)}}),_h=eu({square_:function(e){const t=Jl(e,"x","square");return Gl.runKernel("Square",{x:t},{})}}),Oh=eu({sum_:function(e,t=null,n=!1){let r=Jl(e,"x","sum");"bool"===r.dtype&&(r=ju(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Gl.runKernel(Xi,s,a)}});function Dh(e,t,n=null){if(0===e.rank)return Ju(e);if(1!==e.rank&&null===n)return Dh(Cc(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Oh(Ju(e),n);if(t===1/0)return Nh(Ju(e),n);if(t===-1/0)return Eh(Ju(e),n);if("euclidean"===t||2===t)return Ah(Oh($h(Ju(e),Rh(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Nh(Oh(Ju(e),n[0]),n[1]-1);if(t===1/0)return Nh(Oh(Ju(e),n[1]),n[0]);if(t===-1/0)return Eh(Oh(Ju(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Ah(Oh(_h(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Fh=eu({norm_:function(e,t="euclidean",n=null,r=!1){const s=Dh(e=Jl(e,"x","norm"),t,n);let a=s.shape;if(r){const t=Vr(n,e.shape);a=kh(s.shape,t)}return Cc(s,a)}}),Lh=eu({euclideanNorm_:function(e,t=null,n=!1){return Fh(e,"euclidean",t,n)}}),zh=eu({exp_:function(e){const t={x:Jl(e,"x","exp")};return Gl.runKernel(xa,t)}}),Mh=eu({expandDims_:function(e,t=0){const n=Jl(e,"x","expandDims","string_or_numeric");Or(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return Gl.runKernel(va,r,s)}}),Ph=eu({expm1_:function(e){const t={x:Jl(e,"x","expm1")};return Gl.runKernel(wa,t)}}),Bh=eu({tile_:function(e,t){const n=Jl(e,"x","tile","string_or_numeric");Or(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return Gl.runKernel(go,r,s)}}),Uh=eu({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=Hu([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);const i=Cc(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return Bh(Mh(i,0),[n[0],1,1]);if(2===n.length)return Bh(Mh(Mh(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return Bh(Mh(Mh(Mh(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),Wh=eu({floor_:function(e){const t={x:Jl(e,"x","floor","float32")};return Gl.runKernel(Ca,t)}}),Vh=eu({gather_:function(e,t,n=0,r=0){const s={x:Jl(e,"x","gather"),indices:Jl(t,"indices","gather","int32")},a={axis:n,batchDims:r};return Gl.runKernel(Ea,s,a)}}),Gh=eu({greater_:function(e,t){let n=Jl(e,"a","greater","string_or_numeric"),r=Jl(t,"b","greater","string_or_numeric");[n,r]=zl(n,r),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(Ra,s)}}),Hh=eu({greaterEqual_:function(e,t){let n=Jl(e,"a","greaterEqual","string_or_numeric"),r=Jl(t,"b","greaterEqual","string_or_numeric");[n,r]=zl(n,r),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(Aa,s)}}),jh=eu({imag_:function(e){const t={input:Jl(e,"input","imag")};return Gl.runKernel(Da,t)}}),qh=eu({isFinite_:function(e){const t={x:Jl(e,"x","isFinite")};return Gl.runKernel(Fa,t)}}),Kh=eu({isInf_:function(e){const t={x:Jl(e,"x","isInf")};return Gl.runKernel(La,t)}}),Xh=eu({isNaN_:function(e){const t={x:Jl(e,"x","isNaN")};return Gl.runKernel(za,t)}}),Yh=eu({leakyRelu_:function(e,t=.2){const n={x:Jl(e,"x","leakyRelu")},r={alpha:t};return Gl.runKernel(Ma,n,r)}}),Qh=eu({less_:function(e,t){let n=Jl(e,"a","less","string_or_numeric"),r=Jl(t,"b","less","string_or_numeric");[n,r]=zl(n,r),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(Pa,s)}}),Jh=eu({lessEqual_:function(e,t){let n=Jl(e,"a","lessEqual","string_or_numeric"),r=Jl(t,"b","lessEqual","string_or_numeric");[n,r]=zl(n,r),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(Ba,s)}}),Zh=eu({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const a=Jl(e,"x","localResponseNormalization");Or(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),Or(Mr(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=Cc(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=Gl.runKernel(qa,l,u);return o?Cc(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),ed=eu({log_:function(e){const t={x:Jl(e,"x","log","float32")};return Gl.runKernel(Wa,t)}}),td=eu({log1p_:function(e){const t={x:Jl(e,"x","log1p")};return Gl.runKernel(Va,t)}});function nd(e){return Gl.customGrad(e)}const rd=eu({neg_:function(e){const t={x:Jl(e,"x","neg")};return Gl.runKernel(ui,t)}}),sd=eu({softplus_:function(e){const t={x:Jl(e,"x","softplus")};return Gl.runKernel(qi,t)}}),ad=eu({logSigmoid_:function(e){const t=Jl(e,"x","logSigmoid");return nd((e=>({value:rd(sd(rd(e))),gradFunc:t=>Qu(t,Rc(rd(e)))})))(t)}}),id=eu({sub_:function(e,t){let n=Jl(e,"a","sub"),r=Jl(t,"b","sub");[n,r]=zl(n,r);const s={a:n,b:r};return Gl.runKernel(ho,s)}}),od=eu({logSoftmax_:function(e,t=-1){const n=Jl(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return nd(((e,n)=>{const r=Nh(e,t,!0),s=id(e,r),a=id(ju(s,"float32"),ed(Oh(zh(s),t,!0)));return n([a]),{value:a,gradFunc:(e,n)=>{const[r]=n,s=zh(r);return id(e,Qu(Oh(e,t,!0),s))}}}))(n)}}),ld=eu({logSumExp_:function(e,t=null,n=!1){const r=Jl(e,"x","logSumExp"),s=Vr(t,r.shape),a=Nh(r,s,!0),i=id(r,a),o=zh(i),l=Oh(o,s),u=ed(l),c=Ku(Cc(a,u.shape),u);if(n){const e=kh(c.shape,s);return Cc(c,e)}return c}}),ud=eu({logicalAnd_:function(e,t){const n=Jl(e,"a","logicalAnd","bool"),r=Jl(t,"b","logicalAnd","bool");ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(Ga,s)}}),cd=eu({logicalNot_:function(e){const t={x:Jl(e,"x","logicalNot","bool")};return Gl.runKernel(Ha,t)}}),hd=eu({logicalOr_:function(e,t){const n=Jl(e,"a","logicalOr","bool"),r=Jl(t,"b","logicalOr","bool");ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(ja,s)}}),dd=eu({logicalXor_:function(e,t){const n=Jl(e,"a","logicalXor","bool"),r=Jl(t,"b","logicalXor","bool");return ch(n.shape,r.shape),ud(hd(e,t),cd(ud(e,t)))}}),pd=eu({maxPool_:function(e,t,n,r,s){const a=Jl(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Cc(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Or(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Or(wc(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Ic("maxPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=Gl.runKernel(Qa,l,u);return o?Cc(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),fd=eu({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=Jl(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=Cc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Or(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Or("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Ic("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},h=Gl.runKernel(Za,u,c);return l?Cc(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),gd=eu({maximum_:function(e,t){let n=Jl(e,"a","maximum"),r=Jl(t,"b","maximum");[n,r]=zl(n,r),"bool"===n.dtype&&(n=ju(n,"int32"),r=ju(r,"int32")),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(Ya,s)}}),md=eu({mean_:function(e,t=null,n=!1){const r={x:Jl(e,"x","mean")},s={axis:t,keepDims:n};return Gl.runKernel(ni,r,s)}});function bd(e,t="float32"){if(is(e),"complex64"===t){const t=bd(e,"float32"),n=bd(e,"float32");return tu(t,n)}const n=ss(Lr(e),t);return Gl.makeTensor(n,e,t)}function yd(e,t="float32"){if(is(e),"complex64"===t){const t=yd(e,"float32"),n=bd(e,"float32");return tu(t,n)}const n=rs(Lr(e),t);return Gl.makeTensor(n,e,t)}const xd=eu({minimum_:function(e,t){let n=Jl(e,"a","minimum"),r=Jl(t,"b","minimum");[n,r]=zl(n,r),"bool"===n.dtype&&(n=ju(n,"int32"),r=ju(r,"int32")),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(si,s)}}),vd=eu({mirrorPad_:function(e,t,n){Or("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=Jl(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Or(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Or(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Or(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return Gl.runKernel(ai,i,a)}}),wd=eu({mod_:function(e,t){let n=Jl(e,"a","mod"),r=Jl(t,"b","mod");[n,r]=zl(n,r);const s={a:n,b:r};return Gl.runKernel(ii,s)}}),kd=eu({moments_:function(e,t=null,n=!1){const r=Vr(t,(e=Jl(e,"x","moments")).shape),s=md(e,r,n);let a=s.shape;n||(a=kh(s.shape,r));const i=_h(id(ju(e,"float32"),Cc(s,a)));return{mean:s,variance:md(i,r,n)}}}),Sd=eu({notEqual_:function(e,t){let n=Jl(e,"a","notEqual","string_or_numeric"),r=Jl(t,"b","notEqual","string_or_numeric");[n,r]=zl(n,r),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(ci,s)}}),Id=eu({oneHot_:function(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:Jl(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return Gl.runKernel(gi,a,i)}}),Cd=eu({onesLike_:function(e){const t={x:Jl(e,"x","onesLike")};return Gl.runKernel(fi,t)}}),Td=eu({pad_:function(e,t,n=0){const r=Jl(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return Gl.runKernel(bi,a,s)}}),Nd=eu({spaceToBatchND_:function(e,t,n){const r=Jl(e,"x","spaceToBatchND");Or(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Or(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Or(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return Gl.runKernel(Yi,s,a)}}),Ed=eu({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=Jl(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Cc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Or(wc(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const c=hc(l.shape,t,a,s,r),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),s=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],s[t]]))}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,g]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t]));return[t.map(((e,t)=>[r[t],o[t]])),t.map(((e,t)=>[0,i[t]]))]}([c.inHeight,c.inWidth],h,d),m=p?r:"valid",b=p?l:Nd(l,h,f),y=("avg"===n?()=>Tc(b,t,a,m,i):()=>pd(b,t,a,m,i))(),x=p?y:Oc(y,h,g);return u?Cc(x,[x.shape[1],x.shape[2],x.shape[3]]):x}}),$d=eu({prelu_:function(e,t){const n={x:Jl(e,"x","prelu"),alpha:Jl(t,"alpha","prelu")};return Gl.runKernel(xi,n)}}),Rd=eu({prod_:function(e,t=null,n=!1){let r=Jl(e,"x","prod");"bool"===r.dtype&&(r=ju(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Gl.runKernel(vi,s,a)}});var Ad,_d={exports:{}};var Od,Dd,Fd,Ld,zd,Md={exports:{}},Pd={exports:{}},Bd={exports:{}},Ud={exports:{}},Wd={exports:{}},Vd={exports:{}};const Gd=r(Object.freeze(Object.defineProperty({__proto__:null,default:{}},Symbol.toStringTag,{value:"Module"})));var Hd,jd,qd,Kd=Vd.exports;function Xd(){return Hd||(Hd=1,e=Vd,function(t,n,r){var s,a=256,i="random",o=r.pow(a,6),l=r.pow(2,52),u=2*l,c=255;function h(e,c,h){var b=[],y=g(f((c=1==c?{entropy:!0}:c||{}).entropy?[e,m(n)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(a):(e=new Uint8Array(a),(t.crypto||t.msCrypto).getRandomValues(e)),m(e)}catch(o){var r=t.navigator,i=r&&r.plugins;return[+new Date,t,i,t.screen,m(n)]}}():e,3),b),x=new d(b),v=function(){for(var e=x.g(6),t=o,n=0;e<l;)e=(e+n)*a,t*=a,n=x.g(1);for(;e>=u;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|x.g(4)},v.quick=function(){return x.g(4)/4294967296},v.double=v,g(m(x.S),n),(c.pass||h||function(e,t,n,s){return s&&(s.S&&p(s,x),e.state=function(){return p(x,{})}),n?(r[i]=e,t):e})(v,y,"global"in c?c.global:this==r,c.state)}function d(e){var t,n=e.length,r=this,s=0,i=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);s<a;)o[s]=s++;for(s=0;s<a;s++)o[s]=o[i=c&i+e[s%n]+(t=o[s])],o[i]=t;(r.g=function(e){for(var t,n=0,s=r.i,i=r.j,o=r.S;e--;)t=o[s=c&s+1],n=n*a+o[c&(o[s]=o[i=c&i+t])+(o[i]=t)];return r.i=s,r.j=i,n})(a)}function p(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function f(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(f(e[n],t-1))}catch(a){}return r.length?r:"string"==s?e:e+"\0"}function g(e,t){for(var n,r=e+"",s=0;s<r.length;)t[c&s]=c&(n^=19*t[c&s])+r.charCodeAt(s++);return m(t)}function m(e){return String.fromCharCode.apply(0,e)}if(g(r.random(),n),e.exports){e.exports=h;try{s=Gd}catch(b){}}else r["seed"+i]=h}("undefined"!=typeof self?self:Kd,[],Math)),Vd.exports;var e}var Yd=function(){if(qd)return jd;qd=1;var e=(Ad||(Ad=1,function(e,t){function n(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function r(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var s=new n(e),a=t&&t.state,i=s.next;return i.int32=function(){return 4294967296*s.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.alea=s}(0,_d)),_d.exports),t=(Od||(Od=1,function(e,t){function n(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xor128=s}(0,Md)),Md.exports),n=(Dd||(Dd=1,function(e,t){function n(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function r(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xorwow=s}(0,Pd)),Pd.exports),r=(Fd||(Fd=1,function(e,t){function n(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function r(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&(a.x&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xorshift7=s}(0,Bd)),Bd.exports),s=(Ld||(Ld=1,function(e,t){function n(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function r(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&(a.X&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.xor4096=s}(0,Ud)),Ud.exports),a=(zd||(zd=1,function(e,t){function n(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function r(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var s=new n(e),a=t&&t.state,i=function(){return(s.next()>>>0)/4294967296};return i.double=function(){do{var e=((s.next()>>>11)+(s.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},i.int32=s.next,i.quick=i,a&&("object"==typeof a&&r(a,s),i.state=function(){return r(s,{})}),i}t&&t.exports?t.exports=s:this.tychei=s}(0,Wd)),Wd.exports),i=Xd();return i.alea=e,i.xor128=t,i.xorwow=n,i.xorshift7=r,i.xor4096=s,i.tychei=a,jd=i}();class Qd{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=Yd.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Jd{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Yd.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Zd=eu({randomNormal_:function(e,t=0,n=1,r,s){if(is(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new Qd(t,n,r,!1,s),i=Hu(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),ep=eu({randomUniform_:function(e,t=0,n=1,r="float32",s){is(e);const a=Hu(e,r),i=new Jd(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}});function tp(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return Gl.runKernel(Ii,{},s)}const np=eu({real_:function(e){const t={input:Jl(e,"input","real")};return Gl.runKernel(Ci,t)}}),rp=eu({reciprocal_:function(e){const t={x:Jl(e,"x","reciprocal")};return Gl.runKernel(Ti,t)}}),sp=eu({relu_:function(e){const t={x:Jl(e,"x","relu")};return Gl.runKernel(Ni,t)}}),ap=eu({relu6_:function(e){const t={x:Jl(e,"x","relu6")};return Gl.runKernel(Oi,t)}}),ip=eu({reverse_:function(e,t){const n={x:Jl(e,"x","reverse")},r={dims:t};return Gl.runKernel(Di,n,r)}}),op=eu({round_:function(e){const t={x:Jl(e,"x","round")};return Gl.runKernel(Fi,t)}}),lp=eu({rsqrt_:function(e){const t={x:Jl(e,"x","rsqrt","float32")};return Gl.runKernel(Li,t)}}),up=eu({selu_:function(e){const t={x:Jl(e,"x","selu")};return Gl.runKernel(Ui,t)}}),cp=eu({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=Jl(e,"x","separableConv2d"),l=Jl(t,"depthwiseFilter","separableConv2d"),u=Jl(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Cc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Or(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Or(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Or(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Or(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Or(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];Or(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=ih(c,l,r,s,i,a),g=qc(f,u,1,"valid",i);return h?Cc(g,[g.shape[1],g.shape[2],g.shape[3]]):g}}),hp=eu({sign_:function(e){const t={x:Jl(e,"x","sign")};return Gl.runKernel(Hi,t)}}),dp=eu({sin_:function(e){const t={x:Jl(e,"x","sin","float32")};return Gl.runKernel(Vi,t)}}),pp=eu({sinh_:function(e){const t={x:Jl(e,"x","sinh")};return Gl.runKernel(Gi,t)}}),fp=eu({slice1d_:function(e,t,n){const r=Jl(e,"x","slice1d");return Or(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Ac(r,[t],[n])}}),gp=eu({slice2d_:function(e,t,n){const r=Jl(e,"x","slice2d");return Or(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Ac(r,t,n)}}),mp=eu({slice3d_:function(e,t,n){const r=Jl(e,"x","slice3d");return Or(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Ac(r,t,n)}}),bp=eu({slice4d_:function(e,t,n){const r=Jl(e,"x","slice4d");return Or(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Ac(r,t,n)}}),yp=eu({softmax_:function(e,t=-1){const n=Jl(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return Gl.runKernel(Ji,r,s)}}),xp=eu({fft_:function(e){Or("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Gl.runKernel(ka,t)}}),vp=eu({ifft_:function(e){Or("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Gl.runKernel(Oa,t)}}),wp=eu({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Cc(e,[n,t]);r=vp(s)}else{const s=[n,2*(t-1)],a=Cc(np(e),[n,t]),i=Cc(jh(e),[n,t]),o=ip(Ac(a,[0,1],[n,t-2]),1),l=Qu(ip(Ac(i,[0,1],[n,t-2]),1),Rh(-1)),u=Ec([a,o],1),c=Ec([i,l],1),h=Cc(tu(u,c),[s[0],s[1]]);r=vp(h)}if(r=np(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Cc(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}}),kp=eu({split_:function(e,t,n=0){const r={x:Jl(e,"x","split")},s={numOrSizeSplits:t,axis:n};return Gl.runKernel(Qi,r,s)}}),Sp=eu({rfft_:function(e,t){Or("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=Ac(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=Ec([e,bd(r)],e.shape.length-1),n=t}else s=e;const a=ph(s),i=Cc(tu(s,a),[r,n]),o=xp(i),l=Math.floor(n/2)+1,u=np(o),c=jh(o),h=kp(u,[l,n-l],u.shape.length-1),d=kp(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,Cc(tu(h[0],d[0]),p)}}),Ip=eu({squaredDifference_:function(e,t){let n=Jl(e,"a","squaredDifference"),r=Jl(t,"b","squaredDifference");[n,r]=zl(n,r),ch(n.shape,r.shape);const s={a:n,b:r};return Gl.runKernel(so,s,{})}}),Cp=eu({squeeze_:function(e,t){const n=Jl(e,"x","squeeze","string_or_numeric");return Cc(n,Gr(n.shape,t).newShape)}}),Tp=eu({stack_:function(e,t=0){const n=Zl(e,"tensors","stack","string_or_numeric");Or(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Or(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return Gl.runKernel(mi,r,s)}}),Np=eu({step_:function(e,t=0){const n={x:Jl(e,"x","step")},r={alpha:t};return Gl.runKernel(So,n,r)}}),Ep=eu({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const u={x:Jl(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return Gl.runKernel(oo,u,c)}}),$p=eu({tan_:function(e){const t={x:Jl(e,"x","tan","float32")};return Gl.runKernel(po,t)}});function Rp(e,t){Fr(e);const n=Xl(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return nu(e,null,n,t)}function Ap(e,t,n){if(Fr(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Xl(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return nu(e,t,r,n)}function _p(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function Op(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let l=s;l<a;++l)i*=n[l];const o=s<1?1:s;return{sliceRank:s,numUpdates:Lr(t.shape)/o,sliceSize:i,strides:[...es(n.slice(0,s)),1],outputSize:Lr(n)}}const Dp=eu({topk_:function(e,t=1,n=!0){const r=Jl(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=Gl.runKernel(mo,a,i);return{values:o,indices:l}}}),Fp=eu({truncatedNormal_:function(e,t=0,n=1,r,s){if(is(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new Qd(t,n,r,!0,s),i=Hu(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}}),Lp=eu({unique_:function(e,t=0){const n=Jl(e,"x","unique","string_or_numeric");Or(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=Gl.runKernel(xo,r,s);return{values:a,indices:i}}}),zp=eu({unsortedSegmentSum_:function(e,t,n){const r=Jl(e,"x","unsortedSegmentSum"),s=Jl(t,"segmentIds","unsortedSegmentSum","int32");Or(Mr(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return Gl.runKernel(wo,a,i)}}),Mp=eu({unstack_:function(e,t=0){const n=Jl(e,"x","unstack","string_or_numeric");Or(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return Gl.runKernel(vo,r,s)}});function Pp(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=Hu(e,"int32"),s=Hu([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]),i=a*e.length;s.values.set(t,i)}return s.toTensor()}const Bp=eu({transpose_:function(e,t,n){const r=Jl(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Or(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Or(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?lu((()=>{let e=np(r),t=jh(r);return e=Gl.runKernel(yo,{x:e},a),t=Gl.runKernel(yo,{x:t},a),n&&(t=rd(t)),tu(e,t)})):Gl.runKernel(yo,s,a)}}),Up=eu({dropout_:function(e,t,n,r){const s=Jl(e,"x","dropout");if(Or("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),Or(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof xl?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(zr(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=Yu(Wh(Ku(ep(a,0,1,"float32",r),i)),i);return Qu(s,o)}}),Wp=eu({conv2DBackpropFilter_:function(e,t,n,r,s,a="NHWC",i){let o=e;3===e.rank&&(o=Cc(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Cc(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Or(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Or(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Or(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];Or(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Or(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Ic("conv2dDerFilter",s,i);const h={x:o,dy:l},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return Gl.runKernel(Ks,h,d)}});function Vp(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Qu(e,Np(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Gp(e,t){let n=t;const r=uh(e.shape,t.shape);return r.length>0&&(n=Oh(n,r)),Cc(n,e.shape)}function Hp(e,t,n,r){if("linear"===t)return e;if("relu"===t)return sp(e);if("elu"===t)return bh(e);if("relu6"===t)return ap(e);if("prelu"===t)return $d(e,n);if("leakyrelu"===t)return Yh(e,r);if("sigmoid"===t)return Rc(e);throw new Error(`Unknown fused activation ${t}.`)}const jp=(e,t)=>!(e>0)||"linear"===t,qp=eu({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===jp(Gl.state.gradientDepth,l)){Or("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let h=qc(e,t,n,r,s,a,i);return null!=o&&(h=Ku(h,o)),Hp(h,l,u,c)}const h=Jl(e,"x","conv2d","float32"),d=Jl(t,"filter","conv2d","float32");let p=h,f=!1;3===h.rank&&(f=!0,p=Cc(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Or(4===p.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`)),Or(4===d.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`)),Ic("fused conv2d",r,i);const g="NHWC"===s?p.shape[3]:p.shape[1];Or(d.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`)),Or(wc(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const m=pc(p.shape,d.shape,n,a,r,i);let b,y;if(null!=o&&(b=Jl(o,"bias","fused conv2d"),[b]=zl(b,h),"NHWC"===s?ch(m.outShape,b.shape):(Or(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),Or(0===b.shape.length||b.shape[0]===m.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${m.outChannels})`)))),null!=u){const e=u.shape;if(Or(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Or(1===e[0]||e[0]===m.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${m.outChannels}).`));else if(3===e.length)try{ch(e,m.outShape)}catch(k){const t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(t)}y=Jl(u,"prelu weights","fused conv2d")}const x=(e,t)=>{Or("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[i,o,u,c]=t,h=Vp(e,u,l);Or(vc(a),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const d=[Xc(o.shape,h,i,n,r),Wp(o,h,i.shape,n,r)];if(null!=c){const e=Gp(c,h);d.push(e)}return d},v={x:p,filter:d,bias:b,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};if(null==o){const e=nd(((e,t,n)=>{let r=Gl.runKernel(To,v,w);return n([t,e,r]),f&&(r=Cc(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(p,d)}{const e=nd(((e,t,n,r)=>{let s=Gl.runKernel(To,v,w);return r([t,e,s,n]),f&&(s=Cc(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}}));return e(p,d,b)}}}),Kp=eu({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,a=[1,1],i){let o=e;3===e.rank&&(o=Cc(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Cc(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return Gl.runKernel(oa,u,c)}}),Xp=eu({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=Cc(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},h=Gl.runKernel(la,u,c);return l?Cc(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Yp=eu({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(!1===jp(Gl.state.gradientDepth,a)){let l=$c(e,t,n,r);return null!=s&&(l=Ku(l,s)),Hp(l,a,i,o)}let l=Jl(e,"a","fused matMul"),u=Jl(t,"b","fused matMul");[l,u]=zl(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=Lr(f),b=Lr(g);Or(c===h,(()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));const y=ch(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),x=Cc(l,n?[m,c,d]:[m,d,c]),v=Cc(u,r?[b,p,h]:[b,h,p]);let w,k;null!=s&&(w=Jl(s,"bias","fused matMul"),[w]=zl(w,l),ch(y,w.shape)),null!=i&&(k=Jl(i,"prelu weights","fused matMul"));const S=(e,t)=>{const[i,o,l,u]=t,c=Vp(Cc(e,l.shape),l,a);let h,d;return n||r?!n&&r?(h=$c(c,o,!1,!1),d=$c(c,i,!0,!1)):n&&!r?(h=$c(o,c,!1,!0),d=$c(i,c,!1,!1)):(h=$c(o,c,!0,!0),d=$c(c,i,!0,!0)):(h=$c(c,o,!1,!0),d=$c(i,c,!0,!1)),null!=s?[h,d,Gp(u,c)]:[h,d]},I={a:x,b:v,bias:w,preluActivationWeights:k},C={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};if(null==s){const e=nd(((e,t,n)=>{const r=Gl.runKernel(Co,I,C);return n([e,t,r]),{value:Cc(r,y),gradFunc:S}}));return e(x,v)}{const e=nd(((e,t,n,r)=>{const s=Gl.runKernel(Co,I,C);return r([e,t,s,n]),{value:Cc(s,y),gradFunc:S}}));return e(x,v,w)}}}),Qp=eu({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=Jl(e,"image","cropAndResize"),o=Jl(t,"boxes","cropAndResize","float32"),l=Jl(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Or(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Or(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Or(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Or(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Or(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Or("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:i,boxes:o,boxInd:l},h={method:s,extrapolationValue:a,cropSize:r};return Gl.runKernel(ra,c,h)}}),Jp=eu({flipLeftRight_:function(e){const t=Jl(e,"image","flipLeftRight","float32");Or(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Gl.runKernel(Ia,n,{})}}),Zp=eu({grayscaleToRGB_:function(e){const t=Jl(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Or(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Or(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Bh(t,s)}}),ef=eu({rgbToGrayscale_:function(e){const t=Jl(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Or(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Or(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=ju(t,"float32"),i=Rp([.2989,.587,.114]);let o;switch(t.rank){case 2:o=mh("ij,j->i",a,i);break;case 3:o=mh("ijk,k->ij",a,i);break;case 4:o=mh("ijkl,l->ijk",a,i);break;case 5:o=mh("ijklm,m->ijkl",a,i);break;case 6:o=mh("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Mh(o,-1),ju(o,s)}}),tf=eu({rotateWithOffset_:function(e,t,n=0,r=.5){const s=Jl(e,"image","rotateWithOffset","float32");Or(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return Gl.runKernel(Io,a,i)}});function nf(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Or(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Or(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Or(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Or(1===t.rank,(()=>"scores must be a 1D tensor")),Or(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Or(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const rf=eu({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Jl(e,"boxes","nonMaxSuppression","float32"),i=Jl(t,"scores","nonMaxSuppression","float32"),o=nf(a,i,n,r,s),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return Gl.runKernel(hi,{boxes:a,scores:i},l)}});function sf(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||af)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function af(e,t){return e>t?1:e<t?-1:0}function of(e,t,n,r,s){return cf(e,t,n,r,s,0)}function lf(e,t,n,r,s,a){return cf(e,t,n,r,s,0,!1,a,!0)}function uf(e,t,n,r,s,a){return cf(e,t,n,r,s,a,!0)}function cf(e,t,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let m=0;m<t.length;m++)t[m]>s&&u.push({score:t[m],boxIndex:m,suppressBeginIndex:0});u.sort(pf);const c=a>0?-.5/a:0,h=[],d=[];for(;h.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let l=h.length-1;l>=i;--l){const n=hf(e,a,h[l]);if(n>=r){o=!0;break}if(t.score=t.score*df(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(a),d.push(t.score)):t.score>s&&sf(u,t,pf))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return i&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function hf(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const g=Math.max(a,u),m=Math.max(i,c),b=Math.min(o,h),y=Math.min(l,d),x=Math.max(b-g,0)*Math.max(y-m,0);return x/(p+f-x)}function df(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function pf(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const ff=eu({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Jl(e,"boxes","nonMaxSuppression"),o=Jl(t,"scores","nonMaxSuppression"),l=nf(i,o,n,r,s,a),u={boxes:i,scores:o},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:a=l.softNmsSigma},h=Gl.runKernel(pi,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}}),gf=eu({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Jl(e,"boxes","nonMaxSuppression"),o=Jl(t,"scores","nonMaxSuppression"),l=nf(i,o,n,r,s,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a},h=Gl.runKernel(di,u,c);return{selectedIndices:h[0],validOutputs:h[1]}}}),mf=eu({resizeBilinear_:function(e,t,n=!1,r=!1){const s=Jl(e,"images","resizeBilinear");Or(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),Or(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Or(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Cc(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=Gl.runKernel(Ai,o,l);return i?Cc(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),bf=eu({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=Jl(e,"images","resizeNearestNeighbor");Or(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),Or(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Or("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Or(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Cc(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=Gl.runKernel($i,o,l);return i?Cc(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});function yf(e,t=!1){return Gl.tidy((()=>{Or(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=Uh(n),a=qu(e);const i=Ap([[1]],[1,1]);let o=qu(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=a,l=o,u=s;[o,a,s]=Gl.tidy((()=>{const t=Ac(a,[e,e],[n-e,1]),l=Fh(t),u=Ac(a,[e,e],[1,1]),c=dh(Gh(u,0),Ap([[-1]]),Ap([[1]])),h=id(u,Qu(c,l)),d=Yu(t,h);o=1===d.shape[0]?qu(i):Ec([i,Ac(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=rd(Yu($c(c,h),l)),f=Ac(a,[e,0],[n-e,r]),g=Qu(p,o),m=Bp(o);if(0===e)a=id(f,$c(g,$c(m,f)));else{const t=id(f,$c(g,$c(m,f)));a=Ec([Ac(a,[0,0],[e,r]),t],0)}const b=Bp(g),y=Ac(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=id(y,$c($c(y,o),b));else{const t=id(y,$c($c(y,o),b));s=Ec([Ac(s,[0,0],[n,e]),t],1)}return[o,a,s]})),uu([t,l,u])}return!t&&n>r&&(s=Ac(s,[0,0],[n,r]),a=Ac(a,[0,0],[r,r])),[s,a]}))}const xf={flipLeftRight:Jp,grayscaleToRGB:Zp,resizeNearestNeighbor:bf,resizeBilinear:mf,rgbToGrayscale:ef,rotateWithOffset:tf,cropAndResize:Qp,nonMaxSuppression:rf,nonMaxSuppressionAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Jl(e,"boxes","nonMaxSuppressionAsync"),i=Jl(t,"scores","nonMaxSuppressionAsync"),o=nf(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:h}=of(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Rp(h,"int32")},nonMaxSuppressionWithScore:ff,nonMaxSuppressionWithScoreAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Jl(e,"boxes","nonMaxSuppressionAsync"),o=Jl(t,"scores","nonMaxSuppressionAsync"),l=nf(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=uf(c,h,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Rp(d,"int32"),selectedScores:Rp(p)}},nonMaxSuppressionPadded:gf,nonMaxSuppressionPaddedAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Jl(e,"boxes","nonMaxSuppressionAsync"),o=Jl(t,"scores","nonMaxSuppressionAsync"),l=nf(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:g}=lf(d,p,u,c,h,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Rp(f,"int32"),validOutputs:Rh(g,"int32")}},threshold:eu({threshold_:function(e,t="binary",n=!1,r=.5){const s=Jl(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,l,u,c=Qu(Rp([r]),255);if(Or(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),Or(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),Or("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),Or("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,o,l]=kp(s,[1,1,1],-1);const e=Qu(i,.2989),t=Qu(o,.587),n=Qu(l,.114);u=Ku(Ku(e,t),n)}else u=e;"otsu"===t&&(c=function(e,t){let n,r,s,a,i,o,l=Rp([-1]),u=Rp([0]),c=Rp([0]);for(let h=0;h<e.size-1;h++){n=Ac(e,0,h+1),r=Ac(e,h+1),i=Yu(Oh(n),t),o=Yu(Oh(r),t);const d=Oh(Qu(n,tp(0,n.size)));s=Yu(d,Oh(n));const p=Uc(r.shape,n.size),f=Ku(tp(0,r.size),p),g=Qu(r,f);a=Yu(Oh(g),Oh(r));const m=id(s,a),b=id(s,a),y=Qu(i,o);c=Qu(Qu(y,m),b);const x=Gh(c,u);u=dh(x,c,u),l=dh(x,Rp([h]),l)}return l}(Mc(ju(op(u),"int32"),ru([]),256),a));const h=n?Jh(u,c):Gh(u,c);return ju(Qu(h,255),"int32")}}),transform:eu({transform_:function(e,t,n="nearest",r="constant",s=0,a){const i=Jl(e,"image","transform","float32"),o=Jl(t,"transforms","transform","float32");Or(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Or(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Or(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return Gl.runKernel(bo,l,u)}})},vf={bandPart:eu({bandPart_:function(e,t,n){const r=Jl(e,"a","bandPart");Or(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;"number"==typeof t?(Or(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Or(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=Jl(t<0?a:t,"numLower","bandPart")):(Or("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=dh(Qh(t,0),a,xd(t,a))),"number"==typeof n?(Or(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Or(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=Jl(n<0?i:n,"numUpper","bandPart")):(Or("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=dh(Qh(n,0),i,xd(n,i)));const u=Cc(tp(0,a,1,"int32"),[-1,1]),c=tp(0,i,1,"int32"),h=id(u,c),d=ud(Jh(h,o),Hh(h,rd(l))),p=bd([a,i],r.dtype);return Cc(Tp(Mp(Cc(r,[-1,a,i])).map((e=>dh(d,e,p)))),s)}}),gramSchmidt:eu({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Or(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Or(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=kp(e,e.shape[0],0).map((e=>Cp(e,[0])));Or(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let s=0;s<e.length;++s)n.push(Gl.tidy((()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=Qu(Oh(Qu(n[t],e)),n[t]);e=id(e,r)}return Yu(e,Fh(e,"euclidean"))})));return t?Tp(n,0):n}}),qr:eu({qr_:function(e,t=!1){if(Or(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return yf(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Mp(Cc(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];return r.forEach((e=>{const[n,r]=yf(e,t);s.push(n),a.push(r)})),[Cc(Tp(s,0),e.shape),Cc(Tp(a,0),e.shape)]}}})},wf=new Map,kf=new Map;class Sf{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class If{constructor(){this.classNameMap={}}static getMap(){return null==If.instance&&(If.instance=new If),If.instance}static register(e){If.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Cf(e,t,n){Or(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Or("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Or(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const r=t+">"+n;return If.register(e),wf.set(r,e),kf.set(e,r),e}class Tf extends Sf{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return uu(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){Or(Jr(e),(()=>"The f passed in variableGrads(f) must be a function")),Or(null==t||Array.isArray(t)&&t.every((e=>e instanceof wl)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Gl.registeredVariables)t.push(Gl.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;Or((t=t.filter((e=>e.trainable))).length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=Gl.gradients(e,t,null,!0);Or(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Or(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&uu(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Rh(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Tf,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Nf extends Tf{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Gl.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Gl.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:lu((()=>ph(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:lu((()=>ph(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;lu((()=>{const e=Ku(Qu(i,this.rho),Qu(_h(a),1-this.rho)),t=Qu(Yu(Ah(Ku(o,this.epsilon)),Ah(Ku(i,this.epsilon))),a),n=Ku(Qu(o,this.rho),Qu(_h(t),1-this.rho));i.assign(e),o.assign(n);const s=Ku(Qu(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(uu(this.accumulatedGrads.map((e=>e.variable))),uu(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}class Ef extends Tf{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Gl.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:lu((()=>Uc(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;lu((()=>{const e=Ku(a,_h(s));a.assign(e);const t=Ku(Qu(Yu(s,Ah(Ku(e,Gl.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&uu(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}class $f extends Tf{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],lu((()=>{this.accBeta1=Rh(t).variable(),this.accBeta2=Rh(n).variable()})),null==r&&(this.epsilon=Gl.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);lu((()=>{const n=id(1,this.accBeta1),r=id(1,this.accBeta2);t.forEach(((t,s)=>{const a=Gl.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:lu((()=>ph(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:lu((()=>ph(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=Ku(Qu(l,this.beta1),Qu(o,1-this.beta1)),h=Ku(Qu(u,this.beta2),Qu(_h(o),1-this.beta2)),d=Yu(c,n),p=Yu(h,r);l.assign(c),u.assign(h);const f=Ku(Qu(Yu(d,Ku(Ah(p),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(Qu(this.accBeta1,this.beta1)),this.accBeta2.assign(Qu(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&uu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&uu(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),lu((()=>{this.accBeta1.assign($h(this.beta1,this.iterations_+1)),this.accBeta2.assign($h(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}class Rf extends Tf{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],lu((()=>{this.iteration=Rh(0).variable(),this.accBeta1=Rh(t).variable()})),null==r&&(this.epsilon=Gl.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);lu((()=>{const n=id(1,this.accBeta1),r=Yu(-this.learningRate,Ku(Qu(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=Gl.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:ph(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:ph(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=Ku(Qu(l,this.beta1),Qu(o,1-this.beta1)),h=Qu(u,this.beta2),d=Ju(o),p=gd(h,d);l.assign(c),u.assign(p);const f=Ku(Qu(Yu(r,n),Yu(c,Ku(p,this.epsilon))),a);a.assign(f)})),this.iteration.assign(Ku(this.iteration,1)),this.accBeta1.assign(Qu(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&uu(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&uu(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Af extends Tf{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=Gl.registeredVariables[t];lu((()=>{const e=Ku(Qu(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=cu(Rh(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class _f extends Af{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Rh(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Gl.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:lu((()=>ph(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&lu((()=>{let e;const t=Ku(Qu(this.m,s),a);e=this.useNesterov?Ku(Qu(this.c,Ku(a,Qu(t,this.m))),r):Ku(Qu(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&uu(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Of extends Tf{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=Gl.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Gl.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:lu((()=>ph(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:lu((()=>ph(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:lu((()=>ph(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;lu((()=>{const e=Ku(Qu(i,this.decay),Qu(_h(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=Ku(Qu(t,this.decay),Qu(a,1-this.decay)),l=Yu(Qu(a,this.learningRate),Ah(id(e,Ku(_h(s),this.epsilon)))),u=Ku(Qu(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=id(r,u);r.assign(c)}else{const e=Ku(Qu(i,this.decay),Qu(_h(a),1-this.decay)),t=Ku(Qu(o,this.momentum),Yu(Qu(a,this.learningRate),Ah(Ku(e,this.epsilon))));i.assign(e),o.assign(t);const n=id(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&uu(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&uu(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&uu(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Df=[Nf,Ef,$f,Rf,_f,Of,Af];function Ff(e,t,n,r){var s,a,i;Or(null!=(s=e)&&Array.isArray(s)&&s.length>0,(()=>"promises must be a none empty array")),i=r=null==r?1:r,Or((a=n=null==n?0:n)>=0&&a<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${a}`)),Or(i>=0&&i<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${i}`)),Or(i>=a,(()=>`startFraction must be no more than endFraction, but got startFraction ${a} and endFraction ${i}`));let o=0;return Promise.all(e.map((s=>(s.then((s=>{const a=n+ ++o/e.length*(r-n);return t(a),s})),s))))}class Lf{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Or("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=ps().platform.fetch,Or(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Or(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=function(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=au.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:yu(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){return this.loadOptions.streamWeights?this.loadStream():async function(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),function(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}(e,n,r)}(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=xu(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?ps().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e),n=xu(e),r=await async function(e,t){null==t&&(t={});const n=null==t.fetchFunc?ps().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Ff(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Ff(s,t.onProgress,.5,1)}(t,this.loadOptions);return[n,r]}}function zf(e){return null!=e.match(Lf.URL_SCHEME_REGEX)}Lf.URL_SCHEME_REGEX=/^https?:\/\//;const Mf=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>zf(e))):zf(e),n)return Pf(e,t)}return null};function Pf(e,t){return new Lf(e,t)}function Bf(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Lr(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const o=e.shape,l=s.slice();l.pop();let u=1;for(let h=a;h<n;++h)u*=o[h],l.push(o[h]);const c=[...es(e.shape).map((e=>e/u)),1].slice(0,a);return[l,i,u,c]}function Uf(e,t,n){const r=e.shape.length;Or(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Or(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)Or(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function Wf(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Vf(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)0===a?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Gf(e,t,n){return n<=e?n:n-(t-1)}function Hf(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function jf(e,t,n,r,s){const a=[...s],i=Hf(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const s=Gf(t,n,o);let i=r[s];e&1<<s&&(i=0),a[o]=i}return a}function qf(e,t,n,r,s){const a=[...s],i=Hf(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const s=Gf(t,n,o);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),a[o]=i}for(let o=0;o<a.length;o++){const e=s[o];a[o]<0&&(a[o]+=e),a[o]=Rr(0,a[o],s[o])}return a}function Kf(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Xf(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Rr(0,i,l-1),i}function Yf(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=o>0?Rr(0,i,l):Rr(-1,i,l-1),i}function Qf(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Jf(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Zf(e,t,n){let r;const s=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{Or(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Or(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function eg(e,t,n,r,s,a,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let y=0;y<h.dims;y++)c&&1<<y&o&&h.numAddAxisAfterEllipsis++,1<<y&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(h,d);let p=!0,f=!0,g=!0;const m=[],b=[];for(let y=0;y<e.length;++y){if(0===d.strides[y])throw Error(`strides[${y}] must be non-zero`);const t=!!(d.shrinkAxisMask&1<<y),n=e[y];if(-1===n){m.push(t?1:-1);continue}const r=[d.beginMask&1<<y,d.endMask&1<<y],s=[d.strides[y]>0?0:-1,d.strides[y]>0?n:n-1];if(t&&d.strides[y]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===d.strides[y];const a=!!(d.beginMask&1<<y&&d.endMask&1<<y);if(d.beginValid&&d.endValid){if(t){const e=d.begin[y]<0?n+d.begin[y]:d.begin[y];if(d.begin[y]=e,d.end[y]=d.begin[y]+1,e<0||e>=n)throw Error(`slice index ${d.begin[y]} of dimension ${y} out of bounds.`)}else d.begin[y]=tg(d.begin[y],0,d.strides[y],n,r,s),d.end[y]=tg(d.end[y],1,d.strides[y],n,r,s);const e=1===d.strides[y]&&0===d.begin[y]&&d.end[y]===n;p=p&&e,f=f&&(0===y&&1===d.strides[y]||e)}else p=p&&1===d.strides[y]&&a,f=f&&(0===y&&1===d.strides[y]||a);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[y]-d.begin[y],o=!0):t?(i=1,o=!0):a&&n>=0&&(i=d.strides[y]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=d.strides[y]<0?0:Math.trunc(i/d.strides[y])+(i%d.strides[y]!=0?1:0),m.push(e)}else m.push(-1)}for(let y=0;y<d.finalShapeGatherIndices.length;++y){const e=d.finalShapeGatherIndices[y];e>=0?b.push(m[e]):-2===e&&b.push(1)}return{finalShapeSparse:b.filter(((e,t)=>-2!==d.finalShapeGatherIndices[t])),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function tg(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}vu.registerSaveRouter(Mf),vu.registerLoadRouter(Mf);const ng=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Uf,computeFlatOffset:Jf,computeOutShape:Wf,getNormalizedAxes:function(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=jf(i,l,u,r,e),h=qf(o,l,u,s,e),d=Vf(a,l,u,e)}else for(let p=0;p<u;p++)c[p]=Xf(i,r,a,e,p,l),h[p]=Yf(o,s,a,e,p,l),d[p]=Kf(a,p,l);return{begin:c,end:h,strides:d}},isSliceContinous:Qf,maskToAxes:function(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t},parseSliceParams:Zf,sliceInfo:eg,startForAxis:Xf,startIndicesWithElidedDims:jf,stopForAxis:Yf,stopIndicesWithElidedDims:qf,stridesForAxis:Kf,stridesWithElidedDims:Vf},Symbol.toStringTag,{value:"Module"})),rg=class{static sgd(e){return new Af(e)}static momentum(e,t,n=!1){return new _f(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Of(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new $f(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Nf(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Rf(e,t,n,r,s)}static adagrad(e,t=.1){return new Ef(e,t)}},sg="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function ag(){return new Promise((e=>sg((()=>e()))))}function ig(e,t){const n=e[0].length;e.forEach(((e,t)=>{Or(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Or(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)Or(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function og(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var lg,ug;function cg(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function hg(e){const t={FIRST_DIM_SIZE:lg.FIRST_DIM_SIZE,VALUE_ROWIDS:lg.VALUE_ROWIDS,ROW_LENGTHS:lg.ROW_LENGTHS,ROW_SPLITS:lg.ROW_SPLITS,ROW_LIMITS:lg.ROW_LIMITS,ROW_STARTS:lg.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function dg(e){return 0===e.length?0:e[0]===lg.FIRST_DIM_SIZE?e.length-1:e.length}function pg(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}function fg(e){return e<=30?e:Zr(e,Math.floor(Math.sqrt(e)))}function gg(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function mg(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function bg(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function yg(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function xg(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function vg(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}(ug=lg||(lg={}))[ug.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",ug[ug.VALUE_ROWIDS=1]="VALUE_ROWIDS",ug[ug.ROW_LENGTHS=2]="ROW_LENGTHS",ug[ug.ROW_SPLITS=3]="ROW_SPLITS",ug[ug.ROW_LIMITS=4]="ROW_LIMITS",ug[ug.ROW_STARTS=5]="ROW_STARTS";const wg=1.7580993408473768,kg=1.0507009873554805,Sg=.3275911,Ig=.254829592,Cg=-.284496736,Tg=1.421413741,Ng=-1.453152027,Eg=1.061405429;function $g(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Rg(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Ag(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function _g(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Og(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Dg(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Fg(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function Lg(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const zg=/->/g;function Mg(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(zg,"").length)/2;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=e.split("->");Or(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const a=r.split(","),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const e=s[h];if(!a.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===o.indexOf(e)&&","!==e&&o.push(e)}const l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let e=0;e<a[h].length;++e)l[h].push(o.indexOf(a[h][e]))}const u=o.length,c=[];for(let h=s.length;h<u;++h)c.push(h);return{allDims:o,summedDims:c,idDims:l}}function Pg(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Bg(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:Or(r[t[s][n]]===e[n],(()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Ug(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const e=Vg(t,n[i]);for(const t of e)-1===a.indexOf(t)&&(r[i].push(t),a.push(t))}return{path:n,steps:r}}function Wg(e){return e.every(((e,t)=>e===t))}function Vg(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function Gg(e,t,n=0){let r=[];if("number"==typeof t)Or(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{Or(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}Or(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function Hg(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function jg(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function qg(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Kg(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Xg(e,t){return`size ${e} must be non-negative, not ${t}`}function Yg(e,t){return`Input to reshape is a SparseTensor with ${Lr(e)}\n  dense values, but the requested shape requires a multiple of ${Lr(t)}. inputShape=${e} outputShape= ${t}`}function Qg(e,t){return`Input to reshape is a tensor with ${Lr(e)} dense values, but the requested shape has ${Lr(t)}. inputShape=${e} outputShape=${t}`}function Jg(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Zg(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function em(e,t){let n,r=!1;for(e<=30?(n=e,r=!0):n=Zr(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Zr(e,n+1);return n}function tm(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function nm(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<r;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<s;h++)o.push(t.shape[h]);for(let h=n+1;h<a;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}const rm=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:nm,computeOutShape:tm,segOpComputeOptimalWindowSize:em},Symbol.toStringTag,{value:"Module"}));function sm(e){try{return e.map((e=>al(e)))}catch(DP){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${DP}`)}}function am(e){return e.map((e=>sl(e)))}const im=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Ig,ERF_A2:Cg,ERF_A3:Tg,ERF_A4:Ng,ERF_A5:Eg,ERF_P:Sg,PARALLELIZE_THRESHOLD:30,get RowPartitionType(){return lg},SELU_SCALE:kg,SELU_SCALEALPHA:wg,applyActivation:Hp,assertAndGetBroadcastShape:ch,assertAxesAreInnerMostDims:Sh,assertParamsConsistent:ig,assignToTypedArray:Dg,axesAreInnerMostDims:xh,calculateShapes:Op,checkEinsumDimSizes:Bg,checkPadOnDimRoundingMode:Ic,combineLocations:vh,combineRaggedTensorToTensorShapes:cg,complexWithEvenIndex:Ag,complexWithOddIndex:_g,computeConv2DInfo:pc,computeConv3DInfo:fc,computeDefaultPad:gc,computeDilation2DInfo:cc,computeOptimalWindowSize:fg,computeOutAndReduceShapes:wh,computeOutShape:og,computePool2DInfo:hc,computePool3DInfo:dc,convertConv2DDataFormat:Sc,decodeEinsumEquation:Mg,eitherStridesOrDilationsAreOne:wc,expandShapeToKeepDim:kh,exponent:Lg,exponents:Fg,fromStringArrayToUint8:am,fromUint8ToStringArray:sm,getAxesPermutation:Ih,getBroadcastDims:lh,getComplexWithIndex:Og,getEinsumComputePath:Ug,getEinsumPermutation:Pg,getFusedBiasGradient:Gp,getFusedDyActivation:Vp,getImageCenter:gg,getInnerMostAxes:Th,getPermuted:bg,getRaggedRank:dg,getReductionAxes:uh,getReshaped:mg,getReshapedPermuted:yg,getRowPartitionTypesHelper:hg,getSliceBeginCoords:xg,getSliceSize:vg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Hg,getSparseFillEmptyRowsNegativeIndexErrorMessage:jg,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:qg,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:function(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"},getSparseReshapeInputOutputMismatchErrorMessage:Qg,getSparseReshapeInputOutputMultipleErrorMessage:Yg,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Kg,getSparseReshapeNegativeOutputDimErrorMessage:Xg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Zg,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:function(){return"segment ids must be >= 0"},getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:function(){return"segment ids are not increasing"},getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Jg,getUndoAxesPermutation:Ch,isIdentityPermutation:Wg,log:function(...e){ps().getBool("IS_TEST")||ps().getBool("PROD")||console.log(...e)},mergeRealAndImagArrays:$g,prepareAndValidate:Bf,prepareSplitSize:Gg,segment_util:rm,shouldFuse:jp,slice_util:ng,splitRealAndImagArrays:Rg,stridesOrDilationsArePositive:kc,tupleValuesAreOne:vc,upcastType:Ol,validateDefaultValueShape:pg,validateInput:function(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}_p(n,t,e)},validateUpdateShape:_p,warn:Eo},Symbol.toStringTag,{value:"Module"}));!function(){for(const e of Df)Cf(e)}();const om={kernelName:ys,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(e,Np(ju(n,"float32"),-1))}}},lm={kernelName:xs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=_h(ju(n,"float32")),r=Ah(id(Rh(1),t));return rd(Yu(e,r))}}}},um={kernelName:vs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Ah(id(_h(ju(n,"float32")),1));return Yu(e,t)}}}},cm={kernelName:ws,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ch(n.shape,r.shape);return{a:()=>{let t=e;const r=uh(n.shape,s);return r.length>0&&(t=Oh(t,r)),Cc(t,n.shape)},b:()=>{let t=e;const n=uh(r.shape,s);return n.length>0&&(t=Oh(t,n)),Cc(t,r.shape)}}}},hm={kernelName:ks,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},dm={kernelName:Cs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ph(n)}}},pm={kernelName:Ts,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ph(n)}}},fm={kernelName:Ns,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,Ah(id(Rh(1),_h(ju(n,"float32")))))}}},gm={kernelName:Es,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Ah(Ku(Rh(1),_h(ju(n,"float32"))));return Yu(e,t)}}}},mm={kernelName:As,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ch(n.shape,r.shape);return{a:()=>{const t=Ku(_h(n),_h(r));let a=Qu(e,Yu(r,t));const i=uh(n.shape,s);return i.length>0&&(a=Oh(a,i)),Cc(a,n.shape)},b:()=>{const t=Ku(_h(n),_h(r));let a=rd(Qu(e,Yu(n,t)));const i=uh(r.shape,s);return i.length>0&&(a=Oh(a,i)),Cc(a,r.shape)}}}},bm={kernelName:$s,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,Ku(_h(ju(n,"float32")),1))}}},ym={kernelName:Rs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,id(Rh(1),_h(ju(n,"float32"))))}}},xm=eu({avgPool3dGrad_:function(e,t,n,r,s,a){const i=Jl(e,"dy","avgPool3dGrad"),o=Jl(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=Cc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Cc(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Or(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Or(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Ic("avgPool3dGrad",s,a);const h={dy:l,input:u},d={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=Gl.runKernel(Fs,h,d);return c?Cc(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),vm={kernelName:Ds,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>xm(e,r,s,a,i,o)}}},wm=eu({avgPoolGrad_:function(e,t,n,r,s){const a=Jl(e,"dy","avgPoolGrad"),i=Jl(t,"input","avgPoolGrad");Or(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=Cc(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Cc(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Or(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Or(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},h={filterSize:n,strides:r,pad:s},d=Gl.runKernel(Os,c,h);return u?Cc(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),km={kernelName:_s,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>wm(e,r,s,a,i)}}},Sm={kernelName:Ls,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>$c(e,s,!1,!1),b:()=>$c(e,r,!0,!1)}:a&&!i?{a:()=>$c(s,e,!1,!0),b:()=>$c(r,e,!1,!1)}:{a:()=>$c(s,e,!0,!0),b:()=>$c(e,r,!0,!0)}:{a:()=>$c(e,s,!1,!0),b:()=>$c(r,e,!0,!1)}}},Im={kernelName:zs,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>Nd(e,r,s)}}},Cm={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>Oh(e,o,!0)}}},Tm={kernelName:Us,gradFunc:e=>({x:()=>e.clone()})},Nm={kernelName:Ws,gradFunc:e=>({x:()=>ph(e)})},Em={kernelName:Vs,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>dh(ud(Hh(r,s),Jh(r,a)),e,ph(e))}}},$m={kernelName:Hs,inputsToSave:["x"],gradFunc:om.gradFunc},Rm={kernelName:js,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=Vr(s,t[0].shape)[0],i=r.map((e=>e[a]));return kp(e,i,a).map((e=>()=>e))}},Am={kernelName:qs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Or(vc(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>Xc(r.shape,e,s,i,o,l),filter:()=>Wp(r,e,s.shape,i,o,l)}}},_m={kernelName:Xs,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>qc(e,s,a,i,o,1,l),filter:()=>Wp(e,r,s.shape,a,i,o,l)}}},Om=eu({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=Cc(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Cc(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Or(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),Or(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Or(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Or(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),Or(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return Gl.runKernel(Qs,o,l)}}),Dm={kernelName:Ys,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Or(vc(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>Jc(i.shape,e,o,s,a),filter:()=>Om(i,e,o.shape,s,a)}}},Fm={kernelName:Zs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(rd(dp(ju(n,"float32"))),e)}}},Lm={kernelName:ea,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(pp(ju(n,"float32")),e)}}},zm={kernelName:na,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=Ih([s],r.rank);let n=rh(e,s,a,!i);return null!=t&&(n=Bp(n,t)),n}}}},Mm={kernelName:ia,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Or(vc(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return Or(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Or(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Or(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Or(wc(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),Ic("depthwiseConv2d",a,i),{x:()=>Xp(l.shape,e,u,s,a,o,i),filter:()=>Kp(l,e,u.shape,s,a,o,i)}}},Pm={kernelName:ca,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>Gl.runKernel(ha,a,n),filter:()=>Gl.runKernel(da,i,n)}}},Bm={kernelName:ga,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>Gl.runKernel(ma,r)}}},Um={kernelName:ba,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Qu(zh(rd(_h(n))),2/Math.sqrt(Math.PI));return{x:()=>Qu(e,r)}}},Wm={kernelName:xa,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(e,n)}}},Vm={kernelName:va,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Cc(e,n.shape)}}},Gm={kernelName:wa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(e,zh(n))}}},Hm={kernelName:Ca,gradFunc:e=>({x:()=>ph(e)})},jm={kernelName:Ta,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ch(n.shape,r.shape);return{a:()=>{const t=Yu(e,ju(r,"float32")),a=uh(n.shape,s);return a.length>0?Cc(Oh(t,a),n.shape):t},b:()=>{let t=Qu(e,ju(n,"float32"));const a=uh(r.shape,s);a.length>0&&(t=Cc(Oh(t,a),r.shape));const i=_h(r);return rd(Yu(t,ju(i,"float32")))}}}},qm={kernelName:Na,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?Rh(1):o,u=uh(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const h=id(s,a),d=Qu(e,l),p=lp(Ku(i,Rh(r))),f=Qu(Qu(Qu(p,p),p),Rh(-.5));return{x:()=>1===a.rank?Cc(Qu(Qu(e,Bh(Cc(p,[1,1,1,a.shape[0]]),c)),l),s.shape):Cc(Qu(Qu(e,p),l),s.shape),mean:()=>{let e=Qu(Qu(p,Rh(-1)),d);return 1===a.rank&&(e=Oh(e,u)),Cc(e,a.shape)},variance:()=>{let e=Qu(Qu(f,h),d);return 1===a.rank&&(e=Oh(e,u)),Cc(e,a.shape)},scale:()=>{const t=Qu(h,p);let n=Qu(e,t);return 1===a.rank&&(n=Oh(n,u)),Cc(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=Oh(t,u)),Cc(t,a.shape)}}}},Km={kernelName:Ea,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=Vr(a,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),l=i.length,u=r.slice(a,r.length).slice(1),c=u.length,h=Xm(0,l),d=Xm(l+1,l+1+c),p=Ym([i,[s],u]),f=Cc(n,p),g=Cc(t,[s]),m=Ym([[l],h,d]),b=Bp(f,m);let y=zp(b,g,e.shape[o]);const x=Ch(m);return y=Bp(y,x),y};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>Tp(n.map(((t,n)=>l(t,s.slice(n,1),e.slice(n,1))()))).reshape(r.shape),indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function Xm(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function Ym(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const Qm={kernelName:Aa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ph(n),b:()=>ph(r)}}},Jm={kernelName:_a,gradFunc:e=>({x:()=>ju(e,"float32")})},Zm={kernelName:Fa,gradFunc:e=>({x:()=>ph(e)})},eb={kernelName:La,gradFunc:e=>({x:()=>ph(e)})},tb={kernelName:za,gradFunc:e=>({x:()=>ph(e)})},nb={kernelName:Ma,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=Gh(r,0);return{x:()=>dh(a,e,Qu(e,s))}}},rb={kernelName:Va,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,Ku(n,1))}}},sb={kernelName:Wa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,ju(n,"float32"))}}},ab={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=zh(r);return id(e,Qu(Oh(e,s,!0),t))}}}},ib=eu({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return Gl.runKernel(Ka,o,l)}}),ob={kernelName:qa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>ib(r,s,e,a,i,o,l)}}};function lb(e,t,n,r){return t.rank<n.rank&&(t=Cc(t,kh(t.shape,r))),e.rank<n.rank&&(e=Cc(e,kh(e.shape,r))),{x:()=>Qu(e,ju(hh(n,t),e.dtype))}}const ub={kernelName:Xa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=lb(e,t[1],a,Vr(s,a.shape));return{x:()=>i.x()}}},cb={kernelName:Ya,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Qu(e,ju(Hh(n,r),"float32")),b:()=>Qu(e,ju(Qh(n,r),"float32"))}}},hb=eu({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=Jl(e,"dy","maxPool3dGrad"),l=Jl(t,"input","maxPool3dGrad"),u=Jl(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=Cc(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Cc(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Cc(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Or(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Or(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),Or(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),Ic("maxPool3dGrad",a,i);const f={dy:c,input:h,output:d},g={filterSize:r,strides:s,pad:a,dimRoundingMode:i},m=Gl.runKernel(ei,f,g);return p?Cc(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),db={kernelName:Za,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>hb(e,r,s,a,i,o,l)}}},pb=eu({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=Jl(e,"dy","maxPoolGrad"),l=Jl(t,"input","maxPoolGrad"),u=Jl(n,"output","maxPoolGrad");Or(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Or(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Or(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Ic("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},h={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return Gl.runKernel(Ja,c,h)}}),fb={kernelName:ii,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ch(n.shape,r.shape);return{a:()=>{const t=uh(n.shape,s);return t.length>0?Cc(Oh(e,t),n.shape):e},b:()=>{const t=Qu(e,rd(Wh(Yu(n,r)))),a=uh(r.shape,s);return a.length>0?Cc(Oh(t,a),r.shape):t}}}},gb={kernelName:li,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ch(n.shape,r.shape);return{a:()=>{const t=Qu(e,ju(r,"float32")),a=uh(n.shape,s);return a.length>0?Cc(Oh(t,a),n.shape):t},b:()=>{const t=Qu(e,ju(n,"float32")),a=uh(r.shape,s);return a.length>0?Cc(Oh(t,a),r.shape):t}}}},mb={kernelName:bi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Ac(e,a,r.shape)}}},bb={kernelName:yi,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=ch(a.shape,i.shape);return{a:()=>{const t=ju(i,"float32");let n=Qu(e,Qu(t,$h(a,id(t,Rh(1)))));const r=uh(a.shape,o);return r.length>0&&(n=Oh(n,r)),Cc(n,a.shape)},b:()=>{const t=Gh(a,0),n=dh(t,ed(a),ph(a));let r=Qu(e,Qu(s,n));const l=uh(i.shape,o);return l.length>0&&(r=Oh(r,l)),Cc(r,i.shape)}}}},yb={kernelName:xi,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=Gh(n,0);return{x:()=>dh(s,e,Qu(e,r)),alpha:()=>{let t=dh(s,ph(e),Qu(e,n));const a=uh(r.shape,e.shape);return a.length>0&&(t=Oh(t,a)),Cc(t,r.shape)}}}};const xb={kernelName:pa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ch(n.shape,r.shape);return{a:()=>{const t=Yu(e,ju(r,"float32")),a=uh(n.shape,s);return a.length>0?Cc(Oh(t,a),n.shape):t},b:()=>{let t=Qu(e,ju(n,"float32"));const a=uh(r.shape,s);a.length>0&&(t=Cc(Oh(t,a),r.shape));const i=_h(r);return rd(Yu(t,ju(i,"float32")))}}}},vb={kernelName:Yi,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>Oc(e,r,s)}}},wb={kernelName:Qi,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Ec(e,r)}}},kb={kernelName:ho,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=ch(n.shape,r.shape);return{a:()=>{let t=e;const r=uh(n.shape,s);return r.length>0&&(t=Oh(t,r)),Cc(t,n.shape)},b:()=>{let t=e;const n=uh(r.shape,s);return n.length>0&&(t=Oh(t,n)),Cc(rd(t),r.shape)}}}},Sb=[om,lm,um,cm,hm,dm,pm,fm,gm,mm,bm,ym,vm,km,Sm,Im,Cm,Tm,Nm,Em,$m,Rm,_m,Am,Dm,Fm,Lm,zm,Mm,Pm,xb,Bm,Um,Wm,Vm,Gm,jm,Hm,qm,Km,Qm,Jm,Zm,eb,tb,nb,rb,sb,ab,ob,ub,ub,cb,db,{kernelName:Qa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>pb(e,r,s,a,i,o)}}},{kernelName:ni,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Vr(s,r.shape),i=Lr(wh(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=Cc(e,t);return Yu(Qu(n,yd(r.shape,"float32")),i)}}}},{kernelName:ri,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=lb(e,i,a,Vr(s,a.shape));return{x:()=>o.x()}}},{kernelName:si,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Qu(e,ju(Jh(n,r),"float32")),b:()=>Qu(e,ju(Gh(n,r),"float32"))}}},{kernelName:ai,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Ac(e,a,r.shape)}}},fb,gb,{kernelName:ui,gradFunc:e=>({x:()=>rd(e)})},{kernelName:gi,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>bd(n.shape,"float32")}}},{kernelName:fi,gradFunc:e=>({x:()=>ph(e)})},{kernelName:mi,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return Mp(e,r).map((e=>()=>e))}},mb,mb,bb,yb,{kernelName:vi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=null==s?r.shape.map(((e,t)=>t)):"number"==typeof s?[s]:s,{x:()=>function(e,t,n){const r=e.shape.length,s=r-n.length,a=Ih(n,r);let i=e;null!=a&&(i=Bp(e,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=Cc(t,r),a=nh(e,n,!0,!1),i=nh(e,n,!0,!0),o=Qu(a,i);return Qu(s,o)}(i.reshape(o),t,s);if(u=u.reshape(i.shape),null!=a){const e=Ch(a);u=Bp(u,e)}return u}(r,e,a)}}},{kernelName:Ti,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,rd(_h(n)))}}},{kernelName:Oi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Qu(Jh(n,6),Np(n));return{x:()=>Qu(e,ju(r,"float32"))}}},{kernelName:Ni,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(e,ju(Np(n),"float32"))}}},{kernelName:Ei,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Cc(e,n.shape)}}},{kernelName:Ai,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Gl.runKernel(_i,s,n)}}},{kernelName:$i,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>Gl.runKernel(Ri,s,n)}}},{kernelName:Di,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Vr(r,e.shape);return{x:()=>ip(e,s)}}},{kernelName:Fi,gradFunc:e=>({x:()=>ph(e)})},{kernelName:Li,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>rd(Yu(e,Qu($h(n,1.5),2)))}}},{kernelName:Bi,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>ju(ph(n),"float32"),t:()=>Qu(e,ju(n,e.dtype)),e:()=>Qu(e,ju(cd(n),e.dtype))}}},{kernelName:Ui,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Gh(n,Rh(0)),r=Rh(wg),s=Rh(kg),a=Qu(e,s),i=Qu(Qu(e,r),zh(ju(n,"float32")));return dh(t,a,i)}}}},{kernelName:ji,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(e,Qu(n,id(Rh(1),n)))}}},{kernelName:Hi,gradFunc:e=>({x:()=>ph(e)})},{kernelName:Vi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(eh(ju(n,"float32")),e)}}},{kernelName:Gi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(th(ju(n,"float32")),e)}}},{kernelName:Wi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=Zf(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>Td(e,u)}}},{kernelName:Ji,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=Qu(e,r);return{logits:()=>id(a,Qu(Oh(a,[s],!0),r))}}},{kernelName:qi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(e,Rc(n))}}},vb,vb,wb,wb,{kernelName:Ki,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,Qu(Ah(ju(n,"float32")),2))}}},{kernelName:so,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Rh(2);return{a:()=>Qu(e,Qu(s,id(n,r))),b:()=>Qu(e,Qu(s,id(r,n)))}}},{kernelName:ao,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(e,Qu(ju(n,"float32"),2))}}},{kernelName:So,gradFunc:e=>({x:()=>ph(e)})},kb,{kernelName:Xi,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Vr(a,r.shape).forEach((e=>{s[e]=1}));const i=Cc(e,s),o=Qu(i,yd(r.shape,"float32"));return{x:()=>o}}},{kernelName:po,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Yu(e,_h(eh(n)))}}},{kernelName:fo,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qu(id(Rh(1),_h(n)),e)}}},{kernelName:go,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=ph(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=Ku(t,Ac(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=Ku(t,Ac(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=Ku(t,Ac(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=Ku(t,Ac(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:yo,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Ch(s);return{x:()=>Bp(e,a)}}},{kernelName:vo,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>Tp(e,s)}}},{kernelName:wo,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=gd(t,ph(t)),r=Vh(e,n);let s=Hh(t,Rh(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=Mh(s,o+1);s=ud(s,yd(r.shape,"bool"));const i=ph(r);return dh(s,r,i)}(e,n)}}},{kernelName:ko,gradFunc:e=>({x:()=>ph(e)})}];for(const FP of Sb)Fo(FP);vl().prototype.abs=function(){return this.throwIfDisposed(),Ju(this)},vl().prototype.acos=function(){return this.throwIfDisposed(),Zu(this)},vl().prototype.acosh=function(){return this.throwIfDisposed(),ec(this)},vl().prototype.add=function(e){return this.throwIfDisposed(),Ku(this,e)},vl().prototype.all=function(e,t){return this.throwIfDisposed(),tc(this,e,t)},vl().prototype.any=function(e,t){return this.throwIfDisposed(),nc(this,e,t)},vl().prototype.argMax=function(e){return this.throwIfDisposed(),rc(this,e)},vl().prototype.argMin=function(e){return this.throwIfDisposed(),sc(this,e)},vl().prototype.asScalar=function(){return this.throwIfDisposed(),Or(1===this.size,(()=>"The array must have only 1 element.")),Cc(this,[])},vl().prototype.asType=function(e){return this.throwIfDisposed(),ju(this,e)},vl().prototype.as1D=function(){return this.throwIfDisposed(),Cc(this,[this.size])},vl().prototype.as2D=function(e,t){return this.throwIfDisposed(),Cc(this,[e,t])},vl().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Cc(this,[e,t,n])},vl().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Cc(this,[e,t,n,r])},vl().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Cc(this,[e,t,n,r,s])},vl().prototype.asin=function(){return this.throwIfDisposed(),ac(this)},vl().prototype.asinh=function(){return this.throwIfDisposed(),ic(this)},vl().prototype.atan=function(){return this.throwIfDisposed(),oc(this)},vl().prototype.atan2=function(e){return this.throwIfDisposed(),lc(this,e)},vl().prototype.atanh=function(){return this.throwIfDisposed(),uc(this)},vl().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Tc(this,e,t,n,r)},vl().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Oc(this,e,t)},vl().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Dc(this,e,t,n,r,s)},vl().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Pc(this,e)},vl().prototype.cast=function(e){return this.throwIfDisposed(),ju(this,e)},vl().prototype.ceil=function(){return this.throwIfDisposed(),Bc(this)},vl().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Wc(this,e,t)},vl().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof xl&&(e=[e]),Ec([this,...e],t)},vl().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Kc(this,e,t,n,r,s,a)},vl().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Yc(this,e,t,n,r,s)},vl().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),qc(this,e,t,n,r,s,a)},vl().prototype.cos=function(){return this.throwIfDisposed(),eh(this)},vl().prototype.cosh=function(){return this.throwIfDisposed(),th(this)},vl().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),nh(this,e,t,n)},vl().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),rh(this,e,t,n)},vl().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),ah(this,e,t)},vl().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),ih(this,e,t,n,r,s,a)},vl().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),oh(this,e,t,n,r,s)},vl().prototype.divNoNan=function(e){return this.throwIfDisposed(),fh(this,e)},vl().prototype.div=function(e){return this.throwIfDisposed(),Yu(this,e)},vl().prototype.dot=function(e){return this.throwIfDisposed(),gh(this,e)},vl().prototype.elu=function(){return this.throwIfDisposed(),bh(this)},vl().prototype.equal=function(e){return this.throwIfDisposed(),hh(this,e)},vl().prototype.erf=function(){return this.throwIfDisposed(),yh(this)},vl().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Lh(this,e,t)},vl().prototype.exp=function(){return this.throwIfDisposed(),zh(this)},vl().prototype.expandDims=function(e){return this.throwIfDisposed(),Mh(this,e)},vl().prototype.expm1=function(){return this.throwIfDisposed(),Ph(this)},vl().prototype.fft=function(){return this.throwIfDisposed(),xp(this)},vl().prototype.flatten=function(){return this.throwIfDisposed(),Cc(this,[this.size])},vl().prototype.floor=function(){return this.throwIfDisposed(),Wh(this)},vl().prototype.floorDiv=function(e){return this.throwIfDisposed(),Xu(this,e)},vl().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Vh(this,e,t,n)},vl().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Hh(this,e)},vl().prototype.greater=function(e){return this.throwIfDisposed(),Gh(this,e)},vl().prototype.ifft=function(){return this.throwIfDisposed(),vp(this)},vl().prototype.irfft=function(){return this.throwIfDisposed(),wp(this)},vl().prototype.isFinite=function(){return this.throwIfDisposed(),qh(this)},vl().prototype.isInf=function(){return this.throwIfDisposed(),Kh(this)},vl().prototype.isNaN=function(){return this.throwIfDisposed(),Xh(this)},vl().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Yh(this,e)},vl().prototype.lessEqual=function(e){return this.throwIfDisposed(),Jh(this,e)},vl().prototype.less=function(e){return this.throwIfDisposed(),Qh(this,e)},vl().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Zh(this,e,t,n,r)},vl().prototype.logSigmoid=function(){return this.throwIfDisposed(),ad(this)},vl().prototype.logSoftmax=function(e){return this.throwIfDisposed(),od(this,e)},vl().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),ld(this,e,t)},vl().prototype.log=function(){return this.throwIfDisposed(),ed(this)},vl().prototype.log1p=function(){return this.throwIfDisposed(),td(this)},vl().prototype.logicalAnd=function(e){return this.throwIfDisposed(),ud(this,e)},vl().prototype.logicalNot=function(){return this.throwIfDisposed(),cd(this)},vl().prototype.logicalOr=function(e){return this.throwIfDisposed(),hd(this,e)},vl().prototype.logicalXor=function(e){return this.throwIfDisposed(),dd(this,e)},vl().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),$c(this,e,t,n)},vl().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),pd(this,e,t,n,r)},vl().prototype.max=function(e,t){return this.throwIfDisposed(),Nh(this,e,t)},vl().prototype.maximum=function(e){return this.throwIfDisposed(),gd(this,e)},vl().prototype.mean=function(e,t){return this.throwIfDisposed(),md(this,e,t)},vl().prototype.min=function(e,t){return this.throwIfDisposed(),Eh(this,e,t)},vl().prototype.minimum=function(e){return this.throwIfDisposed(),xd(this,e)},vl().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),vd(this,e,t)},vl().prototype.mod=function(e){return this.throwIfDisposed(),wd(this,e)},vl().prototype.mul=function(e){return this.throwIfDisposed(),Qu(this,e)},vl().prototype.neg=function(){return this.throwIfDisposed(),rd(this)},vl().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Fh(this,e,t,n)},vl().prototype.notEqual=function(e){return this.throwIfDisposed(),Sd(this,e)},vl().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Id(this,e,t,n)},vl().prototype.onesLike=function(){return this.throwIfDisposed(),Cd(this)},vl().prototype.pad=function(e,t){return this.throwIfDisposed(),Td(this,e,t)},vl().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),Ed(this,e,t,n,r,s,a)},vl().prototype.pow=function(e){return this.throwIfDisposed(),$h(this,e)},vl().prototype.prelu=function(e){return this.throwIfDisposed(),$d(this,e)},vl().prototype.prod=function(e,t){return this.throwIfDisposed(),Rd(this,e,t)},vl().prototype.reciprocal=function(){return this.throwIfDisposed(),rp(this)},vl().prototype.relu=function(){return this.throwIfDisposed(),sp(this)},vl().prototype.relu6=function(){return this.throwIfDisposed(),ap(this)},vl().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Cc(this,e.shape)},vl().prototype.reshape=function(e){return this.throwIfDisposed(),Cc(this,e)},vl().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),mf(this,e,t,n)},vl().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),bf(this,e,t,n)},vl().prototype.reverse=function(e){return this.throwIfDisposed(),ip(this,e)},vl().prototype.rfft=function(){return this.throwIfDisposed(),Sp(this)},vl().prototype.round=function(){return this.throwIfDisposed(),op(this)},vl().prototype.rsqrt=function(){return this.throwIfDisposed(),lp(this)},vl().prototype.selu=function(){return this.throwIfDisposed(),up(this)},vl().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),cp(this,e,t,n,r,s,a)},vl().prototype.sigmoid=function(){return this.throwIfDisposed(),Rc(this)},vl().prototype.sign=function(){return this.throwIfDisposed(),hp(this)},vl().prototype.sin=function(){return this.throwIfDisposed(),dp(this)},vl().prototype.sinh=function(){return this.throwIfDisposed(),pp(this)},vl().prototype.slice=function(e,t){return this.throwIfDisposed(),Ac(this,e,t)},vl().prototype.softmax=function(e){return this.throwIfDisposed(),yp(this,e)},vl().prototype.softplus=function(){return this.throwIfDisposed(),sd(this)},vl().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Nd(this,e,t)},vl().prototype.split=function(e,t){return this.throwIfDisposed(),kp(this,e,t)},vl().prototype.sqrt=function(){return this.throwIfDisposed(),Ah(this)},vl().prototype.square=function(){return this.throwIfDisposed(),_h(this)},vl().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Ip(this,e)},vl().prototype.squeeze=function(e){return this.throwIfDisposed(),Cp(this,e)},vl().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof xl?[this,e]:[this,...e];return Tp(n,t)},vl().prototype.step=function(e){return this.throwIfDisposed(),Np(this,e)},vl().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),Ep(this,e,t,n,r,s,a,i,o)},vl().prototype.sub=function(e){return this.throwIfDisposed(),id(this,e)},vl().prototype.sum=function(e,t){return this.throwIfDisposed(),Oh(this,e,t)},vl().prototype.tan=function(){return this.throwIfDisposed(),$p(this)},vl().prototype.tanh=function(){return this.throwIfDisposed(),_c(this)},vl().prototype.tile=function(e){return this.throwIfDisposed(),Bh(this,e)},vl().prototype.toBool=function(){return this.throwIfDisposed(),ju(this,"bool")},vl().prototype.toFloat=function(){return this.throwIfDisposed(),ju(this,"float32")},vl().prototype.toInt=function(){return this.throwIfDisposed(),ju(this,"int32")},vl().prototype.topk=function(e,t){return this.throwIfDisposed(),Dp(this,e,t)},vl().prototype.transpose=function(e){return this.throwIfDisposed(),Bp(this,e)},vl().prototype.unique=function(e){return this.throwIfDisposed(),Lp(this,e)},vl().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),zp(this,e,t)},vl().prototype.unstack=function(e){return this.throwIfDisposed(),Mp(this,e)},vl().prototype.where=function(e,t){return this.throwIfDisposed(),dh(e,this,t)},vl().prototype.zerosLike=function(){return this.throwIfDisposed(),ph(this)};class Ib extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ib.prototype)}}class Cb extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Cb.prototype)}}class Tb extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Tb.prototype)}}class Nb extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Nb.prototype)}}class Eb extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Eb.prototype)}}class $b{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Rb(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Ab(e,t){if(!e)throw new Eb(t)}function _b(e,t){let n=0;for(const r of e)r===t&&n++;return n}function Ob(e){return 1===e.length?e[0]:e}function Db(e){return Array.isArray(e)?e:[e]}function Fb(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Lb(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let zb={};function Mb(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Pb(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>Pb(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?Pb(t):e[n]=t.value)}}}function Bb(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in zb)a=zb[s];else if(a=t[s],null==a)throw new Tb(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new Tb(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in zb?[o,l]=zb.className:i in t&&([o,l]=t[i]),null==o)throw new Tb(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(zb))e[n]=zb[n];for(const s of Object.keys(n))e[s]=n[s];a.config.customObjects=e;const t=Object.assign({},zb);for(const s of Object.keys(n))zb[s]=n[s];Pb(a.config);const r=l(o,a.config,n,s);return zb=Object.assign({},t),r}{const e=Object.assign({},zb);for(const r of Object.keys(n))zb[r]=n[r];const t=new o(a.config);return zb=Object.assign({},e),t}}}function Ub(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Wb(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Vb(e){if(null==e)throw new Tb(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Gb(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Tb(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function Hb(e,t,n=0,r=1/0){return Ab(n>=0),Ab(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function jb(e,t){Array.isArray(e)?(Or(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>jb(e,`element ${n+1} of ${t}`)))):Or(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${qb(e)}.`))}function qb(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>qb(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function Kb(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let Xb=0;function Yb(){return Xb++}const Qb={};function Jb(e=""){return e in Qb||(Qb[e]=0),Qb[e]+=1,e+Qb[e].toString()}const Zb=["channelsFirst","channelsLast"],ey=["nearest","bilinear"],ty=["valid","same","causal"],ny=["max","avg"],ry=["sum","mul","concat","ave"],sy=new Map;function ay(e){Gb(Zb,"DataFormat",e)}function iy(e){Gb(ty,"PaddingMode",e)}function oy(e){Gb(ny,"PoolMode",e)}const ly=[];function uy(e,t){ly.push(e);try{const e=t();return ly.pop(),e}catch(n){throw ly.pop(),n}}function cy(e){if(!py(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===ly.length?"":ly.join("/")+"/")+e}function hy(e){if(!py(e))throw new Error("Not a valid tensor name: '"+e+"'");sy.has(e)||sy.set(e,0);const t=sy.get(e);if(sy.set(e,sy.get(e)+1),t>0){const n=`${e}_${t}`;return sy.set(n,1),n}return e}const dy=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function py(e){return!!e.match(dy)}function fy(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function gy(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function my(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function by(e,t){if(t<e)throw new Tb(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let yy;function xy(){return null==yy&&(yy=Gl.backend.epsilon()),yy}function vy(e,t){return ju(e,t)}function wy(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Cc(e,n)}function ky(e,t,n){return lu((()=>{switch(e.rank){case 1:return fp(e,t,n);case 2:return gp(e,[t,0],[n,e.shape[1]]);case 3:return mp(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return bp(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ac(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ac(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Tb(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Sy(e,t,n){return lu((()=>{switch(e.rank){case 1:return fp(e,t,n);case 2:return gp(e,[0,t],[e.shape[0],n]);case 3:return mp(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return bp(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Tb(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Iy(e,t,n,r){return lu((()=>{switch(e.rank){case 1:return fp(e,t,n);case 2:switch(r){case 1:return ky(e,t,n);case 2:return Sy(e,t,n);default:throw new Tb(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return ky(e,t,n);case 2:return mp(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Sy(e,t,n);default:throw new Tb(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return ky(e,t,n);case 2:return bp(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return bp(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Sy(e,t,n);default:throw new Tb(`The axis is not within the rank of the tensor ${r}`)}default:throw new Tb(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Cy(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Ec(e,t)}function Ty(e,t){switch(e.rank){case 1:return Vc([e,t]);case 2:return Gc([e,t],0);case 3:return Hc([e,t],0);case 4:return jc([e,t],0);default:throw new Tb(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Ny(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Tb(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Bh(e,t)}function Ey(e,t=0,n=1,r,s){return Zd(e,t,n,r,s)}function $y(e,t,n,r){if(e.rank<2||t.rank<2)throw new Nb(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Nb(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return Yp({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?_y(e.rank,r,"channelsLast"):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=Cc(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Cc(Bp(t,c),[l,-1]);const h=[...s,...u];return Cc(Yp({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?_y(e.rank,r,"channelsLast"):null,activation:n}),h)}}function Ry(e,t,n){return lu((()=>(t=Array.isArray(t)?Rp(t,"int32"):ju(t,"int32"),Vh(e,t,n))))}function Ay(e){return Qu(e,e)}function _y(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new Tb(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Cc(t,[1,r[0],1,1,1]):Cc(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Cc(t,[1,1,1,1,r[0]]):Cc(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Cc(t,[1,r[0],1,1]):Cc(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Cc(t,[1,1,1,r[0]]):Cc(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Cc(t,[1,r[0],1]):Cc(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Cc(t,[1,1,r[0]]):Cc(t,[1].concat(r))}else if(e<3)return t;throw new Tb(`Unsupported input rank by biasAdd: ${t.rank}`)}function Oy(e,t,n){return lu((()=>(null==n&&(n="channelsLast"),ay(n),Ku(e,_y(e.rank,t,n)))))}function Dy(e,t,n,r){return lu((()=>Up(e,t,n,r)))}function Fy(e,t,n=!1){return n?e():t()}const Ly=["fanIn","fanOut","fanAvg"],zy=["normal","uniform","truncatedNormal"];class My extends Sf{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Py extends My{apply(e,t){return bd(e,t)}}Py.className="Zeros",Cf(Py);class By extends My{apply(e,t){return yd(e,t)}}By.className="Ones",Cf(By);class Uy extends My{constructor(e){if(super(),"object"!=typeof e)throw new Tb(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new Tb(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return lu((()=>Qu(Rh(this.value),yd(e,t))))}getConfig(){return{value:this.value}}}Uy.className="Constant",Cf(Uy);class Wy extends My{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return ep(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Wy.className="RandomUniform",Cf(Wy);class Vy extends My{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Nb(`randomNormal does not support dType ${t}.`);return Ey(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Vy.className="RandomNormal",Cf(Vy);class Gy extends My{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Nb(`truncatedNormal does not support dType ${t}.`);return Fp(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Gy.className="TruncatedNormal",Cf(Gy);class Hy extends My{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return lu((()=>{if(2!==e.length||e[0]!==e[1])throw new Tb("Identity matrix initializer can only be used for 2D square matrices.");return Qu(this.gain,Uh(e[0]))}))}getConfig(){return{gain:this.gain}}}Hy.className="Identity",Cf(Hy);class jy extends My{constructor(e){if(super(),e.scale<0)throw new Tb(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,Gb(Ly,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Gb(zy,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(ay(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=fy(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=fy(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=fy(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Nb(`${this.getClassName()} does not support dType ${t}.`);return Fp(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return ep(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}jy.className="VarianceScaling",Cf(jy);class qy extends jy{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return jy.className}}qy.className="GlorotUniform",Cf(qy);class Ky extends jy{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return jy.className}}Ky.className="GlorotNormal",Cf(Ky);class Xy extends jy{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return jy.className}}Xy.className="HeNormal",Cf(Xy);class Yy extends jy{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return jy.className}}Yy.className="HeUniform",Cf(Yy);class Qy extends jy{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return jy.className}}Qy.className="LeCunNormal",Cf(Qy);class Jy extends jy{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return jy.className}}Jy.className="LeCunUniform",Cf(Jy);class Zy extends My{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return lu((()=>{if(e.length<2)throw new Nb("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Lr(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=Ey([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=vf.qr(a,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=Qu(o,l.sign()),n<r&&(o=o.transpose()),Qu(Rh(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}Zy.className="Orthogonal",Cf(Zy);const ex={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function tx(e,t={}){return Bb(e,If.getMap().classNameMap,t,"initializer")}function nx(e){return Mb(e)}function rx(e){if("string"==typeof e){const t=e in ex?ex[e]:e;if("GlorotNormal"===t)return new Ky;if("GlorotUniform"===t)return new qy;if("HeNormal"===t)return new Xy;if("HeUniform"===t)return new Yy;if("LeCunNormal"===t)return new Qy;if("LeCunUniform"===t)return new Jy;{const e={};return e.className=t,e.config={},tx(e)}}return e instanceof My?e:tx(e)}function sx(e){return Array.isArray(e)&&Array.isArray(e[0])}function ax(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function ix(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Tb(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function ox(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Tb(`Expected exactly 1 Shape; got ${e.length}`)}return e}function lx(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const ux="Variable";class cx{constructor(e,t="float32",n=ux,r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Yb(),n=null==n?ux:n,this.originalName=cy(n),this.name=hy(this.originalName),this.trainable_=r,this.constraint=s,this.val=function(e,t=!0,n,r){return Gl.makeVariable(e,t,n,r)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function hx(e){return e.map((e=>e.read()))}function dx(e){e.forEach((e=>{e[0].write(e[1])}))}class px{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class fx{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=Yb(),null!=a&&(this.originalName=cy(a),this.name=hy(this.originalName)),this.rank=t.length}}let gx=0;class mx{constructor(e,t){this.callArgs=t,this.id=gx++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let bx=0;class yx extends Sf{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=bx++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=Fb(e)+"_"+Jb(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Cb(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Tb(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Ob(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Ob(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ib(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Ib(`Layer ${this.name} is not connected, no input to return.`);return Ob(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Ib(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ib(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ob(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Db(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=Db(this.inputSpec);if(t.length!==n.length)throw new Tb(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],s=n[r];if(null==s)continue;const a=e.rank;if(null!=s.ndim&&a!==s.ndim)throw new Tb(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new Tb(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new Tb(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&e.dtype!==s.dtype)throw new Tb(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${e.dtype}.`);if(s.axes){const t=e.shape;for(const e in s.axes){const n=Number(e),a=s.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=a&&-1===[a,null].indexOf(i))throw new Tb(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=e.shape[t];if(null!=n&&null!=a&&n!==a)throw new Tb(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Db(e),r=function(e){let t=!0;for(const n of Db(e))if(!(n instanceof fx)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of Db(e))if(n instanceof fx){t=!1;break}return t}(e);if(r===s)throw new Tb("Arguments to apply() must be all SymbolicTensors or all Tensors");return uy(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of Db(e))t.push(n.shape);this.build(Ob(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=Db(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=Ob(a),null!=this.activityRegularizer)throw new Nb("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=Db(e);const t=[];for(const n of e)t.push(n.shape);return Ob(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new fx(a,n,this,Db(e),t,this.name,r))):new fx(a,r,this,Db(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new Nb("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Ib(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Ib(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Cb(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return lx(this.weights)}build(e){this.built=!0}getWeights(e=!1){return hx(e?this.trainableWeights:this.weights)}setWeights(e){lu((()=>{const t=this.weights;if(t.length!==e.length)throw new Tb(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=hx(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!zr(a.shape,o.shape))throw new Tb(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}dx(n)}))}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new Tb(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():rx("zeros"));const l=r.apply(t,n),u=new cx(l,n,e,a,i);return l.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Db(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=Db(t),a=Db(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=a[i]}addInboundNode(e,t,n,r,s,a,i=null){const o=Db(e);t=Db(t),n=Db(n),r=Db(r),s=ax(s),a=ax(a);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new mx({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function xx(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=xx(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class vx extends yx{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Jb("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Tb("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Tb("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Tb("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new fx(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new mx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Tb(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}vx.className="InputLayer",Cf(vx);class wx{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof wx)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Tb(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return ju(t,e.dtype)}catch(DP){throw new Tb(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof fx){if(null==this.id2Value[e.id])throw new Tb(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Tb(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof fx){if(null==this.id2Value[e.id])throw new Tb(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Tb(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&uu(this.id2Mask)}}const kx=new $b,Sx=new $b;function Ix(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);const c=o.join(",")+"|"+t.names().sort().join(",");let h,d=kx.get(c);if(null==d){const e=function(e,t){Or(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=Tx(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=Tx(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:Cx(r)}}(i,t);d=e.sorted,h=e.recipientCounts,kx.put(c,d),Sx.put(c,h)}h={},s||Object.assign(h,Sx.get(c));const p=new wx(t);for(let f=0;f<d.length;++f){const e=d[f],r=e.sourceLayer;if(r instanceof vx)continue;const a=[],i=[],u=[];let c=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);a.push(e),i.push(r),null!=r&&(c=!0),s||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}c&&((n=n||{}).mask=i[0]);const g=Db(r.apply(a,n));let m=null;r.supportsMasking&&(m=r.computeMask(a,i));const b=Nx(e),y=Array.isArray(b)?b:[b];for(let t=0;t<y.length;++t){p.hasKey(y[t])||p.add(y[t],g[t],Array.isArray(m)?m[0]:m);const e=o.indexOf(y[t].name);-1!==e&&(l[e]=g[t])}s||uu(u)}return p.disposeMasks(),a?l:l[0]}function Cx(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Tx(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function Nx(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Ex(e,t){return lu((()=>Ah(Oh(Qu(e,e),t,!0))))}ps().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=kx&&kx.setMaxEntries(e),null!=Sx&&Sx.setMaxEntries(e)}));class $x extends Sf{getConfig(){return{}}}class Rx extends $x{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return lu((()=>{const t=Ex(e,this.axis),n=Wc(t,0,this.maxValue);return Qu(e,Yu(n,Ku(xy(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Rx.className="MaxNorm",Cf(Rx);class Ax extends $x{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return lu((()=>Yu(e,Ku(xy(),Ex(e,this.axis)))))}getConfig(){return{axis:this.axis}}}Ax.className="UnitNorm",Cf(Ax);class _x extends $x{apply(e){return sp(e)}}_x.className="NonNeg",Cf(_x);class Ox extends $x{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return lu((()=>{const t=Ex(e,this.axis),n=Ku(Qu(this.rate,Wc(t,this.minValue,this.maxValue)),Qu(1-this.rate,t));return Qu(e,Yu(n,Ku(xy(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Ox.className="MinMaxNorm",Cf(Ox);const Dx={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Fx(e){return Mb(e)}function Lx(e,t={}){return Bb(e,If.getMap().classNameMap,t,"constraint")}function zx(e){return null==e?null:"string"==typeof e?Lx({className:e in Dx?Dx[e]:e,config:{}}):e instanceof $x?e:Lx(e)}async function Mx(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];uu(r)}}function Px(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var Bx,Ux;(Ux=Bx||(Bx={}))[Ux.SILENT=0]="SILENT",Ux[Ux.VERBOSE=1]="VERBOSE";class Wx{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Vx{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Gx extends Wx{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const s=lu((()=>Ku(this.totals[r],Qu(e,n))));this.totals[r]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:lu((()=>{const e=Qu(Yu(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),cu(t[n])})))}}class Hx extends Wx{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const s in this.history){const r=this.history[s];for(let a=0;a<r.length;++a)if("number"!=typeof r[a]){const i=r[a];e.push(i.data()),t.push(s),n.push(a)}}const r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}}class jx extends Wx{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||ag,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Yr(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():rl();return(...a)=>{const i=null!=n?n():rl();return i-s<t||(s=i,r=e(...a)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await Mx(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Mx(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Mx(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Mx(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Mx(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Yr(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Mx(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Mx(e),await this.trainEnd(e))}}function qx(e,t){return null==e&&(e={}),e instanceof Wx?[e]:Array.isArray(e)&&e[0]instanceof Wx?e:Db(e).map((e=>new jx(e,t)))}class Kx{constructor(){}static registerCallbackConstructor(e,t){Or(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),Kx.checkForDuplicate(t),null==Kx.constructors[e]&&(Kx.constructors[e]=[]),Kx.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Kx.constructors)Kx.constructors[+t].forEach((t=>{if(t===e)throw new Tb("Duplicate callback constructor.")}))}static clear(){Kx.constructors={}}static createCallbacks(e){const t=[];for(const n in Kx.constructors){const r=+n;e>=r&&t.push(...Kx.constructors[r])}return t.map((e=>new e))}}function Xx(e,t,n,r,s,a,i,o,l){const u=new Hx,c=[new Gx,...Kx.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const h=new Vx(c);return h.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function Yx(e,t={},n=!1){return Bb(e,If.getMap().classNameMap,t,"layer",n)}function Qx(e,t){return lu((()=>{"float32"!==e.dtype&&(e=ju(e,"float32"));const n=Oh(Ay(e),t,!0),r=Uc(n.shape,xy()),s=Ah(gd(n,r));return Yu(e,s)}))}function Jx(e,t){return lu((()=>md(Ay(id(t,e)),-1)))}function Zx(e,t){return lu((()=>md(Ju(id(t,e)),-1)))}function ev(e,t){return lu((()=>{const n=id(e,t),r=Wc(Ju(e),xy(),Number.MAX_VALUE),s=Ju(Yu(n,r));return Qu(100,md(s,-1))}))}function tv(e,t,n=!1){return lu((()=>{if(n)t=yp(t);else{const e=Oh(t,t.shape.length-1,!0);t=Yu(t,e)}return t=Wc(t,xy(),1-xy()),rd(Oh(Qu(ju(e,"float32"),ed(t)),t.shape.length-1))}))}function nv(e,t,n=!1){return lu((()=>{const r=ju(Wh(function(e){const t=[fy(e.shape)];return Cc(e,t)}(e)),"int32"),s=(t=Wc(t,xy(),1-xy())).shape;return tv(Cc(Id(r,s[s.length-1]),s),t,n)}))}function rv(e,t){return lu((()=>{let n;return n=Wc(t,xy(),1-xy()),n=ed(Yu(n,id(1,n))),md(function(e,t){if(!zr(e.shape,t.shape))throw new Tb(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return lu((()=>{const n=sp(t),r=rd(Ju(t));return Ku(id(n,Qu(t,e)),td(zh(r)))}))}(e,n),-1)}))}function sv(e,t){return lu((()=>{const n=Qx(e,-1),r=Qx(t,-1),s=Qu(n,r);return rd(Oh(s,-1))}))}Kx.constructors={};const av={meanSquaredError:Jx,meanAbsoluteError:Zx,meanAbsolutePercentageError:ev,meanSquaredLogarithmicError:function(e,t){return lu((()=>{const n=Wc(t,xy(),Number.MAX_VALUE),r=ed(Ku(1,n)),s=Wc(e,xy(),Number.MAX_VALUE),a=ed(Ku(1,s));return md(Ay(id(r,a)),-1)}))},squaredHinge:function(e,t){return lu((()=>{const n=gd(0,id(1,Qu(e,t)));return md(Ay(n),-1)}))},hinge:function(e,t){return lu((()=>{const n=gd(0,id(1,Qu(e,t)));return md(n,-1)}))},categoricalHinge:function(e,t){return lu((()=>{const n=Oh(Qu(e,t),-1),r=Nh(Qu(id(1,e),t),-1);return gd(0,Ku(1,id(r,n)))}))},logcosh:function(e,t){return lu((()=>{const n=Math.log(2),r=id(t,e),s=id(Ku(r,sd(Qu(-2,r))),n);return md(s,-1)}))},categoricalCrossentropy:tv,sparseCategoricalCrossentropy:nv,binaryCrossentropy:rv,kullbackLeiblerDivergence:function(e,t){return lu((()=>{const n=Wc(e,xy(),1),r=Wc(t,xy(),1);return Oh(Qu(e,ed(Yu(n,r))),-1)}))},poisson:function(e,t){return lu((()=>{const n=ed(Ku(xy(),t));return md(id(t,Qu(e,n)),-1)}))},cosineProximity:sv};function iv(e){if("string"==typeof e){if(e in av)return av[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Tb(t)}return e}function ov(e,t){return lu((()=>{const n=Qu(.5,Cd(t)),r=vy(Gh(t,n),e.dtype);return md(hh(e,r),-1)}))}function lv(e,t){return lu((()=>vy(hh(rc(e,-1),rc(t,-1)),"float32")))}function uv(e,t){return rv(e,t)}function cv(e,t){return e.rank===t.rank&&(e=Cp(e,[e.rank-1])),(t=rc(t,-1)).dtype!==e.dtype&&(t=ju(t,e.dtype)),ju(hh(e,t),"float32")}const hv=tv,dv=nv,pv={binaryAccuracy:ov,categoricalAccuracy:lv,precision:function(e,t){return lu((()=>{const n=function(e,t){return lu((()=>ju(Oh(ud(hh(e,1),hh(t,1))),"float32")))}(e,t),r=function(e,t){return lu((()=>ju(Oh(ud(hh(e,0),hh(t,1))),"float32")))}(e,t),s=Ku(n,r);return ju(dh(Gh(s,0),Yu(n,s),0),"float32")}))},categoricalCrossentropy:hv,sparseCategoricalCrossentropy:dv,mse:Jx,MSE:Jx,mae:Zx,MAE:Zx,mape:ev,MAPE:ev,cosine:sv};function fv(e){if("string"==typeof e&&e in pv)return pv[e];if("string"!=typeof e&&null!=e)return e;throw new Tb(`Unknown metric ${e}`)}function gv(e){if(Ab(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(av))if(av[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(pv))if(pv[n]===e){t=n;break}return void 0!==t?t:e.name}}function mv(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!bv(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function bv(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!bv(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!bv(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function yv(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function xv(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(DP){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(DP){r="multiple"}yv([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function vv(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(DP){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(DP){s="multiple"}const i=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];yv([`${o} (${l})`,a,s,e.countParams().toString(),u],t,r);for(let c=1;c<i.length;++c)yv(["","","","",i[c]],t,r)}function wv(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function kv(e,t){if(null===e)return null;if("string"==typeof e)return Lb(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];wv(t,s,r)?n.push(r):n.push(kv(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=Lb(n);t[e]=kv(r,e)}}return t}}function Sv(e,t){if(null==e)return null;if("string"==typeof e)return Fb(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];wv(t,s,r)?n.push(r):n.push(Sv(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];t[Fb(n)]="name"!==n&&"className"!==n||"string"!=typeof r?Sv(r,n):r}return t}}const Iv="4.22.0";class Cv extends yx{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Jb(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Wb(this.inputs).length!==this.inputs.length)throw new Tb(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);Wb(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;Ab(0===t,"input layer has >1 nodes"),Ab(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof vx))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new Cb(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(Cv.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let a=0;a<c;a++){const e=u.inputTensors[a],r=u.inboundLayers[a],s=u.nodeIndices[a],i=u.tensorIndices[a];o(e,t,n,r,s,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const b of this.outputs)o(b,l,u);const c=i.slice().reverse();for(const b of c){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];const a=null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id];e=Math.max(e,a),r[b.outboundLayer.id]=e,s[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let r=0;r<b.inboundLayers.length;r++){const s=b.inboundLayers[r],a=b.nodeIndices[r],i=s.inboundNodes[a],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const h={};for(const b in t){const e=t[b];e in h||(h[e]=[]),h[e].push(n[b])}const d={};for(const b in r){const e=r[b];e in d||(d[e]=[]),d[e].push(s[b])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(Ub);this.layers=[];for(const b of p){const e=d[b];e.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof Cv&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(Ub);const f=this.inputs.slice(),g=[];for(const b of p)for(const e of h[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new Cb(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${g}`);for(const t of e.outputTensors)f.push(t);g.push(t.name)}}this.nodesByDepth=h;const m=this.layers.map((e=>e.name));for(const b of m){const e=m.filter((e=>e===b)).length;if(1!==e)throw new Cb(`The name "${b}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new mx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Tb("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const a=s?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[a])throw new Tb(`Duplicate weight name: ${a}`);n[a]=t,r++}const a=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[i]]);else if(t)throw new Tb(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Tb(`${e.length} of ${r} weights are not set: ${e}`)}dx(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Iv}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=Sv(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return lu((()=>{e=Db(e);const n=new wx;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Ix(this.outputs,n,t)}))}computeMask(e,t){return lu((()=>{let n;return e=Db(e),n=null==t?Rb(null,e.length):Db(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=ax(e);if(t.length!==this.inputLayers.length)throw new Tb(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Ub);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],s=t.nodeIndices[i],a=t.tensorIndices[i],o=n[`${e.name}_${s}_${a}`];r.push(o)}const s=ax(e.computeOutputShape(Ob(r))),a=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++)n[`${e.name}_${a}_${t}`]=s[t]}}const s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;a.push(r)}for(let i=0;i<a.length;i++){const e=a[i];Ab(e in n),s.push(n[e])}return Ob(s)}runInternalGraph(e,t){null==t&&(t=Rb(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],s=e[o],a=t[o];n[r.id]=[s,a]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Ub);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,a=new Array;for(const t of r)t.id in n&&a.push(n[t.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===a.length){const[t,n]=a[0];null==u.mask&&(u.mask=n),o=Db(e.call(t,u)),l=Db(e.computeMask(t,n)),r=[t],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==u.mask&&(u.mask=i),o=Db(e.call(r,u)),l=Db(e.computeMask(r,i));if(e.activityRegularizer)throw new Nb("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=l[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const o of this.outputs){Ab(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),s.push(e),a.push(t)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof Cv?1:0;for(let e=0;e<r.inboundNodes.length;e++){const s=Cv.nodeKey(r,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new Tb("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new Tb(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Tb(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return lu((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=Cv.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),r=a.getConfig(),s=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],r=Cv.nodeKey(a,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(DP){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],a=e.nodeIndices[r],o=e.tensorIndices[r];let l=t[Cv.nodeKey(s,a)];null==l&&(l=0),n.push([s.name,l,o,i])}s.push(n)}}}const i={};i.name=a.name,i.className=e,i.config=r,i.inboundNodes=s,n.push(i)}e.layers=n;const r=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=this.inputLayersNodeIndices[a],s=Cv.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let i=t[s];null==i&&(i=0);const o=this.inputLayersTensorIndices[a];r.push([e.name,i,o])}e.inputLayers=r;const s=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=this.outputLayersNodeIndices[a],r=Cv.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null==i&&(i=0);const o=this.outputLayersTensorIndices[a];s.push([e.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],l=a[1],u=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=l)return void i(e,t);const h=c.inboundNodes[l];n.push(h.outputTensors[u])}n.length>0&&e.apply(Ob(n),r)}function l(e){const n=e.name,a=Yx(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Tb(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)}))}const u=t.name,c=t.layers;for(const g of c)l(g);for(;!Vb(a);)for(const e of c){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const h=[],d=[],p=t.inputLayers;for(const g of p){const e=g[0],t=g[1],n=g[2];Ab(e in s);const r=s[e].inboundNodes[t].outputTensors;h.push(r[n])}const f=t.outputLayers;for(const g of f){const e=g[0],t=g[1],n=g[2];Ab(e in s);const r=s[e].inboundNodes[t].outputTensors;d.push(r[n])}return new e({inputs:h,outputs:d,name:u})}get stateful(){if(this._stateful)throw new Tb("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){lu((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function Tv(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function Nv(e,t,n,r){if(null!=n){const t=lu((()=>{if(1===e.shape.length)return qu(e);if(2===e.shape.length){if(e.shape[1]>1)return rc(e,1);if(1===e.shape[1])return Cc(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());uu(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),Rp(s,"float32")}return null}function Ev(e,t){return Qu(e,t)}function $v(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Or(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=Rv("input",e.inputNames,n),i=Rv("output",e.outputNames,r),o=a[0].shape[0];Or(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Or(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<a.length;l++)Or(a[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Or(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function Rv(e,t,n){if(n instanceof xl)return[n];if(Array.isArray(n))return Or(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new Tb(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function Av(e){return"function"==typeof e.iterator}function _v(e){Or(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function Ov(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>ky(e,t,n-t))):ky(e,t,n-t)}function Dv(e,t){return lu((()=>null==e?null:Array.isArray(e)?e.map((e=>Dv(e,t))):Ry(e,"int32"===t.dtype?t:ju(t,"int32"))))}function Fv(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function Lv(e){const t=[];e instanceof xl&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(wy(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function zv(e,t){if(null==e)return;const n=[];if(t instanceof xl)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const s in t){const e=t[s];n.push(e.id)}const r=[];if(e instanceof xl)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function Mv(e){return Array.isArray(e)}function Pv(e){return!function(e){return e instanceof xl}(e)&&!Mv(e)}function Bv(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(Mv(e)&&e.length>0)t=!0;else if(Pv(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Tb(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let a;if(Pv(e)){a=[];for(const n of t){if(null==e[n])throw new Tb(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(Mv(e)){if(e.length!==t.length)throw new Tb(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(t.length>1)throw new Tb(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=Lv(a),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new Tb(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!r)continue;const a=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&a!==o)throw new Tb(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return a}function Uv(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new Tb(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new Tb(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=a[i];if(e.shape.length!==n[i].length)throw new Tb(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let a=0;a<n[i].length;++a){if(0===a&&!r)continue;const o=e.shape[a],l=n[i][a];if(null!=l&&l!==o)throw new Tb(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class Wv extends Cv{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new Tb("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),yv(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?xv(o[c],n,r):vv(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;return t=null!=e.collectedTrainableWeights?lx(e.collectedTrainableWeights):lx(e.trainableWeights),t}(e),u=lx(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>rg.adagrad(.01),Adadelta:()=>rg.adadelta(1,.95,xy()),Adam:()=>rg.adam(.001,.9,.999,xy()),Adamax:()=>rg.adamax(.002,.9,.999,xy(),0),RMSProp:()=>rg.rmsprop(.001,.9,0,xy()),SGD:()=>rg.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Tb(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Tf))throw new Tb("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Tb(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>iv(e)))}else{const n=iv(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Tb(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(iv(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a],t=this.outputNames[a];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],uy("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};uy("metric",(()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===rv?-1!==["accuracy","acc"].indexOf(i)?r=ov:-1!==["crossentropy","ce"].indexOf(i)&&(r=uv):this.lossFunctions[e]===nv?-1!==["accuracy","acc"].indexOf(i)?r=cv:-1!==["crossentropy","ce"].indexOf(i)&&(r=dv):-1!==["accuracy","acc"].indexOf(i)?r=lv:-1!==["crossentropy","ce"].indexOf(i)&&(r=hv),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=fv(i);a=e,n=""+gv(i)}let t;uy(n,(()=>{t=a})),s(e,n,t)}})(r[e])})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;_v(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return Ob(this.testLoop(t,e,r,n.verbose,n.steps))}finally{zv(s[0],e),zv(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new Nb("Verbose mode is not implemented yet.");Or(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"==typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(a=lu((()=>{if(t.value){const{xs:n,ys:r}=$v(e,t.value),i=n.concat(r),u=lu((()=>s(i)));if(uu(i),0===l)for(let e=0;e<u.length;++e)a.push(Rh(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=lu((()=>Ku(a[e],Qu(c,t)))),l>0&&uu(n)}uu(u),o+=c,++l}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const e=a[u];a[u]=Yu(a[u],o),uu(e)}return Ob(a)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new Tb(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new Tb(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Tb("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new wx;if(e instanceof xl&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Tb(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new Tb(`No value is provided for the model's input ${o.name}`);a.add(o,t)}const i=Ix(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=Rb(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new Tb(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return lu((()=>{const r=this.checkNumSamples(e);if(n)throw new Nb("Verbose predictLoop() is not implemented yet.");const s=Fv(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t)lu((()=>{const n=s[t][0],r=s[t][1],a=Ov(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new wx(i);return Ix(this.outputs,o)})).forEach(((e,t)=>a[t].push(e)));return Ob(a.map((e=>Ec(e,0))))}))}predict(e,t={}){const n=Lv(e);Uv(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return _v(e),this.predictLoop(n,e)}finally{zv(n,e)}}predictOnBatch(e){Uv(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new Cb("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let a=0;a<this.feedOutputShapes.length;++a){const e=this.feedOutputShapes[a];this.feedLossFns[a]===nv?s.push(e.slice(0,e.length-1).concat([1])):s.push(e)}if(function(e,t){const n=Wb(e.map((e=>e.shape[0])));n.sort();const r=Wb(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new Tb(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new Tb(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!zr(n,r))throw new Tb(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=Bv(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Bv(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[Jx,rv,tv];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===tv&&1===a.shape[a.shape.length-1])throw new Tb(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new Tb(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new Tb(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=Tv(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await Nv(o[t],0,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,s){return lu((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new Nb("Verbose mode is not implemented yet.");if(null!=s)throw new Nb("steps mode in testLoop() is not implemented yet");{const r=Fv(a,n),s=Rp(by(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=ky(s,a,o-a),u=Dv(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(Rh(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=Ku(i[e],Qu(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=Yu(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;_b(e,r)>1&&(s+=`_${_b(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new wx(e),o=Ix(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=s[n]&&(e=Ev(e,s[n]));const a=md(e);t.push(a),l=0===n?e:Ku(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],s=this.metricsTensors[n][1];e=md(t(r[s],o[s]))}cu(e),a.push(e)}return l=md(l),this.calculateLosses().forEach((e=>{l=Ku(l,e)})),l}),!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>lu((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new wx(a),o=Ix(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=md(r(s[e],o[e]));n=0===e?a:Ku(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=md(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,a,i,o,l,u,c,h;this.isTraining=!0;try{const d=null==n.batchSize?32:n.batchSize;_v(d);const p=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,p,d);r=f[0],s=f[1],h=f[2];let g,m=!1;if(null!=n.validationData&&n.validationData.length>0){if(m=!0,2!==n.validationData.length)throw 3===n.validationData.length?new Nb("validationData including sample weights is not supported yet."):new Tb(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],l=n.validationData[1];const e=!0,t=await this.standardizeUserData(o,l,null,null,e,d);u=t[0],c=t[1],g=u.concat(c)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){m=!0;const e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=Ov(r,e,t),a=r,r=Ov(r,0,e),c=Ov(s,e,t),i=s,s=Ov(s,0,e),g=u.concat(c)}else null!=n.validationSteps&&(m=!0);const b=r.concat(s).concat(h);this.checkTrainableWeightsConsistency();const y=this.makeTrainFunction(),x=this.getDedupedMetricsNames();let v,w;m?(this.makeTestFunction(),v=this.testFunction,w=x.slice().concat(x.map((e=>"val_"+e)))):(v=null,g=[],w=x.slice());const k=qx(n.callbacks,n.yieldEvery);return await this.fitLoop(y,b,x,d,n.epochs,n.verbose,k,v,g,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,zv(r,e),zv(s,t),zv(a,e),zv(i,t),zv(u,o),zv(c,l),null!=h&&uu(h)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,h,d,p){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new Tb("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,r,d,"steps_per_epoch");let m;null!=g&&(m=by(0,g)),null==a&&(a=1);const{callbackList:b,history:y}=Xx(i,a,s,h,g,d,r,f,c);b.setModel(this),this.history=y,await b.onTrainBegin(),this.stopTraining_=!1;for(let x=h;x<s;++x){await b.onEpochBegin(x);const s={};if(null!=d)throw new Nb("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new Nb("batch shuffling is not implemneted yet");u&&$r(m);const a=Rp(m),i=Fv(g,r);for(let u=0;u<i.length;++u){const c={};if(await b.onBatchBegin(u,c),lu((()=>{const h=i[u][0],d=i[u][1],p=ky(a,h,d-h);c.batch=u,c.size=d-h;const g=Dv(t,p),m=e(g);for(let e=0;e<n.length;++e){const t=n[e],r=m[e];c[t]=r,cu(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];cu(a),s["val_"+r]=a}}})),await b.onBatchEnd(u,c),Px(c),this.stopTraining_)break}a.dispose()}if(await b.onEpochEnd(x,s),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return async function(e,t,n){const r=null!=n.batchesPerEpoch;if(Or(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Or(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Or(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Or(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Or(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(Av(n.validationData))Or(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new Nb("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=qx(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Xx(c,h,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,s,u);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await t.iterator();for(;f<n.epochs;){const u={};await d.onEpochBegin(f);let c=0,h=0;for(r||(g=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await g.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){const{xs:r,ys:s}=$v(e,t.value),a={};a.batch=h,a.size=r[0].shape[0],await d.onBatchBegin(h,a);const i=[];if(null!=n.classWeight){const t=Tv(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await Nv(s[e],0,t[e]))}const u=r.concat(s).concat(i),p=o(u);uu(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];a[t]=n,cu(n)}await d.onBatchEnd(h,a),Px(a),h++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=Av(n.validationData)?Db(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Db(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,u),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const o of a){const e=await o.data();i.push(e[0])}return uu(a),zv(n[0],e),zv(n[1],t),Ob(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=ou().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-ou().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Fb(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>Fb(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=Fb(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Fb(gv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>Fb(gv(e))));{const e={};for(const t in this.metrics)e[t]=Fb(gv(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Yx(kv(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=Lb(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>Lb(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=Lb(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>Lb(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=Lb(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=(n=e,vu.getSaveHandlers(n));if(0===t.length)throw new Tb(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Tb(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}var n;if(null==e.save)throw new Tb("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await du(this.getNamedWeights(t)),s={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Iv}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await du(await this.optimizer.getWeights(),e);r.specs.push(...n),r.data=(a=[r.data,t],au.join(a))}var a;if(null!=this.userDefinedMetadata){const e=!0;mv(this.userDefinedMetadata,this.name,e),s.userDefinedMetadata=this.userDefinedMetadata}return s.weightData=r.data,s.weightSpecs=r.specs,e.save(s)}setUserDefinedMetadata(e){mv(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Wv.className="Model",Cf(Wv);class Vv extends Wv{}Vv.className="Functional",Cf(Vv);class Gv extends Wv{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Jb("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Tb(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Gv||e instanceof Wv;let n;if(t){if(n=e,1!==n.outputs.length)throw new Tb("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Tb("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Tb("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Tb("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new vx({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Tb(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new Tb("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=xx(this.outputs[0])}this.inboundNodes=[],new mx({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Rb(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(ox(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Wv({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Cb("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Cb("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Cb("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Cb("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Tb("Legacy serialization format not supported yet.");s=t}else Or(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof Gv))throw new Nb(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const o of s){const e=Yx(o,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),i.add(e)}return i}set stopTraining(e){if(null==this.model)throw new Tb("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Tb("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}Gv.className="Sequential",Cf(Gv);let Hv=class extends Sf{getConfig(){return{}}};class jv extends Hv{apply(e,t=1){return function(e,t=1){if(1!==t)throw new Nb(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return bh(e)}(e,t)}}jv.className="elu",Cf(jv);class qv extends Hv{apply(e){return up(e)}}qv.className="selu",Cf(qv);class Kv extends Hv{apply(e){return sp(e)}}Kv.className="relu",Cf(Kv);class Xv extends Hv{apply(e){return lu((()=>xd(6,sp(e))))}}Xv.className="relu6",Cf(Xv);class Yv extends Hv{apply(e){return e}}Yv.className="linear",Cf(Yv);class Qv extends Hv{apply(e){return Rc(e)}}Qv.className="sigmoid",Cf(Qv);class Jv extends Hv{apply(e){return function(e){return lu((()=>{const t=Ku(.5,Qu(.2,e));return Wc(t,0,1)}))}(e)}}Jv.className="hardSigmoid",Cf(Jv);class Zv extends Hv{apply(e){return sd(e)}}Zv.className="softplus",Cf(Zv);class ew extends Hv{apply(e){return function(e){return lu((()=>Yu(e,Ku(Ju(e),1))))}(e)}}ew.className="softsign",Cf(ew);class tw extends Hv{apply(e){return _c(e)}}tw.className="tanh",Cf(tw);let nw=class extends Hv{apply(e,t=-1){return yp(e,t)}};nw.className="softmax",Cf(nw);class rw extends Hv{apply(e,t=-1){return od(e,t)}}rw.className="logSoftmax",Cf(rw);class sw extends Hv{apply(e){return lu((()=>lu((()=>{const t=Math.sqrt(2),n=Qu(.5,Ku(1,yh(Yu(e,t))));return Qu(e,n)}))))}}sw.className="gelu",Cf(sw);class aw extends Hv{apply(e){return lu((()=>Qu(.5,Qu(e,Ku(1,_c(Qu(Ah(Yu(2,Math.PI)),Ku(e,Qu(.044715,$h(e,3))))))))))}}aw.className="gelu_new",Cf(aw);class iw extends Hv{apply(e){return lu((()=>Qu(e,_c(sd(e)))))}}iw.className="mish",Cf(iw);class ow extends Hv{apply(e,t=1){return lu((()=>Qu(Rc(Qu(e,t)),e)))}}function lw(e){return e.getClassName()}function uw(e,t={}){return Bb(e,If.getMap().classNameMap,t,"activation")}function cw(e){if(null==e){return uw({className:"linear",config:{}})}if("string"==typeof e){const t={};return t.className=e,t.config={},uw(t)}return e instanceof Hv?e:uw(e)}ow.className="swish",Cf(ow);class hw extends Sf{}class dw extends hw{constructor(e){super(),function(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return lu((()=>{let t=bd([1]);return this.hasL1&&(t=Ku(t,Oh(Qu(this.l1,Ju(e))))),this.hasL2&&(t=Ku(t,Oh(Qu(this.l2,Ay(e))))),Cc(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}dw.className="L1L2",Cf(dw);const pw={l1l2:"L1L2"};function fw(e){return Mb(e)}function gw(e,t={}){return Bb(e,If.getMap().classNameMap,t,"regularizer")}function mw(e){return null==e?null:"string"==typeof e?gw({className:e in pw?pw[e]:e,config:{}}):e instanceof hw?e:gw(e)}class bw extends yx{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=ix(e);let n=sp(e);return null!=this.maxValue&&(n=Wc(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}bw.className="ReLU",Cf(bw);class yw extends yx{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=ix(e);return Yh(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}yw.className="LeakyReLU",Cf(yw);class xw extends yx{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=rx(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=mw(e.alphaRegularizer),this.alphaConstraint=zx(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new Tb(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=ox(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new px({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=ix(e),$d(e,this.alpha.read())}getConfig(){const e={alphaInitializer:nx(this.alphaInitializer),alphaRegularizer:fw(this.alphaRegularizer),alphaConstraint:Fx(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}xw.className="PReLU",Cf(xw);let vw=class extends yx{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Nb(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=ix(e);return bh(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};vw.className="ELU",Cf(vw);class ww extends yx{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=ix(e);return Qu(n,ju(Gh(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}ww.className="ThresholdedReLU",Cf(ww);class kw extends yx{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new nw).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return lu((()=>{let n=ix(e);const r=t.mask;if(null!=r){const e=Qu(id(yd(n.shape),ju(r,n.dtype)),Rh(-1e9));n=Ku(n,e)}return this.axis instanceof Array?this.axis.length>1?zh(id(n,ld(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Sw(e,t,n){if("number"==typeof e)return Rb(e,t);if(e.length!==t)throw new Tb(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const a=e[s];if((r=a)!==parseInt(r.toString(),10))throw new Tb(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var r}function Iw(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function Cw(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+my([n-t,0]);else{if("same"!==r)throw new Tb(`Unsupport padding mode: ${r}.`);e*=t}return e}function Tw(e,t){return lu((()=>(ay(t),"channelsFirst"===t?Bp(e,[0,2,3,1]):e)))}function Nw(e,t){return lu((()=>(ay(t),"channelsFirst"===t?Bp(e,[0,2,3,4,1]):e)))}function Ew(e,t,n,r=[1,1],s="valid",a,i,o=null){return lu((()=>{if(null==a&&(a="channelsLast"),ay(a),3!==e.rank&&4!==e.rank)throw new Tb(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new Tb(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=Tw(e,a);if("causal"===s)throw new Nb("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=qp({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=Bp(l,[0,3,1,2])),l}))}kw.className="Softmax",Cf(kw);class $w extends yx{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$w.verifyArgs(t),this.rank=e,jb(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Nb(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Sw(t.kernelSize,e,"kernelSize"),this.strides=Sw(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,iy(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,ay(this.dataFormat),this.activation=cw(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=rx(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=zx(t.biasConstraint),this.biasRegularizer=mw(t.biasRegularizer),this.activityRegularizer=mw(t.activityRegularizer),this.dilationRate=Sw(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Tb(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Tb(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Tb(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(Ab("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!Hb(e.kernelSize,"number",1,3))throw new Tb(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:lw(this.activation),useBias:this.useBias,biasInitializer:nx(this.biasInitializer),biasRegularizer:fw(this.biasRegularizer),activityRegularizer:fw(this.activityRegularizer),biasConstraint:Fx(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Rw extends $w{constructor(e,t){super(e,t),this.kernel=null,Rw.verifyArgs(t),this.filters=t.filters,jb(this.filters,"filters"),this.kernelInitializer=rx(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=zx(t.kernelConstraint),this.kernelRegularizer=mw(t.kernelRegularizer)}build(e){e=ox(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Tb(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return lu((()=>{let t;e=ix(e);const n=null==this.bias?null:this.bias.read(),r=Kb(this.activation.getClassName());if(null!=r&&2===this.rank)t=Ew(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,s="valid",a,i=1){return lu((()=>{if(null==a&&(a="channelsLast"),ay(a),3!==e.shape.length)throw new Tb(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new Tb(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Tb(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=Bp(e,[0,2,1])),"causal"===s)throw new Nb("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Kc(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=Oy(o,n)),o}))}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=Ew(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Nb("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],s="valid",a,i){return lu((()=>{if(null==a&&(a="channelsLast"),ay(a),4!==e.rank&&5!==e.rank)throw new Tb(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new Tb(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Nw(e,a);if("causal"===s)throw new Nb("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Qc(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=Oy(o,n)),"channelsFirst"===a&&(o=Bp(o,[0,4,1,2,3])),o}))}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=ox(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=Iw(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:nx(this.kernelInitializer),kernelRegularizer:fw(this.kernelRegularizer),kernelConstraint:Fx(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new Tb(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Aw extends Rw{constructor(e){super(2,e),Aw.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Hb(e.kernelSize,"number",1,2))throw new Tb(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Aw.className="Conv2D",Cf(Aw);class _w extends Rw{constructor(e){super(3,e),_w.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Tb(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}_w.className="Conv3D",Cf(_w);class Ow extends Aw{constructor(e){if(super(e),this.inputSpec=[new px({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Tb(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=ox(e)).length)throw new Tb("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Tb("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new px({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return lu((()=>{let t=ix(e);if(4!==t.shape.length)throw new Tb(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],h=this.strides[1],d=[r,Cw(i,c,l,this.padding),Cw(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Bp(t,[0,2,3,1]));let p=Yc(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Bp(p,[0,3,1,2])),null!=this.bias&&(p=Oy(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=ox(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=Cw(t[r],o,a,this.padding),t[s]=Cw(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Ow.className="Conv2DTranspose",Cf(Ow);class Dw extends _w{constructor(e){if(super(e),this.inputSpec=[new px({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Tb(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=ox(e)).length)throw new Tb("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Tb("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new px({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return lu((()=>{let t=ix(e);if(5!==t.shape.length)throw new Tb(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],l=n[s],u=n[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[r,Cw(o,p,c,this.padding),Cw(l,f,h,this.padding),Cw(u,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Bp(t,[0,2,3,4,1]));let b=Zc(t,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Bp(b,[0,4,1,2,3])),null!==this.bias&&(b=Oy(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(e){const t=(e=ox(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[r]=Cw(t[r],u,i,this.padding),t[s]=Cw(t[s],c,o,this.padding),t[a]=Cw(t[a],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Dw.className="Conv3DTranspose",Cf(Dw);class Fw extends Rw{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Tb("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Tb("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Tb(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=rx(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=mw(t.depthwiseRegularizer),this.depthwiseConstraint=zx(t.depthwiseConstraint),this.pointwiseInitializer=rx(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=mw(t.pointwiseRegularizer),this.pointwiseConstraint=zx(t.pointwiseConstraint)}build(e){if((e=ox(e)).length<this.rank+2)throw new Tb(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Tb(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new px({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return lu((()=>{let t;if(e=ix(e),1===this.rank)throw new Nb("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Bp(e,[0,2,3,1])),t=cp(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Oy(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Bp(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=nx(this.depthwiseInitializer),e.pointwiseInitializer=nx(this.pointwiseInitializer),e.depthwiseRegularizer=fw(this.depthwiseRegularizer),e.pointwiseRegularizer=fw(this.pointwiseRegularizer),e.depthwiseConstraint=Fx(this.depthwiseConstraint),e.pointwiseConstraint=Fx(this.pointwiseConstraint),e}}Fw.className="SeparableConv";class Lw extends Fw{constructor(e){super(2,e)}}Lw.className="SeparableConv2D",Cf(Lw);class zw extends Rw{constructor(e){super(1,e),zw.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Hb(e.kernelSize,"number",1,1))throw new Tb(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}zw.className="Conv1D",Cf(zw);class Mw extends yx{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return lu((()=>{if(e=ix(e),"channelsLast"===this.dataFormat){const t=Iy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Iy(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Iy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Iy(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Mw.className="Cropping2D",Cf(Mw);class Pw extends yx{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ay(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,Gb(ey,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return lu((()=>{let t=ix(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Bp(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?xf.resizeNearestNeighbor(t,[e,r]):xf.resizeBilinear(t,[e,r]);return Bp(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?xf.resizeNearestNeighbor(t,[e,r]):xf.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Pw.className="UpSampling2D",Cf(Pw);class Bw extends $w{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=rx(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=zx(e.depthwiseConstraint),this.depthwiseRegularizer=mw(e.depthwiseRegularizer)}build(e){if((e=ox(e)).length<4)throw new Tb(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Tb(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return lu((()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return lu((()=>{null==s&&(s="channelsLast"),ay(s);let i=Tw(e,s);if(4!==e.rank)throw new Tb(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new Tb(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=ih(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=Bp(i,[0,3,1,2])),i}))}(e=ix(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Oy(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=ox(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Iw(t,this.kernelSize[0],this.padding,this.strides[0]),a=Iw(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=nx(this.depthwiseInitializer),e.depthwiseRegularizer=fw(this.depthwiseRegularizer),e.depthwiseConstraint=Fx(this.depthwiseRegularizer),e}}function Uw(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new Tb("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function Ww(e,t,n,r=!1,s,a,i=!1,o=!1){return lu((()=>{const a=t.shape.length;if(a<3)throw new Tb(`Input should be at least 3D, but is ${a}D.`);const l=[1,0].concat(by(2,a));t=Bp(t,l),i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=ju(ju(s,"bool"),"float32")).rank===a-1&&(s=Mh(s,-1)),s=Bp(s,l)),r&&(t=ip(t,0),null!=s&&(s=ip(s,0)));const u=[];let c,h=n;const d=t.shape[0],p=Mp(t);let f,g;null!=s&&(f=Mp(s));for(let t=0;t<d;++t){const n=p[t],r=lu((()=>e(n,h)));if(null==s)c=r[0],h=r[1];else{const e=lu((()=>{const e=f[t],n=id(Cd(e),e);return{output:Ku(Qu(r[0],e),Qu(h[0],n)),newStates:h.map(((t,s)=>Ku(Qu(r[1][s],e),Qu(t,n))))}}));c=e.output,h=e.newStates}o&&u.push(c)}return o&&(g=Tp(u,1)),[c,g,h]}))}Bw.className="DepthwiseConv2D",Cf(Bw);class Vw extends yx{constructor(e){let t;if(super(e),null==e.cell)throw new Tb("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new Qw({cells:e.cell}):e.cell,null==t.stateSize)throw new Tb("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new px({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?by(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null)):this.states_}setStates(e){this.states_=e}computeOutputShape(e){sx(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return lu((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Nb("Constants support is not implemented in RNN yet.");sx(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new px({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!zr(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new Tb(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new px({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){lu((()=>{if(!this.stateful)throw new Ib("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Tb("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>bd([n,e]))):this.states_=[bd([n,this.cell.stateSize])];else if(null==e)uu(this.states_),null!=this.keptStates&&(uu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>bd([n,e]))):this.states_[0]=bd([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Tb(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):uu(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!zr(r.shape,a))throw new Tb(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>cu(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=Uw(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new px({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof fx){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return lu((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=ix(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new Tb(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=Ww(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,0,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h}))}getInitialState(e){return lu((()=>{let t=bd(e.shape);return t=Oh(t,[1,2]),t=wy(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Ny(t,[1,e]):t)):this.cell.stateSize>1?[Ny(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===Vw.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=Yx(t.cell,n);return new e(Object.assign(t,{cell:r}))}}Vw.className="RNN",Cf(Vw);class Gw extends yx{}class Hw extends Gw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,jb(this.units,"units"),this.activation=cw(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mw(e.kernelRegularizer),this.recurrentRegularizer=mw(e.recurrentRegularizer),this.biasRegularizer=mw(e.biasRegularizer),this.kernelConstraint=zx(e.kernelConstraint),this.recurrentConstraint=zx(e.recurrentConstraint),this.biasConstraint=zx(e.biasConstraint),this.dropout=gy([1,my([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gy([1,my([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=ox(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return lu((()=>{if(2!==e.length)throw new Tb(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jw({ones:()=>Cd(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jw({ones:()=>Cd(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=$y(null!=a?Qu(e,a):e,this.kernel.read()),null!=this.bias&&(s=Oy(s,this.bias.read())),null!=i&&(n=Qu(n,i));let o=Ku(s,$y(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:lw(this.activation),useBias:this.useBias,kernelInitializer:nx(this.kernelInitializer),recurrentInitializer:nx(this.recurrentInitializer),biasInitializer:nx(this.biasInitializer),kernelRegularizer:fw(this.kernelRegularizer),recurrentRegularizer:fw(this.recurrentRegularizer),biasRegularizer:fw(this.biasRegularizer),activityRegularizer:fw(this.activityRegularizer),kernelConstraint:Fx(this.kernelConstraint),recurrentConstraint:Fx(this.recurrentConstraint),biasConstraint:Fx(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}Hw.className="SimpleRNNCell",Cf(Hw);class jw extends Vw{constructor(e){e.cell=new Hw(e),super(e)}call(e,t){return lu((()=>{null!=this.cell.dropoutMask&&(uu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(uu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}jw.className="SimpleRNN",Cf(jw);class qw extends Gw{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Tb("GRUCell does not support reset_after parameter set to true.");this.units=e.units,jb(this.units,"units"),this.activation=cw(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cw(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=mw(e.kernelRegularizer),this.recurrentRegularizer=mw(e.recurrentRegularizer),this.biasRegularizer=mw(e.biasRegularizer),this.kernelConstraint=zx(e.kernelConstraint),this.recurrentConstraint=zx(e.recurrentConstraint),this.biasConstraint=zx(e.biasConstraint),this.dropout=gy([1,my([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gy([1,my([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=ox(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return lu((()=>{if(2!==e.length)throw new Tb(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jw({ones:()=>Cd(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jw({ones:()=>Cd(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=Qu(e,s[0]));let u=$y(e,this.kernel.read());this.useBias&&(u=Oy(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Qu(r,a[0]));const c=this.recurrentKernel.read(),[h,d]=kp(c,[2*this.units,this.units],c.rank-1),p=$y(r,h),[f,g,m]=kp(u,3,u.rank-1),[b,y]=kp(p,2,p.rank-1);i=this.recurrentActivation.apply(Ku(f,b)),o=this.recurrentActivation.apply(Ku(g,y));const x=$y(Qu(o,r),d);l=this.activation.apply(Ku(m,x));const v=Ku(Qu(i,r),Qu(Ku(1,rd(i)),l));return[v,v]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:lw(this.activation),recurrentActivation:lw(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nx(this.kernelInitializer),recurrentInitializer:nx(this.recurrentInitializer),biasInitializer:nx(this.biasInitializer),kernelRegularizer:fw(this.kernelRegularizer),recurrentRegularizer:fw(this.recurrentRegularizer),biasRegularizer:fw(this.biasRegularizer),activityRegularizer:fw(this.activityRegularizer),kernelConstraint:Fx(this.kernelConstraint),recurrentConstraint:Fx(this.recurrentConstraint),biasConstraint:Fx(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}qw.className="GRUCell",Cf(qw);class Kw extends Vw{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new qw(e),super(e)}call(e,t){return lu((()=>{null!=this.cell.dropoutMask&&(uu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(uu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Kw.className="GRU",Cf(Kw);class Xw extends Gw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,jb(this.units,"units"),this.activation=cw(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cw(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rx(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=mw(e.kernelRegularizer),this.recurrentRegularizer=mw(e.recurrentRegularizer),this.biasRegularizer=mw(e.biasRegularizer),this.kernelConstraint=zx(e.kernelConstraint),this.recurrentConstraint=zx(e.recurrentConstraint),this.biasConstraint=zx(e.biasConstraint),this.dropout=gy([1,my([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gy([1,my([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=ox(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends My{apply(t,r){const s=e.apply([n]),a=(new By).apply([n]),i=e.apply([2*n]);return Ty(Ty(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return lu((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new Tb(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jw({ones:()=>Cd(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jw({ones:()=>Cd(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=Qu(e,a[0]));let h=$y(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Qu(r,i[0])),h=Ku(h,$y(r,this.recurrentKernel.read())),this.useBias&&(h=Oy(h,this.bias.read()));const[d,p,f,g]=kp(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),u=Ku(Qu(l,s),Qu(o,this.activation.apply(f))),c=this.recurrentActivation.apply(g);const m=Qu(c,this.activation.apply(u));return[m,m,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:lw(this.activation),recurrentActivation:lw(this.recurrentActivation),useBias:this.useBias,kernelInitializer:nx(this.kernelInitializer),recurrentInitializer:nx(this.recurrentInitializer),biasInitializer:nx(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:fw(this.kernelRegularizer),recurrentRegularizer:fw(this.recurrentRegularizer),biasRegularizer:fw(this.biasRegularizer),activityRegularizer:fw(this.activityRegularizer),kernelConstraint:Fx(this.kernelConstraint),recurrentConstraint:Fx(this.recurrentConstraint),biasConstraint:Fx(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Xw.className="LSTMCell",Cf(Xw);class Yw extends Vw{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Xw(e),super(e)}call(e,t){return lu((()=>{null!=this.cell.dropoutMask&&(uu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(uu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Yw.className="LSTM",Cf(Yw);class Qw extends Gw{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return lu((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;sx(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{uy(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){const r=[];for(const s of t.cells)r.push(Yx(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return hx(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}dx(t)}}function Jw(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):Dy(t(),n),o=()=>Fy(i,t,r);return!s||s<=1?cu(o().clone()):Array(s).fill(void 0).map(o).map((e=>cu(e.clone())))}Qw.className="StackedRNNCells",Cf(Qw);class Zw extends Vw{constructor(e){if(e.unroll)throw new Nb("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Nb("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new px({ndim:5})]}call(e,t){return lu((()=>{if(null!=this.cell.dropoutMask&&(uu(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(uu(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Tb("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return lu((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=bd([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){lu((()=>{if(!this.stateful)throw new Ib("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new Tb("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>bd(s))):this.states_=[bd(s)];else if(null==e)uu(this.states_),null!=this.keptStates&&(uu(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>bd(s))):this.states_[0]=bd(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Tb(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):uu(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!zr(n.shape,r))throw new Tb(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>cu(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=Iw(l,r[0],s,a[0],i[0]),h=Iw(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}}Zw.className="ConvRNN2D";class ek extends Xw{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,jb(this.filters,"filters"),this.kernelSize=Sw(n,2,"kernelSize"),this.kernelSize.forEach((e=>jb(e,"kernelSize"))),this.strides=Sw(r||1,2,"strides"),this.strides.forEach((e=>jb(e,"strides"))),this.padding=s||"valid",iy(this.padding),this.dataFormat=a||"channelsLast",ay(this.dataFormat),this.dilationRate=Sw(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>jb(e,"dilationRate")))}build(e){var t;e=ox(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Tb(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends My{apply(e,t){return Cy([n.apply([r]),yd([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return lu((()=>{if(3!==e.length)throw new Tb(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Jw({ones:()=>Cd(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?Qu(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),h=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Jw({ones:()=>Cd(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(s,d,0),f=o(s,d,1),g=o(s,d,2),m=o(s,d,3);const[b,y,x,v]=kp(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?kp(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,w,this.padding),u=this.inputConv(u,y,k,this.padding),c=this.inputConv(c,x,S,this.padding),h=this.inputConv(h,v,I,this.padding);const[C,T,N,E]=kp(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,T),g=this.recurrentConv(g,N),m=this.recurrentConv(m,E);const $=this.recurrentActivation.apply(Ku(l,p)),R=this.recurrentActivation.apply(Ku(u,f)),A=Ku(Qu(R,a),Qu($,this.activation.apply(Ku(c,g)))),_=Qu(this.recurrentActivation.apply(Ku(h,m)),this.activation.apply(A));return[_,_,A]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=qc(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Oy(s,n,this.dataFormat):s}recurrentConv(e,t){return qc(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}ek.className="ConvLSTM2DCell",Cf(ek);class tk extends Zw{constructor(e){const t=new ek(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}tk.className="ConvLSTM2D",Cf(tk);class nk extends yx{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return lu((()=>{this.invokeCallHook(e,t);const n=ix(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return Fy((()=>Dy(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}nk.className="Dropout",Cf(nk);class rk extends nk{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}rk.className="SpatialDropout1D",Cf(rk);class sk extends yx{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,jb(this.units,"units"),this.activation=cw(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=rx(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=rx(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=zx(e.kernelConstraint),this.biasConstraint=zx(e.biasConstraint),this.kernelRegularizer=mw(e.kernelRegularizer),this.biasRegularizer=mw(e.biasRegularizer),this.activityRegularizer=mw(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=ox(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=ox(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return lu((()=>{this.invokeCallHook(e,t);const n=ix(e),r=Kb(this.activation.getClassName());let s;return null!=r?s=$y(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=$y(n,this.kernel.read()),null!=this.bias&&(s=Oy(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:lw(this.activation),useBias:this.useBias,kernelInitializer:nx(this.kernelInitializer),biasInitializer:nx(this.biasInitializer),kernelRegularizer:fw(this.kernelRegularizer),biasRegularizer:fw(this.biasRegularizer),activityRegularizer:fw(this.activityRegularizer),kernelConstraint:Fx(this.kernelConstraint),biasConstraint:Fx(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}sk.className="Dense",Cf(sk);class ak extends yx{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=ox(e);for(const t of e.slice(1))if(null==t)throw new Tb(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],fy(e,1)]}call(e,t){return lu((()=>{this.invokeCallHook(e,t);let n=ix(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Bp(n,e)}return function(e){if(e.rank<=1)throw new Tb(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],fy(e.shape,1)];return Cc(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}ak.className="Flatten",Cf(ak);class ik extends yx{constructor(e){super(e),this.supportsMasking=!0,this.activation=cw(e.activation)}call(e,t){return lu((()=>{this.invokeCallHook(e,t);const n=ix(e);return this.activation.apply(n)}))}getConfig(){const e={activation:lw(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}ik.className="Activation",Cf(ik);class ok extends yx{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return lu((()=>{return e=ix(e),t=e,n=this.n,lu((()=>{if(2!==t.shape.length)throw new Tb(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return Ny(wy(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}ok.className="RepeatVector",Cf(ok);class lk extends yx{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==a)throw new Tb("Can only specifiy one unknown dimension.");a=o}else s*=e}const i=fy(e);if(null!==a){if(0===s||i%s!=0)throw new Tb(n);r[a]=i/s}else if(i!==s)throw new Tb(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return lu((()=>{this.invokeCallHook(e,t);const n=ix(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Cc(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}lk.className="Reshape",Cf(lk);class uk extends yx{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=by(1,e.dims.length+1);if(!zr(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new px({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=ox(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return Bp(ix(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}uk.className="Permute",Cf(uk);class ck extends yx{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=ix(e);return nc(Sd(n,this.maskValue),-1)}call(e,t){return lu((()=>{this.invokeCallHook(e,t);const n=ix(e),r=nc(Sd(n,this.maskValue),-1,!0);return Qu(n,ju(r,n.dtype))}))}}ck.className="Masking",Cf(ck);class hk extends yx{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Db(e.inputLength))}this.inputDim=e.inputDim,jb(this.inputDim,"inputDim"),this.outputDim=e.outputDim,jb(this.outputDim,"outputDim"),this.embeddingsInitializer=rx(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=mw(e.embeddingsRegularizer),this.activityRegularizer=mw(e.activityRegularizer),this.embeddingsConstraint=zx(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return lu((()=>this.maskZero?(e=ix(e),Sd(e,ph(e))):null))}computeOutputShape(e){if(e=ox(e),null==this.inputLength)return[...e,this.outputDim];const t=Db(this.inputLength);if(t.length!==e.length-1)throw new Tb(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new Tb(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return lu((()=>{this.invokeCallHook(e,t);let n=ix(e);"int32"!==n.dtype&&(n=vy(n,"int32"));const r=Ry(this.embeddings.read(),Cc(n,[n.size]));return Cc(r,ox(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:nx(this.embeddingsInitializer),embeddingsRegularizer:fw(this.embeddingsRegularizer),activityRegularizer:fw(this.activityRegularizer),embeddingsConstraint:Fx(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}hk.className="Embedding",Cf(hk);class dk extends yx{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Nb}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new Tb("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[ox(e)]),e.length<2)throw new Tb(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=Wb(t),t.length>1)throw new Tb(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===Wb(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return lu((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=my(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=wy(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,r=e[0],s=e.slice(1).concat([r]);let i=Cc(a,[r].concat(fy(e.slice(1))));i=Bp(i,[1,0]),i=Cc(i,s),t.push(i),n=!0}else if(e>1){const r=by(1,e).concat([0]);t.push(Bp(a,r)),n=!0}else t.push(a)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Cc(Bp(Cc(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(by(0,s-1));r=Bp(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=Wb(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return lu((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Tb("`mask` should be an Array");if(!Array.isArray(e))throw new Tb("`inputs` should be an Array");if(t.length!==e.length)throw new Tb(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Mh(e,0))))[0];for(let e=1;e<t.length-1;++e)n=ud(n,t[e]);return n}))}}class pk extends dk{constructor(e){super(e)}mergeFunction(e){return lu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ku(t,e[n]);return t}))}}pk.className="Add",Cf(pk);class fk extends dk{constructor(e){super(e)}mergeFunction(e){return lu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Qu(t,e[n]);return t}))}}fk.className="Multiply",Cf(fk);class gk extends dk{constructor(e){super(e)}mergeFunction(e){return lu((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Ku(t,e[n]);return Qu(1/e.length,t)}))}}gk.className="Average",Cf(gk);class mk extends dk{constructor(e){super(e)}mergeFunction(e){return lu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=gd(t,e[n]);return t}))}}mk.className="Maximum",Cf(mk);class bk extends dk{constructor(e){super(e)}mergeFunction(e){return lu((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=xd(t,e[n]);return t}))}}bk.className="Minimum",Cf(bk);class yk extends dk{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Tb("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(zr(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new Tb("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return lu((()=>Cy(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Tb("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Tb("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Tb("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Tb(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return lu((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let a=0;a<e.length;++a)null==t[a]?r.push(ju(Cd(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Mh(t[a],-1)):r.push(t[a]);const s=Ec(r,this.axis);return tc(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function xk(e,t){for(;e<0;)e+=t;return e}yk.className="Concatenate",Cf(yk);class vk extends dk{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Or(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Nb("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new Tb(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new Tb(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>xk(t,e[n].shape.length))):[xk(this.axes,n.shape.length),xk(this.axes,r.shape.length)],this.normalize&&(n=Qx(n,t[0]),r=Qx(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Nb("batchDot is not implemented for tensors of 4D or higher rank yet");if(Or(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Or(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Nb("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return lu((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=Cc(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Cc(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?Oh(Qu(e,t),a[0]):Oh(Qu(Bp(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=$c(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=Cp(i,t)}return 1===i.shape.length&&(i=Mh(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[xk(this.axes,e.length),xk(this.axes,t.length)],n}computeOutputShape(e){Or(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Nb("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}vk.className="Dot",Cf(vk);class wk extends yx{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return lu((()=>{this.invokeCallHook(e,t);const n=ix(e);return Fy((()=>Ku(Ey(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}wk.className="GaussianNoise",Cf(wk);class kk extends yx{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return lu((()=>{this.invokeCallHook(e,t);const n=ix(e);return this.rate>0&&this.rate<1?Fy((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Qu(n,Ey(n.shape,1,e))}),(()=>n),t.training||!1):n}))}}kk.className="GaussianDropout",Cf(kk);class Sk extends yx{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ix(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return lu((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e);return Fy((()=>{const t=ix(e),r=-1.7580993408473766;let s=Hh(ep(n),this.rate);s=vy(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=Ku(Qu(t,s),Qu(Ku(s,-1),r));return Ku(Qu(o,a),i)}),(()=>ix(e)),t.training||!1)}return e}))}}function Ik(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=Fc(e,t,n,r,s,a);else if(3===e.rank)i=Lc(e,t,n,r,s,a);else{if(4!==e.rank)throw new Nb(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=zc(e,t,n,r,s,a)}return i}Sk.className="AlphaDropout",Cf(Sk);class Ck extends yx{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rx(e.betaInitializer||"zeros"),this.gammaInitializer=rx(e.gammaInitializer||"ones"),this.movingMeanInitializer=rx(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=rx(e.movingVarianceInitializer||"ones"),this.betaConstraint=zx(e.betaConstraint),this.gammaConstraint=zx(e.gammaConstraint),this.betaRegularizer=mw(e.betaRegularizer),this.gammaRegularizer=mw(e.gammaRegularizer)}build(e){e=ox(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Tb(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new px({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return lu((()=>{const n=null!=t.training&&t.training,r=ix(e),s=r.shape,a=s.length,i=by(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=Rb(1,a);l[o]=s[o];const u=i.slice();u.sort();const c=!zr(u,by(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=Cc(this.movingMean.read(),l),t=Cc(this.movingVariance.read(),l),n=this.center?Cc(this.beta.read(),l):null,s=this.scale?Cc(this.gamma.read(),l):null;return Ik(r,e,t,n,s,this.epsilon)}return Ik(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=function(e,t,n,r,s=.001){return zr(r.slice().sort(),by(0,e.rank-1))?function(e,t,n,r,s=.001){return lu((()=>{const a=kd(e,r),i=a.mean,o=a.variance;return[Ik(e,i,o,n,t,s),i,o]}))}(e,t,n,r,s):function(e,t,n,r,s=.001){return lu((()=>{const a=kd(e,r),i=a.mean,o=a.variance,l=[];for(const t of by(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Cc(i,l),c=Cc(o,l),h=null==t?null:Cc(t,l),d=null==n?null:Cc(n,l);return[Ik(e,u,c,d,h,s),i,o]}))}(e,t,n,r,s)}(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{lu((()=>{const r=1-n,s=e.read(),a=Qu(id(s,t),r);e.write(id(s,a))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nx(this.betaInitializer),gammaInitializer:nx(this.gammaInitializer),movingMeanInitializer:nx(this.movingMeanInitializer),movingVarianceInitializer:nx(this.movingVarianceInitializer),betaRegularizer:fw(this.betaRegularizer),gammaRegularizer:fw(this.gammaRegularizer),betaConstraint:Fx(this.betaConstraint),gammaConstraint:Fx(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}Ck.className="BatchNormalization",Cf(Ck);class Tk extends yx{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rx(e.betaInitializer||"zeros"),this.gammaInitializer=rx(e.gammaInitializer||"ones"),this.betaRegularizer=mw(e.betaRegularizer),this.gammaRegularizer=mw(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=ox(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Wb(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=ix(e),r=n.shape,s=r.length;return lu((()=>{let{mean:e,variance:t}=kd(n,this.axis,!0);const a=Rb(1,s);for(const n of this.axis)a[n]=r[n];const i=e=>null!=e&&e.shape.length!==s?Cc(e,a):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=Bh(e,u),t=Bh(t,u),null!=o&&(o=Bh(o,c)),null!=l&&(l=Bh(l,c)),Ik(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:nx(this.betaInitializer),gammaInitializer:nx(this.gammaInitializer),betaRegularizer:fw(this.betaRegularizer),gammaRegularizer:fw(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Tk.className="LayerNormalization",Cf(Tk);class Nk extends yx{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Tb(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Tb(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new Tb(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new px({ndim:4})]}computeOutputShape(e){let t,n;return e=ox(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return lu((()=>{return t=ix(e),n=this.padding,r=this.dataFormat,lu((()=>{if(4!==t.rank)throw new Tb(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Tb("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new Tb(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Td(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function Ek(e,t,n,r,s,a){return lu((()=>{let i;ay(s),oy(a),iy(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=Tw(e,s);const o="same"===r?"same":"valid";return i="max"===a?pd(e,t,n,o):Tc(e,t,n,o),"channelsFirst"===s&&(i=Bp(i,[0,3,1,2])),i}))}function $k(e,t,n,r,s,a){return lu((()=>{let i;ay(s),oy(a),iy(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=Nw(e,s);const o="same"===r?"same":"valid";return i="max"===a?fd(e,t,n,o):Nc(e,t,n,o),"channelsFirst"===s&&(i=Bp(i,[0,4,1,2,3])),i}))}Nk.className="ZeroPadding2D",Cf(Nk);class Rk extends yx{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new Tb(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(jb(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new Tb(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}jb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,iy(this.padding),this.inputSpec=[new px({ndim:3})]}computeOutputShape(e){const t=Iw((e=ox(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return lu((()=>{this.invokeCallHook(e,t),e=wy(ix(e),2);const n=this.poolingFunction(ix(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Cp(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Ak extends Rk{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ay(s),iy(r),Ek(e,t,n,r,s,"max")}}Ak.className="MaxPooling1D",Cf(Ak);class _k extends Rk{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ay(s),iy(r),Ek(e,t,n,r,s,"avg")}}_k.className="AveragePooling1D",Cf(_k);class Ok extends yx{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Tb(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];jb(this.poolSize,"poolSize"),jb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ay(this.dataFormat),iy(this.padding),this.inputSpec=[new px({ndim:4})]}computeOutputShape(e){e=ox(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Iw(t,this.poolSize[0],this.padding,this.strides[0]),n=Iw(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return lu((()=>(this.invokeCallHook(e,t),this.poolingFunction(ix(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Dk extends Ok{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ay(s),iy(r),Ek(e,t,n,r,s,"max")}}Dk.className="MaxPooling2D",Cf(Dk);class Fk extends Ok{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ay(s),iy(r),Ek(e,t,n,r,s,"avg")}}Fk.className="AveragePooling2D",Cf(Fk);class Lk extends yx{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Tb(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];jb(this.poolSize,"poolSize"),jb(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ay(this.dataFormat),iy(this.padding),this.inputSpec=[new px({ndim:5})]}computeOutputShape(e){e=ox(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Iw(t,this.poolSize[0],this.padding,this.strides[0]),n=Iw(n,this.poolSize[1],this.padding,this.strides[1]),r=Iw(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return lu((()=>(this.invokeCallHook(e,t),this.poolingFunction(ix(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class zk extends Lk{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ay(s),iy(r),$k(e,t,n,r,s,"max")}}zk.className="MaxPooling3D",Cf(zk);class Mk extends Lk{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ay(s),iy(r),$k(e,t,n,r,s,"avg")}}Mk.className="AveragePooling3D",Cf(Mk);class Pk extends yx{constructor(e){super(e),this.inputSpec=[new px({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Nb}}class Bk extends Pk{constructor(e){super(e||{})}call(e,t){return lu((()=>{const t=ix(e);return md(t,1)}))}}Bk.className="GlobalAveragePooling1D",Cf(Bk);class Uk extends Pk{constructor(e){super(e||{})}call(e,t){return lu((()=>{const t=ix(e);return Nh(t,1)}))}}Uk.className="GlobalMaxPooling1D",Cf(Uk);class Wk extends yx{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ay(this.dataFormat),this.inputSpec=[new px({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Nb}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Vk extends Wk{call(e,t){return lu((()=>{const t=ix(e);return"channelsLast"===this.dataFormat?md(t,[1,2]):md(t,[2,3])}))}}Vk.className="GlobalAveragePooling2D",Cf(Vk);class Gk extends Wk{call(e,t){return lu((()=>{const t=ix(e);return"channelsLast"===this.dataFormat?Nh(t,[1,2]):Nh(t,[2,3])}))}}Gk.className="GlobalMaxPooling2D",Cf(Gk);class Hk extends yx{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=Yx(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class jk extends Hk{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=ox(e)).length<3)throw new Tb(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=ox(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return lu((()=>Ww(((e,n)=>[ix(this.layer.call(e,t)),[]]),e=ix(e),[],!1,null,0,!1,!0)[1]))}}jk.className="TimeDistributed",Cf(jk);class qk extends Hk{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Yx(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Yx(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,Gb(ry,"BidirectionalMergeMode",s),e.weights)throw new Nb("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):Ob(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=Uw(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new Tb("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new px({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new Nb("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof fx;for(const l of a)if(l instanceof fx!==o)throw new Tb("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return lu((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=ip(s,1)),"concat"===this.mergeMode?i=Cy([r,s]):"sum"===this.mergeMode?i=Ku(r,s):"ave"===this.mergeMode?i=Qu(.5,Ku(r,s)):"mul"===this.mergeMode?i=Qu(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){uy(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),uy(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=Yx(t.layer);if(delete t.layer,null!=t.numConstants)throw new Nb("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}qk.className="Bidirectional",Cf(qk);class Kk extends yx{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return lu((()=>("float32"!==(e=ix(e)).dtype&&(e=vy(e,"float32")),Ku(Qu(e,this.scale),this.offset))))}}Kk.className="Rescaling",Cf(Kk);const{resizeBilinear:Xk,cropAndResize:Yk}=xf;class Qk extends yx{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return lu((()=>{let l,u=!1;const c=[t/a,n/i,(r+t)/a,(s+n)/i],h=[];3===e.rank?(u=!0,l=Tp([e])):l=e;for(let e=0;e<l.shape[0];e++)h.push(c);const d=ru(h,[h.length,4]),p=tp(0,h.length,1,"int32"),f=Yk(l,d,p,[r,s],"nearest");return vy(u?ix(Mp(f)):f,o)}))}upsize(e,t,n,r){return lu((()=>vy(Xk(e,[t,n]),r)))}call(e,t){return lu((()=>{const t=ix(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=ox(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}Qk.className="CenterCrop",Cf(Qk);class Jk extends yx{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=ox(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return lu((()=>{let n;if("int32"!==(e=ix(e)).dtype&&(e=vy(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new Tb(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=ix(t.countWeights)}const r=Nh(e),s=Eh(e),a=Gh(this.numTokens,r).bufferSync().get(0),i=Hh(s,0).bufferSync().get(0);if(!a||!i)throw new Tb(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=ix(e);if("int32"!==s.dtype&&(s=vy(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=Mh(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=Mh(s,-1)),s.rank>2)throw new Tb(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t);let o;if(o=sh(s,void 0!==r&&"count"===t?r:[],n,i),"tfIdf"!==t)return o;if(r)return Qu(o,r);throw new Tb("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}Jk.className="CategoryEncoding",Cf(Jk);const Zk=new Set(["bilinear","nearest"]);class eS extends yx{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!Zk.has(e.interpolation))throw new Tb(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=ox(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return lu((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return xf.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return xf.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Zk]} are supported`)}))}}eS.className="Resizing",Cf(eS);class tS{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}tS.className="RandomSeed";class nS extends yx{constructor(e){super(e),this.randomGenerator=new tS(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}nS.className="BaseRandomLayer";const rS=new Set(["bilinear","nearest"]);class sS extends nS{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new Tb(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new Tb(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Tb(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!rS.has(n))throw new Tb(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=ox(e))[2];return[this.imgHeight,-1,t]}call(e,t){return lu((()=>{const t=ix(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=ep([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return xf.resizeBilinear(e,s);case"nearest":return xf.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...rS]} are supported`)}}))}}var aS,iS,oS,lS,uS,cS,hS;function dS(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Or("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}sS.className="RandomWidth",Cf(sS),ps().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),(iS=aS||(aS={}))[iS.DT_INVALID=0]="DT_INVALID",iS[iS.DT_FLOAT=1]="DT_FLOAT",iS[iS.DT_DOUBLE=2]="DT_DOUBLE",iS[iS.DT_INT32=3]="DT_INT32",iS[iS.DT_UINT8=4]="DT_UINT8",iS[iS.DT_INT16=5]="DT_INT16",iS[iS.DT_INT8=6]="DT_INT8",iS[iS.DT_STRING=7]="DT_STRING",iS[iS.DT_COMPLEX64=8]="DT_COMPLEX64",iS[iS.DT_INT64=9]="DT_INT64",iS[iS.DT_BOOL=10]="DT_BOOL",iS[iS.DT_QINT8=11]="DT_QINT8",iS[iS.DT_QUINT8=12]="DT_QUINT8",iS[iS.DT_QINT32=13]="DT_QINT32",iS[iS.DT_BFLOAT16=14]="DT_BFLOAT16",iS[iS.DT_QINT16=15]="DT_QINT16",iS[iS.DT_QUINT16=16]="DT_QUINT16",iS[iS.DT_UINT16=17]="DT_UINT16",iS[iS.DT_COMPLEX128=18]="DT_COMPLEX128",iS[iS.DT_HALF=19]="DT_HALF",iS[iS.DT_RESOURCE=20]="DT_RESOURCE",iS[iS.DT_VARIANT=21]="DT_VARIANT",iS[iS.DT_UINT32=22]="DT_UINT32",iS[iS.DT_UINT64=23]="DT_UINT64",iS[iS.DT_FLOAT_REF=101]="DT_FLOAT_REF",iS[iS.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",iS[iS.DT_INT32_REF=103]="DT_INT32_REF",iS[iS.DT_UINT8_REF=104]="DT_UINT8_REF",iS[iS.DT_INT16_REF=105]="DT_INT16_REF",iS[iS.DT_INT8_REF=106]="DT_INT8_REF",iS[iS.DT_STRING_REF=107]="DT_STRING_REF",iS[iS.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",iS[iS.DT_INT64_REF=109]="DT_INT64_REF",iS[iS.DT_BOOL_REF=110]="DT_BOOL_REF",iS[iS.DT_QINT8_REF=111]="DT_QINT8_REF",iS[iS.DT_QUINT8_REF=112]="DT_QUINT8_REF",iS[iS.DT_QINT32_REF=113]="DT_QINT32_REF",iS[iS.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",iS[iS.DT_QINT16_REF=115]="DT_QINT16_REF",iS[iS.DT_QUINT16_REF=116]="DT_QUINT16_REF",iS[iS.DT_UINT16_REF=117]="DT_UINT16_REF",iS[iS.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",iS[iS.DT_HALF_REF=119]="DT_HALF_REF",iS[iS.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",iS[iS.DT_VARIANT_REF=121]="DT_VARIANT_REF",iS[iS.DT_UINT32_REF=122]="DT_UINT32_REF",iS[iS.DT_UINT64_REF=123]="DT_UINT64_REF",(uS=(lS=oS||(oS={})).CheckpointFormatVersion||(lS.CheckpointFormatVersion={}))[uS.LEGACY=0]="LEGACY",uS[uS.V1=1]="V1",uS[uS.V2=2]="V2",(hS=cS||(cS={}))[hS.FAIL=0]="FAIL",hS[hS.SHORTEST=1]="SHORTEST",hS[hS.LONGEST=2]="LONGEST";const pS=Pp;class fS extends Nr{nextDataId(){return fS.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Tr(this,iu())}write(e,t,n){this.firstUse&&(this.firstUse=!1,ps().get("IS_NODE")&&Eo("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Xr(n[0])){const s=n.map((e=>sl(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?$g(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>al(e)));return Hu(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Hu(e.shape,e.dtype,t)}makeOutput(e,t,n){return iu().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=rl();return e(),{kernelMs:rl()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){dS([e],"where");const t=this.readSync(e.dataId);return pS(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function gS(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}fS.nextDataId=0;const mS={kernelName:ys,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;dS(t,"abs");let r=new Float32Array(Lr(t.shape));return r=gS(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function bS(e){return(t,n,r,s,a)=>{const i=ch(t,n),o=i.length,l=es(i),u=Hr(a,Lr(i)),c=t.length,h=n.length,d=es(t),p=es(n),f=lh(t,i),g=lh(n,i);if(f.length+g.length===0)for(let m=0;m<u.length;++m)u[m]=e(r[m%r.length],s[m%s.length]);else for(let m=0;m<u.length;++m){const t=ls(m,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const a=os(n,c,d),i=t.slice(-h);g.forEach((e=>i[e]=0));const b=os(i,h,p);u[m]=e(r[a],s[b])}return[u,i]}}function yS(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const xS={kernelName:Gs,backendName:"cpu",kernelFunc:yS};function vS(e,t,n="float32"){if("complex64"===n)return yS({inputs:{real:vS(e,t,"float32"),imag:vS(e,t,"float32")},backend:e});const r=ss(Lr(t),n);return e.makeTensorInfo(t,n,r)}function wS(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const kS={kernelName:_a,backendName:"cpu",kernelFunc:wS};function SS(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const IS={kernelName:Ci,backendName:"cpu",kernelFunc:SS};function CS(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){const r=nl([0],n),[s,a]=bS(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function TS(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return wS({inputs:{x:s},backend:n});const e=vS(n,s.shape,s.dtype),t=TS({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=yS({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=SS({inputs:{input:s},backend:n}),t=TS({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!qr(s.dtype,a)){const e=wS({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=CS(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const NS={kernelName:Us,backendName:"cpu",kernelFunc:TS};function ES(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:a,b:i}=n,o=s;dS([a,i],e);const l=o.data.get(a.dataId).values,u=o.data.get(i.dataId).values,c="string"===a.dtype?sm(l):l,h="string"===a.dtype?sm(u):u,d=r||a.dtype,[p,f]=t(a.shape,i.shape,c,h,d);return o.makeTensorInfo(f,d,p)}:({inputs:e,backend:s})=>{const{a:a,b:i}=e,o=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=TS({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(s.dataId).values,c=TS({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),h=o.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=o.data.get(d.dataId).values,g=o.data.get(p.dataId).values,[m,b,y]=n(a.shape,i.shape,l,u,f,g),x=o.makeTensorInfo(y,"float32",m),v=o.makeTensorInfo(y,"float32",b),w=yS({inputs:{real:x,imag:v},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(v),w}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,s=r||a.dtype,[l,u]=t(a.shape,i.shape,e,n,s);return o.makeTensorInfo(u,s,l)}}}function $S(e){return(t,n,r,s,a,i)=>{const o=ch(t,n),l=Lr(o),u=o.length,c=es(o),h=Hr("float32",l),d=Hr("float32",l),p=lh(t,o),f=lh(n,o),g=$g(r,s),m=$g(a,i),b=t.length,y=es(t),x=n.length,v=es(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%g.length,n=w%m.length,r=e(g[2*t],g[2*t+1],m[2*n],m[2*n+1]);h[w]=r.real,d[w]=r.imag}else for(let w=0;w<h.length;w++){const t=ls(w,u,c),n=t.slice(-b);p.forEach((e=>n[e]=0));const r=os(n,b,y),s=t.slice(-x);f.forEach((e=>s[e]=0));const a=os(s,x,v),i=e(g[2*r],g[2*r+1],m[2*a],m[2*a+1]);h[w]=i.real,d[w]=i.imag}return[h,d,o]}}const RS=bS(((e,t)=>e+t)),AS=$S(((e,t,n,r)=>({real:e+n,imag:t+r}))),_S=ES(ws,RS,AS),OS={kernelName:ws,backendName:"cpu",kernelFunc:_S};function DS(e,t,n,r,s){const a=Lr(r),i=ss(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=a>0?t[o]:1)}return i}function FS(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=Hu([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const LS=bS(((e,t)=>e&t)),zS={kernelName:Ps,backendName:"cpu",kernelFunc:ES(Ps,LS)};function MS(e){return(t,n,r)=>{const s=jr(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function PS(e,t,n){return BS(e,MS(t),n)}function BS(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;dS(i,e);const o=a,l=o.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=sm(l)}else u=l;const c=n||i.dtype,h=t(u,c,s);return o.makeTensorInfo(i.shape,c,h)}}const US=MS((e=>Math.ceil(e))),WS=BS(Ws,US),VS={kernelName:Ws,backendName:"cpu",kernelFunc:WS};function GS(e,t,n,r){const s=jr(n,Lr(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Lr(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?sm(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}const HS=bS(((e,t)=>e===t?1:0)),jS=ES(ya,HS,null,"bool"),qS={kernelName:ya,backendName:"cpu",kernelFunc:jS},KS=MS((e=>Math.exp(e))),XS=BS(xa,KS,"float32"),YS={kernelName:xa,backendName:"cpu",kernelFunc:XS},QS=MS((e=>Math.expm1(e))),JS=BS(wa,QS),ZS={kernelName:wa,backendName:"cpu",kernelFunc:JS},eI=MS((e=>Math.floor(e))),tI=BS(Ca,eI),nI={kernelName:Ca,backendName:"cpu",kernelFunc:tI},rI=bS(((e,t)=>Math.floor(e/t))),sI=ES(Ta,rI,null,"int32"),aI={kernelName:Ta,backendName:"cpu",kernelFunc:sI};function iI(e,t,n,r,s,a,i,o,l){const u=Hu([r,a],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const a=e[c*s+t];r+=a*i[t],n.push(a)}if(r<0||r>=l/a)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<a;e++)u.values[c*a+e]=t.get(...t.indexToLoc(r*a+e))}return u}function oI(e,t,n){const r=Hu(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),a=n[0],i=n[2],o=t.locToIndex([a,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[s]=e.values[l])}return r}const lI=bS(((e,t)=>e>t?1:0)),uI=ES(Ra,lI,null,"bool"),cI={kernelName:Ra,backendName:"cpu",kernelFunc:uI},hI=bS(((e,t)=>e>=t?1:0)),dI=ES(Aa,hI,null,"bool"),pI={kernelName:Aa,backendName:"cpu",kernelFunc:dI},fI=bS(((e,t)=>e<t?1:0)),gI=ES(Pa,fI,null,"bool"),mI={kernelName:Pa,backendName:"cpu",kernelFunc:gI},bI=bS(((e,t)=>e<=t?1:0)),yI=ES(Ba,bI,null,"bool"),xI={kernelName:Ba,backendName:"cpu",kernelFunc:yI};function vI(e,t,n){const r=(t-e)/(n-1),s=ss(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}const wI=MS((e=>Math.log(e))),kI=BS(Wa,wI),SI={kernelName:Wa,backendName:"cpu",kernelFunc:kI};function II(e,t,n,r){const s=Hr(r,Lr(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[a]=r}return s}const CI=bS(((e,t)=>Math.max(e,t))),TI=ES(Ya,CI),NI={kernelName:Ya,backendName:"cpu",kernelFunc:TI},EI=bS(((e,t)=>Math.min(e,t))),$I=ES(si,EI),RI={kernelName:si,backendName:"cpu",kernelFunc:$I},AI=bS(((e,t)=>e*t)),_I=$S(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),OI=ES(li,AI,_I),DI={kernelName:li,backendName:"cpu",kernelFunc:OI};function FI(e,t,n){const r=tl(-1,n);return AI([],t,r,e,n)}const LI={kernelName:ui,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;dS(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=FI(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},zI=bS(((e,t)=>e!==t?1:0)),MI=ES(ci,zI,null,"bool"),PI={kernelName:ci,backendName:"cpu",kernelFunc:MI};function BI(e,t,n,r,s){const a=t.length,i=Lr(t),o=es(t),l=es(s),u=Hr(n,Lr(s));for(let c=0;c<i;++c){const t=ls(c,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[os(n,a,l)]=e[c]}return u}function UI(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;dS(s,"transpose");const i=s.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=s.shape[a[u]];const l=BI(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(l,o,s.dtype),shape:o,dtype:s.dtype}}const WI={kernelName:yo,backendName:"cpu",kernelFunc:UI};function VI(e,t,n,r){const[s,a]=wh(e,r),i=Ol(t,"int32"),o=ss(Lr(s),i),l=Lr(a);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:s,outDtype:i}}const GI={kernelName:vi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;dS(s,"prod");const o=s.shape.length,l=Vr(a,s.shape),u=Ih(l,o);let c=l,h=s;const d=[];null!=u&&(h=UI({inputs:{x:s},backend:n,attrs:{perm:u}}),d.push(h),c=Th(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:m}=VI(h.shape,h.dtype,p,c);let b=g;return i&&(b=kh(g,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,m,f)}};function HI(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function jI(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const s=ls(r,t.length,es(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:h}=function(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const s=n[e],a=e+t.length-1;if(a>=0){const e=o[a],t=e[e.length-1]-s[r];for(let n=r;n<i;++n)o[a].push(s[n+1]+t)}r=s[r],i=s[i]}i!==r&&(s.push([r,i]),a+=i-r)}return{outSplits:o,valueSlices:s,numValues:a}}(a,i,e,l),d=function(e){const t=[];for(let n=0;n<e.length;++n){const r=jr("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=function(e,t,n,r,s){const a=t.slice();a[0]=s;const i=jr(n,Lr(a)),o=e.length;return function(e,t,n,r,s,a){const i=HI(t,2)[1],o=HI(a,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)s[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,a),[i,a]}(n,r,s,c,h);return[d,p[0],p[1]]}function qI(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===s.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===c.length?1:c[0],d=jr("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const t=o?e[0]:e[g],n=l?r[0]:r[g],s=u?a[0]:a[g];if(0===s)throw new Error("Requires delta != 0");let i;if(s>0&&n<t||s<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/s)),i>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");d[g+1]=d[g]+i}const p=jr(n,d[h]);let f=0;for(let g=0;g<h;++g){const t=d[g+1]-d[g];let n=o?e[0]:e[g];const r=u?a[0]:a[g];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[d,p]}var KI=lg;class XI{constructor(e,t,n,r,s,a,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=hg(u),this.raggedRank=dg(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===KI.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===KI.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case KI.VALUE_ROWIDS:return XI.getMaxWidthValueRowID(t);case KI.ROW_SPLITS:return XI.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${KI[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return QI(e,n)}calculateOutputSize(e){const t=this.valuesShape;pg(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=cg(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let s=1;s<=this.raggedRank;++s)r[s]<0&&(r[s]=this.getMaxWidth(s));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let i=0;i<r;++i,a+=t)s.push(a);for(let i=r;i<e;++i)s.push(-1);return Or(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)a.push(l),l+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){const s=e[u];if(s===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);l=t[s]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case KI.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case KI.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${KI[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case KI.FIRST_DIM_SIZE:return e[0];case KI.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case KI.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${KI[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let a=n.length-2;a>=0;--a)n[a]=n[a+1]*t[a+1];const r=QI(t,!1),s=jr(this.valuesDType,Lr(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)a=this.calculateOutputIndex(e-1,a,n[e],t[e]);this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=Lr(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;lu((()=>{const t=Cc(u,e),n=Pc(t,i);u=n.dataSync()}))}let c=0,h=0,d=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==d){if(h<d){const e=s.subarray(c*o);YI(a.subarray(h*o),e,(d-h)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>d)if(1===this.defaultValue.length)a.subarray(d*o,e*o).fill(this.defaultValue[0]),d=e;else for(;e>d;)YI(a.slice(d*o),u,o),++d;e<0?(c=p+1,h=d):(c=p,h=d,d=h+1)}else++d}}}function YI(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function QI(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function JI(e,t,n,r,s,a,i,o,l,u){return new XI(e,t,n,r,s,a,i,o,l,u).compute()}function ZI(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return ss(0,r);const s=ss(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+n;return s}const eC=MS((e=>1/Math.sqrt(e))),tC=BS(Li,eC),nC={kernelName:Li,backendName:"cpu",kernelFunc:tC};function rC(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],h=e.values,d=t.values;if(0===r)return Hu(n,t.dtype);const p=l instanceof ml?l:Hu(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=h[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[a*s+n]+=d[f*s+n]:p.values[a*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}const sC=MS((e=>1/(1+Math.exp(-e)))),aC=PS(ji,(e=>1/(1+Math.exp(-e)))),iC={kernelName:ji,backendName:"cpu",kernelFunc:aC};function oC(e,t,n,r,s){const a=Qf(r,t,n),i=Lr(n),o=es(r);if(a){const n=Jf(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const l=Hu(r,s,"string"===s?sm(e):e),u=Hu(n,s);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===s?am(u.values):u.values}function lC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;dS(s,"slice");const[o,l]=Zf(s,a,i);Uf(s,o,l);const u=oC(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const uC={kernelName:Wi,backendName:"cpu",kernelFunc:lC};function cC(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),h=t[1];if(0===l){if(0!==o)throw new Error(Hg(o));return[jr(n,0),[0,h],jr(s,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<o;++m){const t=e[m*h];if(t<0)throw new Error(jg(m,t));if(t>=l)throw new Error(qg(m,t,l));++f[t],d=d&&t>=p,p=t}let g=!0;for(let m=0;m<l;++m){const e=0===f[m];u[m]=e,g=g&&!e,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,u,c]}{const t=f[l-1],a=jr(n,t*h),d=jr(s,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*h],s=p[t],i=(0===t?0:f[t-1])+s;p[t]++;for(let r=0;r<h;++r)a[i*h+r]=e[n*h+r];d[i]=r[n],c[n]=i}for(let e=0;e<l;++e)if(0===p[e]){const t=0===e?0:f[e-1];a[t*h+0]=e;for(let e=1;e<h;++e)a[t*h+e]=0;d[t]=i}return[a,[t,h],d,u,c]}}function hC(e,t,n,r,s){const a=Lr(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let g=0;g<o;++g){const e=s[g];if(-1===e){if(-1!==c)throw new Error(Kg(c,g));c=g,l.push(1)}else{if(e<0)throw new Error(Xg(g,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/u);if(u*e!==a)throw new Error(Yg(r,l));l[c]=e}if(Lr(l)!==a)throw new Error(Qg(r,l));const h=r.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=jr(n,i*o);for(let g=0;g<i;++g){let t=0;for(let n=0;n<h;++n)t+=e[g*h+n]*d[n];for(let e=0;e<o;++e)f[g*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}function dC(e,t,n,r,s,a=!1,i=0){const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=jr(n,h.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&d.fill(i),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,g=0,m=s[p];for(;;){let t=0;if(f<o){if(t=s[f],m===t){++f;continue}if(m>=t)throw new Error("segment ids are not increasing")}if(m<0||m>=c)throw new Error(Jg(m,c));m>g&&d.fill(i,g*u,m*u);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(Zg(n,r[n],l[0]));for(let n=0;n<u;n++)d[m*u+n]+=e[t*u+n]}if(a)for(let e=0;e<u;e++)d[m*u+e]/=f-p;if(p=f,++f,g=m+1,m=t,f>o)break}return g<c&&d.fill(i,g*u,c*u),[d,h]}const pC=MS((e=>Math.sqrt(e))),fC=PS(Ki,(e=>Math.sqrt(e))),gC={kernelName:Ki,backendName:"cpu",kernelFunc:fC},mC=bS(((e,t)=>{const n=e-t;return n*n})),bC=ES(so,mC),yC={kernelName:so,backendName:"cpu",kernelFunc:bC},xC=MS(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),vC={kernelName:io,backendName:"cpu",kernelFunc:BS(io,xC)};function wC(e,t,n,r){const s=Hu(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}class kC{constructor(e,t,n,r,s,a){this.separator=sl(e),this.nGramWidths=t,this.leftPad=sl(n),this.rightPad=sl(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),h=t+(l>0?0:i-o);let d=0;d+=l*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const g=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)g(this.leftPad),g(this.separator);for(let t=0;t<c-1;++t)g(e[h+t]),g(this.separator);if(c>0){g(e[h+c-1]);for(let e=0;e<u;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<u-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=jr("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)a[t]=0;return[e,a]}a[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),a[o]=a[o-1]+n}const i=new Array(a[s]);for(let o=0;o<s;++o){const n=t[o];let r=a[o];if(this.nGramWidths.forEach((s=>{const a=t[o+1]-t[o],l=this.getNumNGrams(a,s);this.createNGrams(e,n,i,r,l,s),r+=l})),this.preserveShort&&r===a[o]){const s=t[o+1]-t[o];if(0===s)continue;const a=s+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,a)}}return[i,a]}}function SC(e,t,n,r,s,a,i,o){return new kC(n,r,s,a,i,o).compute(e,t)}function IC(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function CC(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let d=0;d<r;++d){const r=s.length;IC(e[d],t,n,s);const l=s.length-r;o[d]=l,a+=l,i=Math.max(i,l)}const l=jr("int32",2*a),u=new Array(a),c=[r,i];let h=0;for(let d=0;d<r;++d)for(let e=0;e<o[d];++e)l[2*h]=d,l[2*h+1]=e,u[h]=s[h],++h;return[l,u,c]}function TC(e,t){const n=jr("int32",e.length);for(let r=0;r<e.length;++r)n[r]=el(e[r]).modulo(t).getLowBitsUnsigned();return n}const NC=bS(((e,t)=>e-t)),EC=$S(((e,t,n,r)=>({real:e-n,imag:t-r}))),$C=ES(ho,NC,EC),RC={kernelName:ho,backendName:"cpu",kernelFunc:$C};function AC(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=Hu(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}const _C=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function OC(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);OC(e,t,Math.max(n,Math.floor(t-a*o/s+l)),Math.min(r,Math.floor(t+(s-a)*o/s+l)))}const s=e[t];let a=n,i=r;for(_r(e,n,t),_C(e[r],s)>0&&_r(e,n,r);a<i;){for(_r(e,a,i),a++,i--;_C(e[a],s)<0;)a+=1;for(;_C(e[i],s)>0;)i-=1}0===_C(e[n],s)?_r(e,n,i):(i+=1,_r(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function DC(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=Hr(n,i*r),u=Hr("int32",i*r);for(let h=0;h<i;h++){const t=h*o,n=e.subarray(t,t+o);let a=new Array(n.length);n.forEach(((e,t)=>a[t]={value:e,index:t})),r<a.length&&(OC(a,r),a=a.slice(0,r)),s&&a.sort(_C);const i=h*r,c=l.subarray(i,i+r),d=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=a[e].value,d[e]=a[e].index}const c=t.slice();return c[c.length-1]=r,[Hu(c,n,l),Hu(c,"int32",u)]}function FC(e,t,n,r){const s=Vr(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),l=new ml(a,r,e),u=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const h=a.slice();h[1]=i.size;const d=new ml(h,r);u.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)d.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const LC=Object.freeze(Object.defineProperty({__proto__:null,addImpl:RS,bincountImpl:DS,bincountReduceImpl:FS,bitwiseAndImpl:LS,castImpl:CS,ceilImpl:US,concatImpl:GS,equalImpl:HS,expImpl:KS,expm1Impl:QS,floorDivImpl:rI,floorImpl:eI,gatherNdImpl:iI,gatherV2Impl:oI,greaterEqualImpl:hI,greaterImpl:lI,lessEqualImpl:bI,lessImpl:fI,linSpaceImpl:vI,logImpl:wI,maxImpl:II,maximumImpl:CI,minimumImpl:EI,multiplyImpl:AI,negImpl:FI,notEqualImpl:zI,prodImpl:VI,raggedGatherImpl:jI,raggedRangeImpl:qI,raggedTensorToTensorImpl:JI,rangeImpl:ZI,rsqrtImpl:eC,scatterImpl:rC,sigmoidImpl:sC,simpleAbsImpl:gS,sliceImpl:oC,sparseFillEmptyRowsImpl:cC,sparseReshapeImpl:hC,sparseSegmentReductionImpl:dC,sqrtImpl:pC,squaredDifferenceImpl:mC,staticRegexReplaceImpl:xC,stridedSliceImpl:wC,stringNGramsImpl:SC,stringSplitImpl:CC,stringToHashBucketFastImpl:TC,subImpl:NC,tileImpl:AC,topKImpl:DC,transposeImpl:BI,uniqueImpl:FC},Symbol.toStringTag,{value:"Module"}));hu("cpu",(()=>new fS),1);const zC=PS(ga,(e=>e>=0?e:Math.exp(e)-1)),MC={kernelName:ga,backendName:"cpu",kernelFunc:zC};function PC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;dS([s],"leakyRelu");const i=Lr(s.shape),o=n.data.get(s.dataId).values,l=Hr("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const BC={kernelName:Ma,backendName:"cpu",kernelFunc:PC},UC=bS(((e,t)=>e<0?t*e:e));function WC(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;dS([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=UC(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const VC={kernelName:xi,backendName:"cpu",kernelFunc:WC},GC=PS(Ni,(e=>Math.max(0,e))),HC={kernelName:Ni,backendName:"cpu",kernelFunc:GC},jC=PS(Oi,(e=>Math.min(Math.max(0,e),6))),qC={kernelName:Oi,backendName:"cpu",kernelFunc:jC};function KC(e,t,n,r,s){if("linear"===n)return wS({inputs:{x:t},backend:e});if("relu"===n)return GC({inputs:{x:t},backend:e});if("elu"===n)return zC({inputs:{x:t},backend:e});if("relu6"===n)return jC({inputs:{x:t},backend:e});if("prelu"===n)return WC({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return PC({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return aC({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function XC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Lr(s.shape),o=Wr(a,i),l=Lr(o);Or(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const YC={kernelName:Ei,backendName:"cpu",kernelFunc:XC};function QC(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;dS([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],h=o?a.shape[u-1]:a.shape[u-2],d=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),g=a.shape.slice(0,-2),m=Lr(f),b=Lr(g),y=ch(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([d,p]);Or(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));const x=o?[b,p,h]:[b,h,p],v=XC({inputs:{x:s},backend:n,attrs:{shape:i?[m,c,d]:[m,d,c]}}),w=XC({inputs:{x:a},backend:n,attrs:{shape:x}}),k=i?v.shape[1]:v.shape[2],S=i?v.shape[2]:v.shape[1],I=o?w.shape[1]:w.shape[2],C=Math.max(m,b),T=n.data.get(v.dataId).values,N=n.data.get(w.dataId).values,E=es(v.shape),$=es(w.shape),[R,A,_]=i?[E[0],1,E[1]]:[E[0],E[1],1],[O,D,F]=o?[1,$[1],$[0]]:[$[1],1,$[0]],L=S*I,z=Hu([C,S,I],v.dtype),M=z.values,P=n.blockSize;for(let B=0;B<C;B++){const e=B%m,t=B%b;for(let n=0;n<S;n+=P){const r=Math.min(n+P,S);for(let s=0;s<I;s+=P){const a=Math.min(s+P,I);for(let i=0;i<k;i+=P){const o=Math.min(i+P,k);for(let l=n;l<r;l++)for(let n=s;n<a;n++){let r=0;for(let s=i;s<o;s++)r+=T[e*R+l*A+s*_]*N[s*O+n*D+t*F];M[B*L+(l*I+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(y,z.dtype,z.values)}const JC={kernelName:Ls,backendName:"cpu",kernelFunc:QC},ZC={kernelName:Co,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,f;const g=[];d=QC({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=_S({inputs:{a:d,b:i},backend:n}),g.push(d),d=p),c&&(f=KC(n,d,c,o,h),g.push(d),d=f);for(const m of g)n.disposeIntermediateTensorInfo(m);return d}},eT=PS(xs,(e=>Math.acos(e))),tT={kernelName:xs,backendName:"cpu",kernelFunc:eT},nT=PS(vs,(e=>Math.acosh(e))),rT={kernelName:vs,backendName:"cpu",kernelFunc:nT},sT={kernelName:ks,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;dS(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=Hu(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}},aT={kernelName:Ss,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;dS(s,"all");const o=Vr(a,s.shape);let l=o;const u=Ih(l,s.shape.length);let c=s;null!=u&&(c=UI({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Th(l.length,s.shape.length)),Sh("all",l,c.shape.length);const[h,d]=wh(c.shape,l),p=Lr(d),f=ss(Lr(h),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const r=g[e+n];t=t&&r}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,f);if(i){const e=XC({inputs:{x:m},backend:n,attrs:{shape:kh(h,o)}});return n.disposeIntermediateTensorInfo(m),e}return m}},iT={kernelName:Is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;dS(s,"any");const o=Vr(a,s.shape);let l=o;const u=Ih(l,s.shape.length);let c=s;null!=u&&(c=UI({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Th(l.length,s.shape.length)),Sh("any",l,c.shape.length);const[h,d]=wh(c.shape,l),p=Lr(d),f=ss(Lr(h),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const r=g[e+n];t=t||r}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,f);if(i){const e=XC({inputs:{x:m},backend:n,attrs:{shape:kh(h,o)}});return n.disposeIntermediateTensorInfo(m),e}return m}},oT={kernelName:Cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;dS(s,"argMax");let i=Vr(a,s.shape);const o=Ih(i,s.shape.length);let l=s;const u=[];null!=o&&(l=UI({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Th(i.length,l.shape.length)),i=[i[0]],Sh("argMax",i,l.shape.length);const[c,h]=wh(l.shape,i),d=ss(Lr(c),"int32"),p=Lr(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const e=g*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s>t&&(t=s,n=r)}d[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}},lT={kernelName:Ts,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;dS(s,"argMin");let i=Vr(a,s.shape);const o=Ih(i,s.shape.length);let l=s;const u=[];null!=o&&(l=UI({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Th(i.length,l.shape.length)),i=[i[0]],Sh("argMin",i,l.shape.length);const[c,h]=wh(l.shape,i),d=ss(Lr(c),"int32"),p=Lr(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const e=g*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s<t&&(t=s,n=r)}d[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}},uT=PS(Ns,(e=>Math.asin(e))),cT={kernelName:Ns,backendName:"cpu",kernelFunc:uT},hT=PS(Es,(e=>Math.asinh(e))),dT={kernelName:Es,backendName:"cpu",kernelFunc:hT},pT=PS($s,(e=>Math.atan(e))),fT={kernelName:$s,backendName:"cpu",kernelFunc:pT},gT=bS(((e,t)=>Math.atan2(e,t))),mT=ES(As,gT),bT={kernelName:As,backendName:"cpu",kernelFunc:mT},yT=PS(Rs,(e=>Math.atanh(e))),xT={kernelName:Rs,backendName:"cpu",kernelFunc:yT};function vT(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Hu(s.outShape,n),m=g.values,b=s.outShape[1]*s.outShape[2]*s.outShape[3],y=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let v=0;v<s.batchSize;++v){const t=v*b,n=v*r[0];for(let g=0;g<s.inChannels;++g)for(let b=0;b<s.outHeight;++b){const v=b*i-d,w=Math.max(0,v),k=Math.min(s.inHeight,c+v),S=t+b*y;for(let t=0;t<s.outWidth;++t){const i=t*o-p,c=Math.max(0,i),d=Math.min(s.inWidth,h+i);let b=f,y=0,v=0;for(let t=w;t<k;t+=l){const s=n+t*r[1];for(let t=c;t<d;t+=u){const n=e[s+t*r[2]+g];"max"===a&&n>b?b=n:"avg"===a&&(y+=n,v++)}if(isNaN(b))break}m[S+t*x+g]="avg"===a?y/v:b}}}return g}function wT(e,t,n,r,s=!1,a=!1){const i=Hu(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,g=Hu(t,n,e);for(let m=0;m<r.batchSize;++m)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let b=n;for(;b<0;)b+=u;const y=Math.min(r.inHeight,h+n);for(let o=0;o<r.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const x=Math.min(r.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<y;t+=u){const i=t-n;for(let n=p;n<x;n+=c){const o=n-h,l=g.get(m,t,n,e);l>v&&(v=l,w=s?a?((m*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*d+o)}}i.set(w,m,t,o,e)}}return i}function kT(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,g=s.padInfo.front,m=s.padInfo.top,b=s.padInfo.left,y="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Hu(s.outShape,n),v=x.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let C=0;C<s.batchSize;++C){const t=C*w,n=C*r[0];for(let x=0;x<s.inChannels;++x)for(let w=0;w<s.outDepth;++w){const C=w*i-g;let T=C;for(;T<0;)T+=u;const N=Math.min(s.inDepth,d+C),E=t+w*k;for(let t=0;t<s.outHeight;++t){const i=t*o-m;let d=i;for(;d<0;)d+=c;const g=Math.min(s.inHeight,p+i),w=E+t*S;for(let t=0;t<s.outWidth;++t){const i=t*l-b;let o=i;for(;o<0;)o+=h;const p=Math.min(s.inWidth,f+i),m=w+t*I;let k=y,S=0,C=0;for(let t=T;t<N;t+=u){const s=n+t*r[1];for(let t=d;t<g;t+=c){const n=s+t*r[2];for(let t=o;t<p;t+=h){const s=e[n+t*r[3]+x];if("max"===a&&s>k?k=s:"avg"===a&&(S+=s,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[m+x]="avg"===a?S/Math.max(C,1):k}}}}return x}const ST={kernelName:_s,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;dS(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Or(wc(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hc(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&zr(u.inShape,u.outShape))c=wS({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=es(s.shape),r=vT(e,s.shape,s.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},IT={kernelName:Ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;dS(s,"avgPool3d");const c=dc(s.shape,a,i,1,o,l,u),h=kT(n.data.get(s.dataId).values,s.shape,s.dtype,es(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}},CT={kernelName:Fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;dS([s,a],"avgPool3DGrad");const c=dc(a.shape,i,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,m=c.filterWidth,b=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=v-1-c.padInfo.front,I=k-1-c.padInfo.left,C=w-1-c.padInfo.top,T=Hu(a.shape,"float32"),N=1/(f*g*m),E=n.bufferSync(s);for(let $=0;$<c.batchSize;++$)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-S,a=n-C,i=r-I;let o=0;for(let t=0;t<v;t+=b){const n=(s+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=y){const r=(a+t)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=x){const s=(i+t)/p;s<0||s>=c.outWidth||Math.floor(s)!==s||(o+=E.get($,n,r,s,e))}}}T.set(o*N,$,t,n,r,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}},TT={kernelName:Os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;dS([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=hc(i.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,b=c.effectiveFilterHeight,y=c.effectiveFilterWidth,x=y-1-c.padInfo.left,v=b-1-c.padInfo.top,w=Hu(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,I=Hu(s.shape,"float32",S);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-v,s=n-x;let a=0;for(let t=0;t<b;t+=g){const n=(r+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<y;t+=m){const r=(s+t)/d;r<0||r>=c.outWidth||Math.floor(r)!==r||(a+=I.get(C,n,r,e))}}w.set(a*k,C,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},NT={kernelName:Na,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;Or(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Or(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Or(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),dS([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=f.length,b=p.length,y=d.length,x=h.length;let v=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)g[I]=f[v++]+(c[I]-h[w++])*p[k++]/Math.sqrt(d[S++]+u),v>=m&&(v=0),w>=x&&(w=0),k>=b&&(k=0),S>=y&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,g)}},ET={kernelName:zs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;dS([s],"batchToSpaceND");const o=a.reduce(((e,t)=>e*t)),l=mg(s.shape,a,o),u=bg(l.length,a.length),c=yg(s.shape,a,o),h=xg(i,a.length),d=vg(c,i,a.length),p=XC({inputs:{x:s},backend:n,attrs:{shape:l}}),f=UI({inputs:{x:p},backend:n,attrs:{perm:u}}),g=XC({inputs:{x:f},backend:n,attrs:{shape:c}}),m=lC({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}},$T={kernelName:Ms,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=DS(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}},RT={kernelName:Bs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=ch(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},AT=PS(Vs,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),_T={kernelName:Vs,backendName:"cpu",kernelFunc:AT},OT={kernelName:Hs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Lr(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function DT(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const FT={kernelName:Da,backendName:"cpu",kernelFunc:DT};function LT(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Vr(s,t[0].shape)[0];ig(t.map((e=>e.shape)),a);let i=og(t.map((e=>e.shape)),a);if(0===Lr(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Lr(e.shape)>0));if(1===o.length)return wS({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>SS({inputs:{input:e},backend:n}))),t=o.map((e=>DT({inputs:{input:e},backend:n}))),r=LT({inputs:e,backend:n,attrs:{axis:a}}),s=LT({inputs:t,backend:n,attrs:{axis:a}}),i=yS({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=o.map((e=>{const t=Lr(e.shape.slice(a));return XC({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=og(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],h=GS(u,i,t[0].dtype,c),d=og(o.map((e=>e.shape)),a),p=n.makeTensorInfo(d,t[0].dtype,h);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const zT={kernelName:js,backendName:"cpu",kernelFunc:LT};function MT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;dS([s,a],"conv2d");const h=Sc(l),d=pc(s.shape,a.shape,i,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,y=d.padInfo.top,x="channelsLast"===d.dataFormat,v=new ml(d.outShape,s.dtype),w=es(s.shape),k=es(a.shape),S=w[0],I=x?w[1]:w[2],C=x?w[2]:1,T=x?1:w[1],N=v.strides[0],E=x?v.strides[1]:v.strides[2],$=x?v.strides[2]:1,R=x?1:v.strides[1],A=n.data.get(s.dataId).values,_=n.data.get(a.dataId).values,O=v.values;for(let D=0;D<d.batchSize;++D){const e=D*S,t=D*N;for(let n=0;n<d.outHeight;++n){const r=t+n*E,s=n*d.strideHeight-y;for(let t=0;t<p;++t){const n=s+t*g;if(n<0||n>=d.inHeight)continue;const a=t*k[0],i=e+n*I;for(let e=0;e<d.outWidth;++e){const t=r+e*$,n=e*d.strideWidth-b;for(let e=0;e<f;++e){const r=n+e*m;if(r<0||r>=d.inWidth)continue;const s=i+r*C;let o=a+e*k[1];for(let e=0;e<d.inChannels;++e){const n=A[s+e*T];for(let e=0;e<d.outChannels;++e)O[t+e*R]+=n*_[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,O)}const PT={kernelName:qs,backendName:"cpu",kernelFunc:MT},BT={kernelName:Ks,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;dS([s,a],"conv2dBackpropFilter");const h=Sc(l),d=pc(s.shape,c,i,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,b="channelsLast"===d.dataFormat,y=new ml(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=new ml(s.shape,s.dtype,w),I=new ml(a.shape,a.dtype,k);for(let C=0;C<g;++C){const e=Math.max(0,Math.ceil((v-C)/p)),t=Math.min(d.outHeight,(d.inHeight+v-C)/p);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((x-n)/f)),s=Math.min(d.outWidth,(d.inWidth+x-n)/f);for(let a=0;a<d.inChannels;++a)for(let i=0;i<d.outChannels;++i){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=e;u<t;++u){const e=C+u*p-v;for(let t=r;t<s;++t){const r=n+t*f-x;o+=b?S.get(l,e,r,a)*I.get(l,u,t,i):S.get(l,a,e,r)*I.get(l,i,u,t)}}y.set(o,C,n,a,i)}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},UT={kernelName:Xs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;dS([s,a],"conv2dBackpropInput");const h=es(a.shape),d=es(s.shape);let p=Sc(u);const f=pc(i,a.shape,o,1,l,c,!1,p),g=new ml(f.inShape,"float32"),m=g.values,b=n.data.get(s.dataId).values,y=n.data.get(a.dataId).values,[x,v,w]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:C,inHeight:T,inWidth:N,outChannels:E,outHeight:$,outWidth:R,strideHeight:A,strideWidth:_}=f;p=f.dataFormat;const O=S-1-f.padInfo.top,D=I-1-f.padInfo.left,F="channelsLast"===p,L=g.strides[0],z=F?g.strides[1]:g.strides[2],M=F?g.strides[2]:1,P=F?1:g.strides[1],B=d[0],U=F?d[1]:d[2],W=F?d[2]:1,V=F?1:d[1];for(let G=0;G<k;++G)for(let e=0;e<C;++e)for(let t=0;t<T;++t){const n=t-O,r=Math.max(0,Math.ceil(n/A)),s=Math.min($,(S+n)/A);for(let a=0;a<N;++a){const i=a-D,o=Math.max(0,Math.ceil(i/_)),l=Math.min(R,(I+i)/_);let u=0;for(let t=r;t<s;++t){const r=t*A-n;for(let n=o;n<l;++n){const s=B*G+U*t+W*n,a=x*(S-1-r)+v*(I-1-(n*_-i))+w*e;for(let e=0;e<E;++e)u+=b[s+V*e]*y[a+e]}}m[L*G+z*t+M*a+P*e]=u}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},WT={kernelName:Ys,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;dS([s,a],"conv3d");const u=fc(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=u,b=m.front,y=m.left,x=m.top,v=new ml(u.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=v.values,I=es(s.shape),C=es(a.shape);for(let T=0;T<u.batchSize;++T){const e=T*I[0],t=T*v.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*v.strides[1],s=n*u.strideDepth-b;for(let t=0;t<c;++t){const n=s+t*p;if(n<0||n>=u.inDepth)continue;const a=t*C[0],i=e+n*I[1];for(let e=0;e<u.outHeight;++e){const t=r+e*v.strides[2],n=e*u.strideHeight-x;for(let e=0;e<h;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const s=a+e*C[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-y;for(let e=0;e<d;++e){const t=r+e*g;if(t<0||t>=u.inWidth)continue;const a=s+e*C[2],i=o+t*u.inChannels;let l=a;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}},VT={kernelName:Qs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;dS([s,a],"conv3dBackpropFilterV2");const u=es(s.shape),c=es(a.shape),h=fc(s.shape,l,i,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,m=h.filterHeight,b=h.filterWidth,y=new ml(h.filterShape,"float32"),x=y.values,[v,w,k,S]=y.strides,I=n.data.get(a.dataId).values,[C,T,N,E]=c,$=n.data.get(s.dataId).values,[R,A,_,O]=u,D=h.padInfo.front,F=h.padInfo.left,L=h.padInfo.top;for(let z=0;z<g;++z){const e=Math.max(0,Math.ceil((D-z)/d)),t=Math.min(h.outDepth,(h.inDepth+D-z)/d),n=z*v;for(let r=0;r<m;++r){const s=Math.max(0,Math.ceil((L-r)/p)),a=Math.min(h.outHeight,(h.inHeight+L-r)/p),i=r*w+n;for(let n=0;n<b;++n){const o=Math.max(0,Math.ceil((F-n)/f)),l=Math.min(h.outWidth,(h.inWidth+F-n)/f),u=n*k+i;for(let i=0;i<h.inChannels;++i){const c=i*S+u;for(let u=0;u<h.outChannels;++u){let g=0;for(let c=0;c<h.batchSize;++c){const h=c*R,m=c*C;for(let c=e;c<t;++c){const e=(z+c*d-D)*A+h,t=c*T+m;for(let c=s;c<a;++c){const s=(r+c*p-L)*_+e,a=c*N+t;for(let e=o;e<l;++e){const t=e*E+a;g+=$[(n+e*f-F)*O+s+i]*I[t+u]}}}}x[c+u]=g}}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},GT={kernelName:Js,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;dS([s],"conv3dBackpropInputV2");const u=es(s.shape),c=es(a.shape),h=fc(l,a.shape,o,1,i),d=new ml(h.inShape,"float32"),p=d.values,[f,g,m,b]=d.strides,y=n.data.get(s.dataId).values,[x,v,w,k]=u,S=n.data.get(a.dataId).values,[I,C,T,N]=c,{batchSize:E,filterDepth:$,filterHeight:R,filterWidth:A,inChannels:_,inDepth:O,inHeight:D,inWidth:F,outChannels:L,outDepth:z,outHeight:M,outWidth:P,strideDepth:B,strideHeight:U,strideWidth:W}=h,V=$-1-h.padInfo.front,G=R-1-h.padInfo.top,H=A-1-h.padInfo.left;for(let j=0;j<E;++j)for(let e=0;e<_;++e)for(let t=0;t<O;++t){const n=t-V,r=Math.max(0,Math.ceil(n/B)),s=Math.min(z,($+n)/B);for(let a=0;a<D;++a){const i=a-G,o=Math.max(0,Math.ceil(i/U)),l=Math.min(M,(R+i)/U);for(let u=0;u<F;++u){const c=u-H,h=Math.max(0,Math.ceil(c/W)),d=Math.min(P,(A+c)/W);let E=0;for(let t=r;t<s;++t){const r=t*B-n;for(let n=o;n<l;++n){const s=n*U-i;for(let a=h;a<d;++a){const i=x*j+v*t+w*n+k*a,o=I*($-1-r)+C*(R-1-s)+T*(A-1-(a*W-c))+N*e;for(let e=0;e<L;++e)E+=y[i+e]*S[o+e]}}}p[f*j+g*t+m*a+b*u+e]=E}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},HT=PS(Zs,(e=>Math.cos(e))),jT={kernelName:Zs,backendName:"cpu",kernelFunc:HT},qT=PS(ea,(e=>Math.cosh(e))),KT={kernelName:ea,backendName:"cpu",kernelFunc:qT},XT={kernelName:ra,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,h,d,p]=s.shape,f=a.shape[0],[g,m]=o,b=Hu([f,g,m,p],"float32"),y=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,w=es(s.shape),k=es(b.shape);for(let S=0;S<f;S++){const e=4*S,t=y[e],n=y[e+1],r=y[e+2],s=y[e+3],a=x[S];if(a>=c)continue;const i=g>1?(r-t)*(h-1)/(g-1):0,o=m>1?(s-n)*(d-1)/(m-1):0;for(let c=0;c<g;c++){const e=g>1?t*(h-1)+c*i:.5*(t+r)*(h-1);if(e<0||e>h-1)for(let t=0;t<m;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];b.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<m;e++){const l=m>1?n*(d-1)+e*o:.5*(n+s)*(d-1);if(l<0||l>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];b.values[n]=u}continue}const h=Math.floor(l),f=Math.ceil(l),g=l-h;for(let n=0;n<p;n++){let s=n+h*w[2]+t*w[1]+a*w[0];const o=v[s];s=n+f*w[2]+t*w[1]+a*w[0];const l=v[s];s=n+h*w[2]+r*w[1]+a*w[0];const u=v[s];s=n+f*w[2]+r*w[1]+a*w[0];const d=o+(l-o)*g,p=u+(v[s]-u)*g;s=n+e*k[2]+c*k[1]+S*k[0],b.values[s]=d+(p-d)*i}}}else for(let t=0;t<m;++t){const r=m>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(r<0||r>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];b.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+l*w[1]+a*w[0],r=e+t*k[2]+c*k[1]+S*k[0];b.values[r]=v[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},YT={kernelName:ta,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;dS(s,"cumprod");const l=Ih([a],s.shape.length);let u=s;null!=l&&(u=UI({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Th(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Ol(u.dtype,"int32"),d=rs(Lr(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=g(b,e);if(0===e)d[t]=i?1:p[t];else{const n=g(b,e-1);d[t]=i?p[n]*d[n]:p[t]*d[n]}}const m=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=UI({inputs:{x:m},backend:n,attrs:{perm:Ch(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(u),e}return m}},QT={kernelName:na,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;dS(s,"cumsum");const l=Ih([a],s.shape.length);let u=s;null!=l&&(u=UI({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Th(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=Ol(u.dtype,"int32"),d=ss(Lr(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=g(b,e);if(0===e)d[t]=i?0:p[t];else{const n=g(b,e-1);d[t]=i?p[n]+d[n]:p[t]+d[n]}}const m=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=UI({inputs:{x:m},backend:n,attrs:{perm:Ch(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(u),e}return m}},JT={kernelName:sa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=DS(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=FS(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},ZT={kernelName:aa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Or("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],h=l*a,d=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,g=new Float32Array(o*h*d*p);let m=0;for(let b=0;b<o;++b)for(let e=0;e<h;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<d;++e){const r=Math.floor(e/a),s=(n*a+e%a)*p;for(let e=0;e<p;++e){const n=e+s+c*(r+u*(t+l*b));g[m++]=f[n]}}}return n.makeTensorInfo([o,h,d,p],s.dtype,g)}};function eN(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;dS([s,a],"depthwiseConv2DNative");const c=es(s.shape),h=es(a.shape);let d=l;null==d&&(d=[1,1]),Or(wc(i,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));const p=pc(s.shape,a.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:y}=p,x=y.left,v=y.top,w=p.outChannels/p.inChannels,k=new ml(p.outShape,s.dtype),S=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,C=k.values;for(let T=0;T<p.batchSize;++T){const e=T*c[0],t=T*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],s=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=s+t*m;if(n<0||n>=p.inHeight)continue;const a=t*h[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-x;for(let e=0;e<g;++e){const r=n+e*b;if(r<0||r>=p.inWidth)continue;const s=a+e*h[1],o=i+r*p.inChannels;let l=t,u=s;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)C[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const tN={kernelName:ia,backendName:"cpu",kernelFunc:eN},nN={kernelName:oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;dS([s,a],"depthwiseConv2dNativeBackpropFilter");const h=pc(s.shape,c,i,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,m=new ml(h.filterShape,"float32"),b=h.padInfo.left,y=h.padInfo.top,x=h.outChannels/h.inChannels,v=n.data.get(s.dataId).values,w=new ml(s.shape,s.dtype,v),k=n.data.get(a.dataId).values,S=new ml(a.shape,a.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((y-I)/d)),t=Math.min(h.outHeight,(h.inHeight+y-I)/d);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((b-n)/p)),s=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let a=0;a<h.outChannels;++a){const i=Math.trunc(a/x),o=a%x;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=e;o<t;++o){const e=I+o*d-y;for(let t=r;t<s;++t){const r=n+t*p-b;l+=w.get(u,e,r,i)*S.get(u,o,t,a)}}m.set(l,I,n,i,o)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},rN={kernelName:la,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;dS([s,a],"depthwiseConv2DNativeBackpropInput");const h=es(s.shape),d=es(a.shape),p=pc(c,a.shape,i,o,l,u,!0),f=new ml(p.inShape,"float32"),g=f.values,[m,b,y]=f.strides,x=n.data.get(s.dataId).values,[v,w,k]=h,S=n.data.get(a.dataId).values,[I,C,T]=d,{batchSize:N,filterHeight:E,filterWidth:$,inChannels:R,inHeight:A,inWidth:_,outChannels:O,outHeight:D,outWidth:F,strideHeight:L,strideWidth:z}=p,M=E-1-p.padInfo.top,P=$-1-p.padInfo.left,B=O/R;for(let U=0;U<N;++U)for(let e=0;e<R;++e)for(let t=0;t<A;++t){const n=t-M,r=Math.max(0,Math.ceil(n/L)),s=Math.min(D,(E+n)/L);for(let a=0;a<_;++a){const i=a-P,o=Math.max(0,Math.ceil(i/z)),l=Math.min(F,($+i)/z);let u=0;for(let t=r;t<s;++t){const r=t*L-n;for(let n=o;n<l;++n){const s=v*U+w*t+k*n,a=I*(E-1-r)+C*($-1-(n*z-i))+T*e;for(let t=0;t<B;++t)u+=x[s+(e*B+t)]*S[a+t]}}g[m*U+b*t+y*a+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},sN={kernelName:ua,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Lr(r.shape),a=n.data.get(r.dataId).values,i=Hu([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},aN={kernelName:ca,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,h=l.data.get(s.dataId).values,d=s.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:y,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:T}=cc(r.shape,s.shape,a,i,"NHWC",o),N=Lr(T),E=T.length,$=jr(r.dtype,N);for(let R=0;R<p;++R)for(let e=0;e<b;++e){const t=e*v-x.top;for(let n=0;n<y;++n){const a=n*w-x.left;for(let i=0;i<m;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=a+t*C;if(l>=0&&l<g){const a=os([R,n,l,i],c,es(r.shape)),p=os([e,t,i],d,es(s.shape)),f=u[a]+h[p];f>o&&(o=f)}}}$[os([R,e,n,i],E,es(T))]=o}}}return{dataId:l.write(nl($,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},iN={kernelName:da,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=ns(r.shape,u.data.get(r.dataId).values),h=ns(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:b,padInfo:y,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:C}=cc(r.shape,s.shape,i,o,"NHWC",l);Or(a.rank===C.length,(()=>`Error in ${da}, dy must have the same rank as output ${C.length}, but got ${a.rank}`));const T=ns(C,u.data.get(a.dataId).values),N=as(s.shape,s.dtype);for(let E=0;E<d;++E)for(let e=0;e<m;++e){const t=e*x-y.top;for(let n=0;n<b;++n){const r=n*v-y.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<w;++e){const n=t+e*S;if(n>=0&&n<p)for(let t=0;t<k;++t){const l=r+t*I;if(l>=0&&l<f){const r=c[E][n][l][s]+h[e][t][s];r>a&&(a=r,i=e,o=t)}}}N[i][o][s]+=T[E][e][n][s]}}}return{dataId:u.write(nl(N,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},oN={kernelName:ha,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=ns(r.shape,u.data.get(r.dataId).values),h=ns(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:b,padInfo:y,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:C}=cc(r.shape,s.shape,i,o,"NHWC",l);Or(a.rank===C.length,(()=>`Error in ${ha}, dy must have the same rank as output ${C.length}, but got ${a.rank}`));const T=ns(C,u.data.get(a.dataId).values),N=as(r.shape,r.dtype);for(let E=0;E<d;++E)for(let e=0;e<m;++e){const t=e*x-y.top;for(let n=0;n<b;++n){const r=n*v-y.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<w;++e){const n=t+e*S;if(n>=0&&n<p)for(let t=0;t<k;++t){const l=r+t*I;if(l>=0&&l<f){const r=c[E][n][l][s]+h[e][t][s];r>a&&(a=r,i=n,o=l)}}}N[E][i][o][s]+=T[E][e][n][s]}}}return{dataId:u.write(nl(N,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},lN={kernelName:"Draw",backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=a.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==h)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],g=n.data.get(s.dataId).values,m="float32"===s.dtype?255:1,b=new Uint8ClampedArray(p*d*4);for(let x=0;x<d*p;++x){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=g[x*f+n];if("float32"===s.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===s.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*m,e[1]=t*m,e[2]=t*m):e[n]=t*m}const t=4*x;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}a.width=p,a.height=d;const y=new ImageData(b,p,d);return h.putImageData(y,0,0),s}};function uN(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;dS(s,"sum"),o="bool"===s.dtype?TS({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):wS({inputs:{x:s},backend:n});const l=o.shape.length,u=Vr(a,o.shape),c=Ih(u,l);let h=u,d=o;null!=c&&(d=UI({inputs:{x:o},backend:n,attrs:{perm:c}}),h=Th(h.length,l)),Sh("sum",h,d.shape.length);const[p,f]=wh(d.shape,h);let g=vS(n,p,Ol(d.dtype,"int32"));const m=Lr(f),b=n.data.get(g.dataId).values,y=n.data.get(d.dataId).values;for(let x=0;x<b.length;++x){const e=x*m;let t=0;for(let n=0;n<m;++n)t+=y[e+n];b[x]=t}if(i){const e=g;g=XC({inputs:{x:g},backend:n,attrs:{shape:kh(g.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),g}const cN={kernelName:Xi,backendName:"cpu",kernelFunc:uN},hN={kernelName:fa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=Mg(s,a.length);Bg(i.length,l,a);const{path:u,steps:c}=Ug(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let g=0;g<h;++g){for(const e of c[g]){const{permutationIndices:t,expandDims:r}=Pg(p,l[e]);let s;Wg(t)?s=a[e]:(s=UI({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);zr(s.shape,i)||(s=XC({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=OI({inputs:{a:s,b:d},backend:n}),f.push(d))}g<h-1&&(u[g]>=0&&(d=uN({inputs:{x:d},backend:n,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}},dN={kernelName:ma,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;dS([r,s],"eluGrad");const a=new Float32Array(Lr(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];a[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(s.shape,"float32",a)}},pN=Sg,fN=Ig,gN=Cg,mN=Tg,bN=Ng,yN=Eg,xN=PS(ba,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+pN*n);return t*(1-((((yN*r+bN)*r+mN)*r+gN)*r+fN)*r*Math.exp(-n*n))})),vN={kernelName:ba,backendName:"cpu",kernelFunc:xN};function wN(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Or(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),XC({inputs:{x:s},backend:n,attrs:{shape:o}})}const kN={kernelName:va,backendName:"cpu",kernelFunc:wN},SN=bS(((e,t)=>e/t)),IN=ES(pa,SN),CN={kernelName:pa,backendName:"cpu",kernelFunc:IN};function TN(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Lr(u),h=Hr("float32",c),d=Hr("float32",c);for(let m=0;m<s;m++){const e=lC({inputs:{x:o},backend:n,attrs:{begin:[m,0],size:[1,a]}}),r=lC({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,a]}}),s=yS({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=NN(s,t,n),c=$g(i,u);for(let t=0;t<a;t++){const e=Og(c,t);h[m*a+t]=e.real,d[m*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),g=yS({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function NN(e,t,n){const r=Lr(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if((o=r)&o-1){const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=Lg(s*r,t,n),l=Og(e,r);a+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(a/=t,i/=t),Dg(r,a,i,s)}return r}($g(a,i),r,t);return Rg(e)}{const s=EN(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",tl(r,"float32")),i=wS({inputs:{x:a},backend:n}),l=CN.kernelFunc({inputs:{a:e,b:a},backend:n}),u=CN.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return s}var o}function EN(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=$g(e,t),i=n/2,o=Ag(a),l=o.real,u=o.imag,c=[l.length],h=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),p=yS({inputs:{real:h,imag:d},backend:s}),f=_g(a),g=f.real,m=f.imag,b=[g.length],y=s.makeTensorInfo(b,"float32",g),x=s.makeTensorInfo(b,"float32",m),v=yS({inputs:{real:y,imag:x},backend:s}),w=EN(l,u,i,r,s),k=w.real,S=w.imag,I=[k.length],C=s.makeTensorInfo(I,"float32",k),T=s.makeTensorInfo(I,"float32",S),N=yS({inputs:{real:C,imag:T},backend:s}),E=EN(g,m,i,r,s),$=E.real,R=E.imag,A=[$.length],_=s.makeTensorInfo(A,"float32",$),O=s.makeTensorInfo(A,"float32",R),D=yS({inputs:{real:_,imag:O},backend:s}),F=Fg(n,r),L=[F.real.length],z=s.makeTensorInfo(L,"float32",F.real),M=s.makeTensorInfo(L,"float32",F.imag),P=yS({inputs:{real:z,imag:M},backend:s}),B=OI({inputs:{a:P,b:D},backend:s}),U=_S({inputs:{a:N,b:B},backend:s}),W=$C({inputs:{a:N,b:B},backend:s}),V=SS({inputs:{input:U},backend:s}),G=SS({inputs:{input:W},backend:s}),H=DT({inputs:{input:U},backend:s}),j=DT({inputs:{input:W},backend:s}),q=LT({inputs:[V,G],backend:s,attrs:{axis:0}}),K=LT({inputs:[H,j],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Y=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const $N={kernelName:ka,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Lr(r.shape),a=r.shape[r.shape.length-1],i=XC({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=TN(i,!1,n),l=XC({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function RN(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Qr(s),o=jr(i,Lr(r));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const AN={kernelName:Sa,backendName:"cpu",kernelFunc:RN},_N={kernelName:Ia,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=Hr(r.dtype,Lr(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const e=h*l*o*u;for(let t=0;t<o;t++){const n=t*(l*u);for(let t=0;t<l;t++){const r=t*u;for(let s=0;s<u;s++){const i=Math.round(l-t-1),o=e+n+r+s;let h=c[o];i>=0&&i<l&&(h=c[e+n+i*u+s]),a[o]=h}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},ON={kernelName:To,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=MT({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=g;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=XC({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=_S({inputs:{a:g,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else g=_S({inputs:{a:g,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=g;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=XC({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=KC(n,g,p,e,f),n.disposeIntermediateTensorInfo(e)}else g=KC(n,g,p,o,f);n.disposeIntermediateTensorInfo(e)}return g}},DN={kernelName:No,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r;let g=eN({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const e=g;g=_S({inputs:{a:g,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=g;g=KC(n,g,p,o,f),n.disposeIntermediateTensorInfo(e)}return g}},FN={kernelName:$a,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Lr(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,h]=Bf(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const d=iI(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,h,r.shape,a);return n.makeTensorInfo(l,r.dtype,d.values)}},LN={kernelName:Ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;dS([s,a],"gatherV2");const l=Vr(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let x=0;x<u.length;++x){const e=u[x];Or(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let h=o;null==o&&(h=0);const d=Lr(a.shape),p=nm(s,a,l,h),f=XC({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=XC({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=n.bufferSync(g),y=oI(n.bufferSync(f),b,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,y.dtype,y.values)}},zN={kernelName:Oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Lr(r.shape),a=r.shape[r.shape.length-1],i=XC({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=TN(i,!0,n),l=XC({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},MN=PS(Fa,(e=>Number.isFinite(e)?1:0),"bool"),PN={kernelName:Fa,backendName:"cpu",kernelFunc:MN},BN=PS(La,(e=>Math.abs(e)===1/0?1:0),"bool"),UN={kernelName:La,backendName:"cpu",kernelFunc:BN},WN=PS(za,(e=>Number.isNaN(e)?1:0),"bool"),VN={kernelName:za,backendName:"cpu",kernelFunc:WN},GN={kernelName:Ua,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=vI(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},HN=PS(Va,(e=>Math.log1p(e))),jN={kernelName:Va,backendName:"cpu",kernelFunc:HN},qN=bS(((e,t)=>e&&t)),KN=ES(Ga,qN,null,"bool"),XN={kernelName:Ga,backendName:"cpu",kernelFunc:KN},YN=PS(Ha,(e=>e?0:1),"bool"),QN={kernelName:Ha,backendName:"cpu",kernelFunc:YN},JN=bS(((e,t)=>e||t)),ZN=ES(ja,JN,null,"bool"),eE={kernelName:ja,backendName:"cpu",kernelFunc:ZN},tE={kernelName:qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;dS(s,"LRN");const u=s.shape[3],c=u-1,h=n.data.get(s.dataId).values,d=Lr(s.shape),p=new Float32Array(d);function f(e){const t=e%u;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=h[n];s+=e*e}return s}for(let g=0;g<d;g++){const e=f(g),t=h[g]*Math.pow(i+o*e,-l);p[g]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}},nE={kernelName:Ka,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;dS(i,"LRNGrad");const h=Lr(i.shape),d=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,g=n.data.get(a.dataId).values,m=new Float32Array(h),b=h;for(let y=0;y<b;y++){const e=y%d,t=y-e+Math.max(0,e-o),n=y-e+Math.min(d,e+o+1);let r=0;for(let s=t;s<n;s++)r+=Math.pow(f[s],2);r=u*r+l;for(let s=t;s<n;s++){let e=-2*u*c*f[s]*g[y]/r;y===s&&(e+=Math.pow(r,-c)),e*=p[y],m[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,m)}};function rE(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Vr(a,l);let h=c;const d=Ih(h,u);let p=o.data.get(s.dataId).values;if(null!=d){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[d[t]];p=BI(p,l,s.dtype,d,e),h=Th(h.length,u),l=e}dS(s,"max"),Sh("max",h,u);const[f,g]=wh(l,h),m=II(p,Lr(g),f,s.dtype),b=o.write(m,f,s.dtype);let y=f;return i&&(y=kh(f,c)),{dataId:b,shape:y,dtype:s.dtype}}const sE={kernelName:Xa,backendName:"cpu",kernelFunc:rE},aE={kernelName:Qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;dS(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Or(wc(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hc(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&zr(u.inShape,u.outShape))c=wS({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=es(s.shape),r=vT(e,s.shape,s.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},iE={kernelName:Za,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;dS(s,"maxPool3d");const c=dc(s.shape,a,i,1,o,l,u),h=kT(n.data.get(s.dataId).values,s.shape,s.dtype,es(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}},oE={kernelName:ei,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;dS([s,a],"maxPool3DGrad");const c=dc(a.shape,i,o,1,l,u),h=function(e,t){const n=Hu(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let b=0;b<t.outDepth;++b){const y=b*r-d;let x=y;for(;x<0;)x+=i;const v=Math.min(t.inDepth,u+y);for(let r=0;r<t.outHeight;++r){const u=r*s-p;let d=u;for(;d<0;)d+=o;const w=Math.min(t.inHeight,c+u);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,C=-1;for(let t=x;t<v;t+=i){const n=t-y;for(let r=d;r<w;r+=o){const s=r-u;for(let a=k;a<S;a+=l){const i=a-p,o=e.get(g,t,r,a,m);o>=I&&(I=o,C=n*c*h+s*c+i)}}}n.set(C,g,b,r,s,m)}}}return n}(n.bufferSync(a),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,g=c.dilationDepth,m=c.dilationHeight,b=c.dilationWidth,y=c.effectiveFilterDepth,x=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=y-1-c.padInfo.front,k=v-1-c.padInfo.left,S=x-1-c.padInfo.top,I=Hu(a.shape,"float32"),C=n.bufferSync(s);for(let T=0;T<c.batchSize;++T)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-w,a=n-S,i=r-k;let o=0;for(let t=0;t<y;t+=g){const n=(s+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<x;r+=m){const s=(a+r)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let a=0;a<v;a+=b){const l=(i+a)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=y*x*v-1-h.get(T,n,s,l,e)===t*x*v+r*v+a?1:0;0!==u&&(o+=C.get(T,n,s,l,e)*u)}}}I.set(o,T,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}},lE={kernelName:Ja,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;dS([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=hc(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=Hu(d.outShape,o.dtype,wT(p,o.shape,o.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,y=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,k=x-1-d.padInfo.top,S=Hu(o.shape,"float32"),I=n.data.get(s.dataId).values,C=Hu(s.shape,"float32",I);for(let T=0;T<d.batchSize;++T)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const r=t-k,s=n-w;let a=0;for(let t=0;t<x;t+=b){const n=(r+t)/g;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<v;r+=y){const i=(s+r)/m;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;const o=x*v-1-f.get(T,n,i,e)===t*v+r?1:0;0!==o&&(a+=C.get(T,n,i,e)*o)}}S.set(a,T,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}},uE={kernelName:ti,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;dS(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=hc(r.shape,s,a,[1,1],i),[h,d]=function(e,t,n,r,s){const a=vT(e,0,n,es(t),s,"max"),i=wT(e,t,n,s,!0,r);return[a.values,i.values]}(u,r.shape,r.dtype,o,c),p=l.write(h,c.outShape,r.dtype),f=l.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},cE={kernelName:ni,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Vr(a,s.shape),l=Lr(wh(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=TS({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=IN({inputs:{a:h,b:c},backend:n});u.push(d);const p=uN({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},hE={kernelName:ri,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;dS(s,"min");const o=Vr(a,s.shape);let l=o;const u=Ih(l,s.shape.length);let c=s;null!=u&&(c=UI({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Th(l.length,s.shape.length)),Sh("min",l,c.shape.length);const[h,d]=wh(c.shape,l),p=Lr(d),f=ss(Lr(h),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const r=g[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,f);if(i){const e=XC({inputs:{x:m},backend:n,attrs:{shape:kh(h,o)}});return n.disposeIntermediateTensorInfo(m),e}return m}},dE={kernelName:ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;dS(s,"mirrorPad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=a.map(((e,t)=>e[0]+s.shape[t])),c="reflect"===i?0:1,h=n.data.get(s.dataId).values,d=s.shape.length,p=es(s.shape),f=Lr(o),g=o.length,m=es(o),b=Hr(s.dtype,f);for(let y=0;y<f;y++){let e=ls(y,g,m);for(let n=0;n<g;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=os(e,d,p);b[y]=h[t]}return{dataId:n.write(b,o,s.dtype),shape:o,dtype:s.dtype}}},pE=bS(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),fE=ES(ii,pE),gE={kernelName:ii,backendName:"cpu",kernelFunc:fE};function mE(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Vr([o],s.shape),u=rE({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=kh(u.shape,l),h=XC({inputs:{x:u},backend:n,attrs:{shape:c}}),d=$C({inputs:{a:s,b:h},backend:n}),p=XS({inputs:{x:d},backend:n}),f=uN({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=XC({inputs:{x:f},backend:n,attrs:{shape:c}}),m=IN({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const bE={kernelName:Ji,backendName:"cpu",kernelFunc:mE},yE={kernelName:oi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;dS(s,"multinomial");const l=o?s:mE({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,a],p=ss(Lr(d),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+h[e+s];const n=Yd.alea(i.toString()),r=f*a;for(let s=0;s<a;++s){const e=n();p[r+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}},xE=of,vE={kernelName:hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;dS(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:h}=xE(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},wE=lf,kE={kernelName:di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;dS(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,{selectedIndices:d,validOutputs:p}=wE(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},SE=uf,IE={kernelName:pi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;dS(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,h=n.data.get(a.dataId).values,d=i,p=o,f=l,g=u,{selectedIndices:m,selectedScores:b}=SE(c,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},CE={kernelName:gi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;dS(s,"oneHot");const u=Lr(s.shape),c=new Float32Array(u*i);c.fill(l);const h=n.data.get(s.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<i&&(c[d*i+h[d]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}};function TE(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=SS({inputs:{input:r},backend:n}),t=TE({inputs:{x:e},backend:n}),s=DT({inputs:{input:r},backend:n}),a=TE({inputs:{x:s},backend:n}),i=yS({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return RN({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const NE={kernelName:ko,backendName:"cpu",kernelFunc:TE},EE={kernelName:fi,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=SS({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=DT({inputs:{input:s},backend:r}),i=TE({inputs:{x:a},backend:r}),o=yS({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return RN({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function $E(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return wN({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{Dr(a,e.shape,"All tensors passed to stack must have matching shapes"),Or(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=LT({inputs:t.map((e=>{const t=wN({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const RE={kernelName:mi,backendName:"cpu",kernelFunc:$E},AE={kernelName:bi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;dS(s,"pad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=n.data.get(s.dataId).values,c=Lr(s.shape),h=s.shape.length,d=es(s.shape),p=Lr(o),f=o.length,g=es(o),m=Hr(s.dtype,p);0!==i&&m.fill(i);for(let b=0;b<c;b++)m[os(ls(b,h,d).map(((e,t)=>e+l[t])),f,g)]=u[b];return{dataId:n.write(m,o,s.dtype),shape:o,dtype:s.dtype}}},_E=bS(((e,t)=>Math.pow(e,t))),OE=ES(yi,_E),DE={kernelName:yi,backendName:"cpu",kernelFunc:OE},FE={kernelName:wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.data.get(e.dataId).values)),u=s.map((e=>e.shape)),c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,[d,p,f]=jI(l,u,c,a.shape,a.dtype,h,i.shape),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,a.dtype,p);return g.concat([m])}},LE={kernelName:ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=qI(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}},zE={kernelName:Si,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,h=n.data.get(i.dataId).values,d=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,g]=JI(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,g)}},ME={kernelName:Ii,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=ZI(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},PE=PS(Ti,(e=>1/e)),BE={kernelName:Ti,backendName:"cpu",kernelFunc:PE},UE={kernelName:Ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;dS(s,"resizeBilinear");const l=es(s.shape),[u,c]=o,[h,d,p,f]=s.shape,g=n.data.get(s.dataId).values,m=new Float32Array(Lr([h,u,c,f])),b=[a&&u>1?d-1:d,a&&c>1?p-1:p],y=[a&&u>1?u-1:u,a&&c>1?c-1:c];let x=0;const v=b[0]/y[0],w=b[1]/y[1];for(let k=0;k<h;k++)for(let e=0;e<u;e++){let t;t=i?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(d-1,Math.ceil(t)),a=k*l[0]+n*l[1],o=k*l[0]+s*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,u=Math.min(p-1,Math.ceil(t)),c=a+n*l[2],h=o+n*l[2],d=a+u*l[2],b=o+u*l[2];for(let e=0;e<f;e++){const t=g[c+e],n=g[h+e],a=t+(g[d+e]-t)*s,i=a+(n+(g[b+e]-n)*s-a)*r;m[x++]=i}}}return n.makeTensorInfo([h,u,c,f],"float32",m)}},WE={kernelName:_i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;dS([a,s],"resizeBilinearGrad");const o=es(s.shape),[l,u,c,h]=s.shape,[,d,p]=a.shape,f=new Float32Array(l*u*c*h),g=[i&&d>1?u-1:u,i&&p>1?c-1:c],m=[i&&d>1?d-1:d,i&&p>1?p-1:p],b=g[0]/m[0],y=g[1]/m[1],x=n.data.get(a.dataId).values;let v=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<d;t++){const n=t*b,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),a=e+r*o[1],i=e+s*o[1],l=n-r,d=1-l;for(let e=0;e<p;e++){const t=e*y,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,u=1-s,p=a+n*o[2],g=a+r*o[2],m=i+n*o[2],b=i+r*o[2],w=d*u,k=d*s,S=l*u,I=l*s;for(let e=0;e<h;e++){const t=x[v++];f[p+e]+=t*w,f[g+e]+=t*k,f[m+e]+=t*S,f[b+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}},VE={kernelName:$i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;dS(s,"resizeNearestNeighbor");const l=es(s.shape),[u,c]=o,[h,d,p,f]=s.shape,g=n.data.get(s.dataId).values,m=new Float32Array(h*u*c*f),b=[a&&u>1?d-1:d,a&&c>1?p-1:p],y=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=b[0]/y[0],v=b[1]/y[1];let w=0;for(let k=0;k<h;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?x*(t+.5):x*t;let r=Math.min(d-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=e+r*l[1];for(let e=0;e<c;e++){const t=i?v*(e+.5):v*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*l[2];for(let e=0;e<f;e++){const t=g[r+e];m[w++]=t}}}}return n.makeTensorInfo([h,u,c,f],s.dtype,m)}},GE={kernelName:Ri,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;dS([a,s],"resizeNearestNeighborGrad");const o=es(s.shape),l=es(a.shape),[u,c,h,d]=s.shape,[,p,f]=a.shape,g=new Float32Array(u*c*h*d),m=n.data.get(a.dataId).values,b=[i&&p>1?c-1:c,i&&f>1?h-1:h],y=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=b[0]/y[0],v=b[1]/y[1],w=1/x,k=1/v,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let C=0;C<u;C++){const e=C*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),s=Math.floor(r-S/2);for(let a=0;a<h;a++){const r=n+a*o[2],u=Math.floor(a*k),b=Math.floor(u-I/2);for(let n=0;n<d;n++){let o=0;for(let r=0;r<S;r++){const u=r+s;if(u<0||u>=p)continue;const d=e+u*l[1],g=u*x;if(t===Math.min(c-1,i?Math.round(g):Math.floor(g)))for(let e=0;e<I;e++){const t=e+b;if(t<0||t>=f)continue;const r=d+t*l[2],s=t*v;a===Math.min(h-1,i?Math.round(s):Math.floor(s))&&(o+=m[r+n])}}g[r+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,g)}},HE={kernelName:Di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;dS(s,"reverse");const i=s.shape.length,o=Vr(a,s.shape);if(0===i)return wS({inputs:{x:s},backend:n});const l=new ml(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=s.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},jE={kernelName:Io,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=Hr(r.dtype,Lr(r.shape)),[u,c,h,d]=r.shape,[p,f]=gg(i,c,h),g=Math.sin(s),m=Math.cos(s),b=o.data.get(r.dataId).values;for(let y=0;y<u;y++){const e=y*h*c*d;for(let t=0;t<c;t++){const n=t*(h*d);for(let r=0;r<h;r++){const s=r*d;for(let i=0;i<d;i++){const o=[u,t,r,i],y=o[2],x=o[1];let v=(y-p)*m-(x-f)*g,w=(y-p)*g+(x-f)*m;v=Math.round(v+p),w=Math.round(w+f);let k=a;"number"!=typeof a&&(k=3===i?255:a[i]),v>=0&&v<h&&w>=0&&w<c&&(k=b[e+w*(h*d)+v*d+i]),l[e+n+s+i]=k}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},qE=PS(Fi,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),KE={kernelName:Fi,backendName:"cpu",kernelFunc:qE},XE={kernelName:zi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Op(0,s,i),d=rC(n.bufferSync(s),n.bufferSync(a),i,h,u,l,o,c,0,!0);return n.makeTensorInfo(i,d.dtype,d.values)}};function YE(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function QE(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const JE={kernelName:Pi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=function(e,t,n,r,s,a){const i=jr("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*s;for(let e=0;e<s;++e)i[l+e]="left"===a?YE(n,t[e+l]):QE(n,t[e+l])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",o)}},ZE={kernelName:Bi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;dS([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=Ol(s.dtype,a.dtype),h=ss(Lr(s.shape),c);let d=0;const p=0===i||i>1||1===s.shape.length?1:Lr(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?h[d++]=l[f]:h[d++]=u[f];return n.makeTensorInfo(s.shape,c,h)}},e$=wg,t$=kg,n$=PS(Ui,(e=>e>=0?t$*e:e$*(Math.exp(e)-1))),r$={kernelName:Ui,backendName:"cpu",kernelFunc:n$},s$=PS(Hi,(e=>e<0?-1:e>0?1:0)),a$={kernelName:Hi,backendName:"cpu",kernelFunc:s$},i$=PS(Vi,(e=>Math.sin(e))),o$={kernelName:Vi,backendName:"cpu",kernelFunc:i$},l$=PS(Gi,(e=>Math.sinh(e))),u$={kernelName:Gi,backendName:"cpu",kernelFunc:l$},c$=Math.log(1.1920928955078125e-7)+2,h$=PS(qi,(e=>{const t=e>-c$,n=e<c$,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),d$={kernelName:qi,backendName:"cpu",kernelFunc:h$},p$={kernelName:Yi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;dS([s],"spaceToBatchND");const o=Lr(a),l=[[0,0]];l.push(...i);for(let m=1+a.length;m<s.shape.length;++m)l.push([0,0]);const u=AE.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=mg(u.shape,a,o,!1),h=bg(c.length,a.length,!1),d=yg(u.shape,a,o,!1),p=XC({inputs:{x:u},backend:n,attrs:{shape:c}}),f=UI({inputs:{x:p},backend:n,attrs:{perm:h}}),g=XC({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}},f$={kernelName:Zi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,p,f,g]=cC(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}},g$={kernelName:eo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,h]=hC(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}},m$={kernelName:to,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=dC(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},b$={kernelName:no,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=dC(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},y$={kernelName:ro,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Op(0,s,o),p=!1,f=n.bufferSync(s);let g;switch(a.dtype){case"bool":g=rC(f,n.bufferSync(a),o,d,c,u,l,h,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":case"int32":g=rC(f,n.bufferSync(a),o,d,c,u,l,h,n.data.get(i.dataId).values[0],p);break;case"string":g=rC(f,n.bufferSync(a),o,d,c,u,l,h,al(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,g.dtype,g.values)}},x$={kernelName:Qi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Vr(i,s.shape)[0],l=Gg(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=lC({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},v$={kernelName:ao,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;dS(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){const e=s[i];a[i]=e*e}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},w$=PS(So,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),k$={kernelName:So,backendName:"cpu",kernelFunc:w$},S$={kernelName:oo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;dS(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:x,strides:v}=eg(s.shape,a,i,o,l,u,c,h,d);let w;if(g)w=XC({inputs:{x:s},backend:n,attrs:{shape:f}});else if(m||b){Or(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=Wf(y,x,v),t=lC({inputs:{x:s},backend:n,attrs:{begin:y,size:e}});w=XC({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=wC(p,n.bufferSync(s),v,y);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}},I$={kernelName:lo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,g]=SC(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}},C$={kernelName:uo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,h]=CC(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},T$={kernelName:co,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=TC(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},N$=PS(po,(e=>Math.tan(e))),E$={kernelName:po,backendName:"cpu",kernelFunc:N$},$$=PS(fo,(e=>Math.tanh(e)));function R$(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Rr(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Rr(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Rr(0,e,t-1)}(e,t);default:return e}}function A$(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function _$(e,t,n,r,s,a,i,o,l,u,c){return A$(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function O$(e,t,n,r,s,a,i,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*A$(e,t,n,r,s,a,i,h,d,u,c)+(l-d)*A$(e,t,n,r,s,a,i,h,f,u,c))+(o-h)*((f-l)*A$(e,t,n,r,s,a,i,p,d,u,c)+(l-d)*A$(e,t,n,r,s,a,i,p,f,u,c))}const D$={kernelName:vo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),h=s.shape.slice();h[a]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[a]=p;const e=lC({inputs:{x:s},backend:n,attrs:{begin:c,size:h}});d[p]=XC({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}},F$={kernelName:wo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;dS(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-a.shape.length;let c=a;for(let d=0;d<u;++d){const e=wN({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=e,l.push(e)}for(let d=0;d<i;++d){const e=tl(d,"int32"),t=n.makeTensorInfo([],"int32",e),r=jS({inputs:{a:t,b:c},backend:n}),a=TS({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=OI({inputs:{a:a,b:s},backend:n}),u=uN({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(a),l.push(i),l.push(u)}const h=$E({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},L$=[ZC,mS,tT,rT,OS,sT,aT,iT,oT,lT,cT,dT,fT,bT,xT,ST,IT,CT,TT,JC,NT,ET,$T,zS,RT,NS,VS,_T,xS,OT,zT,PT,BT,UT,WT,VT,GT,jT,KT,XT,YT,QT,JT,ZT,tN,nN,rN,sN,aN,iN,oN,lN,hN,MC,dN,qS,vN,YS,kN,ZS,$N,AN,_N,nI,aI,ON,DN,FN,LN,cI,pI,kS,zN,FT,PN,UN,VN,BC,mI,xI,GN,SI,jN,XN,QN,eE,tE,nE,sE,NI,aE,iE,oE,lE,uE,cE,hE,RI,dE,gE,yE,DI,LI,vE,kE,IE,PI,CE,EE,RE,AE,DE,VC,GI,FE,LE,zE,ME,IS,CN,BE,HC,qC,YC,UE,WE,VE,GE,HE,jE,KE,nC,XE,JE,ZE,r$,iC,a$,o$,u$,uC,bE,d$,p$,f$,g$,m$,b$,y$,x$,gC,v$,yC,vC,k$,S$,I$,C$,T$,RC,cN,E$,{kernelName:fo,backendName:"cpu",kernelFunc:$$},{kernelName:Mi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Op(0,s,r.shape),h=n.bufferSync(s),d=n.bufferSync(a),p=n.bufferSync(r),f=rC(h,d,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}},{kernelName:go,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;dS(s,"tile");const i=AC(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:mo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;dS(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=DC(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:bo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=s.shape,[f,g]=null!=u?u:[h,d],m=[c,f,g,p],b=es(s.shape),y=b[0],x=b[1],v=b[2],w=es(m),k=w[0],S=w[1],I=w[2],C=Hr(s.dtype,Lr(m));C.fill(l);const T=r.data.get(s.dataId).values,N=r.data.get(a.dataId).values;for(let E=0;E<c;++E){const e=1===a.shape[0]?N:N.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<g;++n)for(let r=0;r<p;++r){let s;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const u=(e[0]*n+e[1]*t+e[2])/a,c=(e[3]*n+e[4]*t+e[5])/a,p=R$(u,d,o),f=R$(c,h,o);switch(i){case"nearest":s=_$(T,h,d,y,x,v,E,f,p,r,l);break;case"bilinear":s=O$(T,h,d,y,x,v,E,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}C[E*k+t*S+n*I+r]=s}return r.makeTensorInfo(m,s.dtype,C)}return{dataId:r.write(C,m,s.dtype),shape:s.shape,dtype:s.dtype}}},WI,{kernelName:xo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;dS(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=FC(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},D$,F$,NE];for(const FP of L$)Do(FP);const z$={},M$={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function P$(e,t){if(!(e in z$)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(ps().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete z$[e]}),!1),ps().getBool("SOFTWARE_WEBGL_ENABLED")&&(M$.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",M$)||n.getContext("experimental-webgl",M$):n.getContext("webgl2",M$)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;z$[e]=n}const n=z$[e];return null==n||n.isContextLost()?(delete z$[e],P$(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),z$[e])}var B$,U$,W$,V$,G$,H$;function j$(e,t){return[t,e]}function q$(e){const t=Lr(e);return Pr(Math.ceil(t/4))}function K$(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function X$(e,t){const n=e;let r,s,a,i,o,l,u,c,h,d;return 2===ps().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function Y$(e,t){const n=t();return ps().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function Q$(e){return!!(ps().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function J$(e,t){return iR(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}(U$=B$||(B$={}))[U$.DENSE=0]="DENSE",U$[U$.SHARED_BATCH=1]="SHARED_BATCH",(V$=W$||(W$={}))[V$.RENDER=0]="RENDER",V$[V$.UPLOAD=1]="UPLOAD",V$[V$.PIXELS=2]="PIXELS",V$[V$.DOWNLOAD=3]="DOWNLOAD",(H$=G$||(G$={}))[H$.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",H$[H$.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",H$[H$.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",H$[H$.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",H$[H$.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16";const Z$=/ERROR: [0-9]+:([0-9]+):/g;function eR(e,t){const n=Z$.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>Br((t+1).toString(),a)+e));let o=0;for(let h=0;h<i.length;h++)o=Math.max(i[h].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Br(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function tR(e,t){if(Y$(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function nR(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(Y$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),Y$(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),Y$(e,(()=>e.enableVertexAttribArray(o))),!0)}function rR(e,t,n){Y$(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),Y$(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function sR(e,t){Y$(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),Y$(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function aR(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function iR(e,t,n){const r=Y$(e,(()=>t()));if(null==r)throw new Error(n);return r}function oR(e,t=2){return Lr(e.slice(0,e.length-t))}function lR(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function uR(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[oR(e),...lR(e)]),t}function cR(e){return e%2==0}function hR(e,t){if(zr(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(cR(n)&&cR(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&cR(e[0])&&cR(t[0])}let dR,pR;function fR(e,t){return null!=e.getExtension(t)}function gR(e){try{if(null!=P$(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function mR(e){const t=X$(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function bR(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Or("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const yR=ps();function xR(){let e,t,n,r,s,a,i,o,l,u;return 2===ps().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=ps().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function vR(e,t,n="index"){const r=es(t);return r.map(((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function wR(e,t,n="index"){const r=es(t);return r.map(((t,s)=>`int ${e[s]} = ${n} / outShapeStrides[${s}]; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`)).join("")}function kR(e){const t=es(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}yR.registerFlag("HAS_WEBGL",(()=>yR.getNumber("WEBGL_VERSION")>0)),yR.registerFlag("WEBGL_VERSION",(()=>gR(2)?2:gR(1)?1:0)),yR.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),yR.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===yR.get("WEBGL_VERSION"))),yR.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),yR.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),yR.registerFlag("WEBGL_PACK",(()=>yR.getBool("HAS_WEBGL"))),yR.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_CLIP",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_REDUCE",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_LAZILY_UNPACK",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_CONV_IM2COL",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>yR.getBool("WEBGL_PACK"))),yR.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==dR){const t=P$(e);dR=t.getParameter(t.MAX_TEXTURE_SIZE)}return dR}(yR.getNumber("WEBGL_VERSION")))),yR.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==pR){const t=P$(e);pR=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,pR)}(yR.getNumber("WEBGL_VERSION")))),yR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=yR.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=P$(e);return t=fR(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:fR(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),yR.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>yR.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!jl())),yR.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=P$(e);if(1===e){if(!fR(t,"OES_texture_float"))return!1}else if(!fR(t,"EXT_color_buffer_float"))return!1;return mR(t)}(yR.getNumber("WEBGL_VERSION")))),yR.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!yR.getBool("WEBGL_FORCE_F16_TEXTURES")&&yR.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),yR.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>function(e){if(0===e)return!1;const t=P$(e);if(1!==e){if(fR(t,"EXT_color_buffer_float"))return mR(t);const e="EXT_color_buffer_half_float";if(fR(t,e)){const n=t.getExtension(e);return function(e,t){const n=X$(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}(t,n)}return!1}return!!fR(t,"OES_texture_float")&&!!fR(t,"WEBGL_color_buffer_float")&&mR(t)}(yR.getNumber("WEBGL_VERSION")))),yR.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=yR.getNumber("WEBGL_VERSION"))&&null!=P$(e).fenceSync;var e})),yR.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>yR.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),yR.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),yR.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>jl()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),yR.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),yR.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),yR.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),yR.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),yR.registerFlag("WEBGL_EXP_CONV",(()=>!1)),yR.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>yR.getBool("IS_TEST"))),yR.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),yR.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),yR.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),yR.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const SR="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:IR}=im;function CR(e,t,n){const r=[];if(e.forEach((e=>{const t=Lr(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=FR(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),a=e.map((e=>function(e,t,n=!1,r){let s="";s+=n?NR(e,r):TR(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=IR(e.shapeInfo.logicalShape,t.logicalShape),l=DR(i),u=i-a;let c;const h=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${h[e+u]} = 0;`)).join("\n");let d="";d=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+u]}`)).join(", ");let p="return outputValue;";const f=1===Lr(e.shapeInfo.logicalShape),g=1===Lr(t.logicalShape);if(1!==a||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&zr(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=DR(l),c=IR(e.shapeInfo.logicalShape,t.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${r}(${f});\n    }\n  `}(e,t)),s}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=xR(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,h=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${ER}\n    ${$R}\n    ${RR}\n  `}(o);return t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(zr(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return zr(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${wR(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=vR(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${wR(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=vR(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=vR(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=vR(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=AR),[h,l,c,s,u,a,n.userCode].join("\n")}function TR(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=_R(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${OR(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=_R(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&zr(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Gr(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${TR(LR(e,l),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${zR(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${OR(e)}\n      }\n    `;const u=a[0],c=a[1],h=_R(r);return 1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Gr(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${TR(LR(e,u),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${zR(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${OR(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;if(d===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=_R(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=Gr(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${TR(LR(e,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${zR(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${OR(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const b=_R(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${g}\n      ${m}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${b});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=Gr(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${TR(LR(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${zR(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${OR(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${_R(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Gr(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${TR(LR(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${zR(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${OR(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==h)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${_R(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function NR(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${xR().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=xR();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=xR();if(null!=a&&zr(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${NR(LR(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${zR(a,r)});\n        }\n      `}const o=xR();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=xR();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(a[i-1]/2);let d=h*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<i-1;g++)p=`int b${g}, `+p,d*=a[i-g-1],f=`b${g} * ${d} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const ER="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$R="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",RR="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",AR="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function _R(e){return`offset${e}`}function OR(e){const t=e.name,n=Lr(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function DR(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function FR(e,t,n){const{newShape:r,keptDims:s}=Gr(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,l=!e&&a>1&&!zr(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function LR(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function zR(e,t){return t.map((t=>e[t])).join(", ")}function MR(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===ps().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of t.variableNames){const s={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(s.shape=e.getUniformLocation(n,`${h}Shape`,c),s.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),r.push(s)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const h of t.customUniforms)s.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function PR(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!zr(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!zr(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function BR(e){return ps().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class UR{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=B$.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=xR();this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?wR(["r","c","d"],e):vR(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class WR{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=B$.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=xR();this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?wR(["r","c","d"],e):vR(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class VR{constructor(e){this.variableNames=["A"],this.outTexUsage=W$.DOWNLOAD;const t=xR();this.outputShape=e,this.userCode=`\n      ${SR}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class GR{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=W$.DOWNLOAD;const t=xR();this.outputShape=e,this.userCode=`\n      ${SR}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const HR={R:0,G:1,B:2,A:3};class jR{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=xR();this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){const e=n[i];a+=`\n          if(offset == ${i}) {\n            result = values[${HR[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kR(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class qR{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=xR();this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let t=0;t<=1;t++){const s=2*a+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${a};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kR(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function KR(e,t,n,r,s,a){!function(e,t){const n=ps().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return iR(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return Y$(e,(()=>e.bindTexture(o,i))),Y$(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),Y$(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),Y$(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),Y$(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===ps().getNumber("WEBGL_VERSION")?Y$(e,(()=>e.texImage2D(o,0,r,t,n,0,s,a,null))):Y$(e,(()=>e.texStorage2D(o,1,r,t,n))),Y$(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function XR(e){return e.internalFormatFloat}function YR(e){return e.internalFormatHalfFloat}function QR(e){return e.downloadTextureFormat}function JR(e){return e.internalFormatPackedFloat}function ZR(e){return e.internalFormatPackedHalfFloat}class eA{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ps().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){z$[e]=t}(t,e)):this.gl=P$(t),e=this.gl,2===ps().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>Y$(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>Y$(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>Y$(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>Y$(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Y$(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>Y$(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>Y$(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>Y$(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===ps().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=J$(this.gl,e),fR(this.gl,t))this.textureHalfFloatExtension=J$(this.gl,t);else if(ps().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),fR(this.gl,r))this.colorBufferHalfFloatExtension=J$(this.gl,r);else if(ps().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",fR(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!fR(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=iR(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Y$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),Y$(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=iR(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return Y$(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),Y$(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return iR(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=X$(this.gl,this.textureHalfFloatExtension)}get debug(){return ps().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Y$(e,(()=>e.finish())),Y$(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),Y$(e,(()=>e.deleteFramebuffer(this.framebuffer))),Y$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),Y$(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),Y$(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=j$(t,n);return KR(e,s,a,XR(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=j$(t,n);return KR(e,s,a,YR(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=j$(t,n);return KR(e,s,a,QR(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){Y$(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===ps().getNumber("WEBGL_VERSION")?Y$(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):Y$(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===ps().getNumber("WEBGL_VERSION")?Y$(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):Y$(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),Y$(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,l;Y$(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),2===ps().getNumber("WEBGL_VERSION")?Y$(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):Y$(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),Y$(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=K$(t,n);return KR(e,s,a,ZR(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=K$(t,n);return KR(e,s,a,JR(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(sR(this.gl,this.framebuffer),this.outputTexture=null),Y$(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[s,a]=j$(t,n),i=new Uint8Array(t*n*4);return Y$(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return function(e,t,n,r,s,a,i){const o=e,l=new Float32Array(function(e,t){const[n,r]=K$(e,t);return n*r*4}(a,i));return o.bindBuffer(o.PIXEL_PACK_BUFFER,t),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,l),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();Y$(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return Y$(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),Y$(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),Y$(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(ps().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return Y$(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=function(e){const t=xR();return function(e,t){const n=iR(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(Y$(e,(()=>e.shaderSource(n,t))),Y$(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const n=function(e){return iR(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);Y$(t,(()=>t.attachShader(n,this.vertexShader))),Y$(t,(()=>t.attachShader(n,e))),function(e,t){if(Y$(e,(()=>e.linkProgram(t))),!ps().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&tR(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Y$(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){Y$(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),nR(e,t,"clipSpacePos",n,3,20,0)&&nR(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(Y$(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&tR(this.gl,this.program),Y$(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return iR(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Y$(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,r){Y$(e,(()=>function(e,t,n){!function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)}(e,n),Y$(e,(()=>e.activeTexture(e.TEXTURE0+n))),Y$(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),Y$(e,(()=>e.uniform1i(n,r)))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=K$(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&tR(this.gl,this.program),aR(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Y$(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Y$(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=J$(this.gl,2===ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Ur((()=>this.disposed||this.isQueryAvailable(e,ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in ps().platform&&(n=ps().platform.setTimeoutCustom.bind(ps().platform)),Ur((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),rR(this.gl,e,this.framebuffer),this.debug&&aR(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(rR(this.gl,this.outputTexture,this.framebuffer),this.debug&&aR(this.gl)):sR(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;rR(r,e,this.framebuffer),this.debug&&aR(r),this.outputTexture=e,Y$(r,(()=>r.viewport(0,0,t,n))),Y$(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),Y$(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:tA,bincountImpl:nA,bincountReduceImpl:rA,bitwiseAndImpl:sA,castImpl:aA,ceilImpl:iA,concatImpl:oA,equalImpl:lA,expImpl:uA,expm1Impl:cA,floorImpl:hA,gatherNdImpl:dA,gatherV2Impl:pA,greaterImpl:fA,greaterEqualImpl:gA,lessImpl:mA,lessEqualImpl:bA,linSpaceImpl:yA,logImpl:xA,maxImpl:vA,maximumImpl:wA,minimumImpl:kA,multiplyImpl:SA,negImpl:IA,notEqualImpl:CA,prodImpl:TA,raggedGatherImpl:NA,raggedRangeImpl:EA,raggedTensorToTensorImpl:$A,rangeImpl:RA,rsqrtImpl:AA,scatterImpl:_A,sigmoidImpl:OA,simpleAbsImpl:DA,sliceImpl:FA,sparseFillEmptyRowsImpl:LA,sparseReshapeImpl:zA,sparseSegmentReductionImpl:MA,sqrtImpl:PA,staticRegexReplaceImpl:BA,stridedSliceImpl:UA,stringNGramsImpl:WA,stringSplitImpl:VA,stringToHashBucketFastImpl:GA,subImpl:HA,tileImpl:jA,topKImpl:qA,transposeImpl:KA,uniqueImpl:XA}=LC;function YA(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function QA(e,t){return 1===t?[e]:YA(e,t)}class JA{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=BR(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=QA("rc",this.rank),t=DR(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class ZA{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2==1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${a}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${a>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?function(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}(e.map(((e,t)=>t)),t);return r.map(((t,s)=>`int ${e[s]} = ${n} / ${r[s]}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`};`)).join("")}(["r","c","d"],"inputShape"):vR(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kR(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class e_{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=n_(t,n),s=r_(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=t_(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===G$.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===G$.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===G$.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===G$.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===G$.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=n_(n,r),a=r_(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=t_(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=ps().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function t_(e,t,n,r,s){const a=function(e,t){switch(e){case G$.PACKED_2X2_FLOAT32:return JR(t);case G$.PACKED_2X2_FLOAT16:return ZR(t);case G$.UNPACKED_FLOAT32:return XR(t);case G$.UNPACKED_FLOAT16:return YR(t);case G$.PACKED_4X1_UNSIGNED_BYTE:return QR(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=K$(e[0],e[1]);i=t*n}else{const[t,n]=j$(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function n_(e,t){if(e===W$.UPLOAD)return G$.PACKED_2X2_FLOAT32;if(e===W$.RENDER||null==e)return function(e){return ps().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?G$.PACKED_2X2_FLOAT32:G$.UNPACKED_FLOAT32:e?G$.PACKED_2X2_FLOAT16:G$.UNPACKED_FLOAT16}(t);if(e===W$.DOWNLOAD||e===W$.PIXELS)return G$.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function r_(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class s_{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const a_="if (isnan(x)) return x;",i_="return abs(x);",o_=a_+"\n  return (x < 0.0) ? 0.0 : x;\n",l_=a_+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",u_="return x;";class c_{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class h_{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length);const t=e.length,n=QA("rc",t),r=DR(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const d_=Pp,p_={},f_=ps().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class g_ extends Nr{nextDataId(){return g_.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ps().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof eA)t=e;else{const n=P$(ps().getNumber("WEBGL_VERSION"),e);t=new eA(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=P$(ps().getNumber("WEBGL_VERSION"));t=new eA(e),this.binaryCache=((n=ps().getNumber("WEBGL_VERSION"))in p_||(p_[n]={}),p_[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new e_(this.gpgpu),this.numMBBeforeWarning=null==ps().global.screen?1024:ps().global.screen.height*ps().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Tr(this,iu())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const l=uR(t),u=new jR(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((ps().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ps().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:W$.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if(ps().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:W$.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new c_(i,u_):new s_(i,u_);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;return l&&(u=rl()),c="complex64"===r?$g(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),l&&(this.downloadWaitMs+=rl()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new c_(r,u_):new s_(r,u_);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(ps().getBool("DEBUG")&&!ps().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ps().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==a&&ps().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...q$(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=$g(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=Lr(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;Y$(e,(()=>e.deleteBuffer(c)))}const h=this.convertAndCacheOnCPU(e,u),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&iu().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new c_(s,u_):new s_(s,u_);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=iu().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>al(e)));return Hu(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Hu(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!Q$(n)){if(ps().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Lr(t);if(ps().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...q$(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=ps().getBool("WEBGL_PACK")&&!0===r,i=a?uR(t):t,o=a?new GR(i):new VR(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=ol(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=ol(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:rl(),endMs:null}}endTimer(e){return ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=rl(),e)}async getQueryTime(e){if(ps().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=f_){return ps().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Lr(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Eo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return d_(e.shape,t)}packedUnaryOp(e,t,n){const r=new c_(e.shape,t),s=this.compileAndRun(r,[e],n);return iu().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=DA(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(ps().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,i_,e.dtype);const t=new s_(e.shape,i_),n=this.compileAndRun(t,[e]);return iu().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Xr(n[0])){const s=n.map((e=>sl(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return iu().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new h_(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new JA(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[oR(e.shape),...lR(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[oR(t),...lR(t)],a=new ZA(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;null!=t&&Or(Lr(s)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."));const i=uR(s);let o;o=r?new WR(i):new UR(i);const l=[null!=t?t:q$(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,s=!1,a){const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===B$.DENSE){const t=null!=a?a:q$(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Lr(i.shape))return o.values=Hr(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Lr(t.shape)<=ps().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!hR(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},h=function(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=FR(e.packedInputs,t.shape,a);let u="",c="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=es(o);h=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const d=t.shape.length,p=2===o.length&&zr(t.shape,a),f=1===Lr(t.shape),g=lh(t.shape,n.shape),m=!e.packedInputs&&d===n.shape.length&&zr(a,n.texData.texShape),b=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${d}_${m}_${i?l:""}_${o.length}_${f}_${g}_${p}_${u}_${c}_${h}_${b}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${ps().getNumber("WEBGL_VERSION")}`,a}(e,u,c),d=this.getAndSaveBinary(h,(()=>function(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=s.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=CR(s,i,t),l=function(e,t){const n=iR(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(Y$(e,(()=>e.shaderSource(n,t))),Y$(e,(()=>e.compileShader(n))),ps().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw eR(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return ps().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},MR(e,t,u)))}(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),ps().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(PR(t.inShapeInfos,n),PR([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===ps().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:s,offset:a,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=FR(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=s)if(r.isUniform)if(Lr(r.shape)<2)e.gl.uniform1f(s,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=r.texData.slice&&null!=a&&e.gl.uniform1i(a,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,s,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=es(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],a=s[l];if("float"===n.type)e.gl.uniform1fv(r,a);else if("vec2"===n.type)e.gl.uniform2fv(r,a);else if("vec3"===n.type)e.gl.uniform3fv(r,a);else if("vec4"===n.type)e.gl.uniform4fv(r,a);else if("int"===n.type)e.gl.uniform1iv(r,a);else if("ivec2"===n.type)e.gl.uniform2iv(r,a);else if("ivec3"===n.type)e.gl.uniform3iv(r,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,a)}}e.executeProgram()}(this.gpgpu,d,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const g=ps().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const e=rl();e-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!ps().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ps().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=lu((()=>{if(!ps().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ps().getBool("DEBUG");ps().set("DEBUG",!1);const t=this.abs(Rh(1e-8)).dataSync()[0];if(ps().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=rl());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=ps().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ps().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&ps().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Ar(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Gr(e);e=t.newShape}let s=Lr(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=oR(e);let n=2,r=2;e.length&&([n,r]=lR(e)),s=t*(n/2)*(r/2),a=Pr(s).map((e=>2*e))}else a=Pr(s);return a}(n,o),t.texShape=c),null!=s){const e=uR(n);let a,i=c[1],h=c[0];const d=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&d||([i,h]=K$(c[0],c[1])),a=o?new qR(e,d):new jR(e,d);const p=d?[h,i]:c,f=this.makeTensorInfo(p,r),g=this.texData.get(f.dataId);g.usage=d?W$.PIXELS:W$.UPLOAD,g.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,h,s);const m=[[h,i]],b=!0,y=this.runWebGLProgram(a,[f],r,m,b),x=this.texData.get(y.dataId);t.texShape=x.texShape,t.isPacked=x.isPacked,t.usage=x.usage,ps().get("ENGINE_COMPILE_ONLY")?this.disposeData(y.dataId):(t.texture=x.texture,t.values=null,this.texData.delete(y.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=rl()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Kr(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await ag(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw eR(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=MR(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=iu().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,s,a,i);return iu().makeTensorFromDataId(l,t,n,o)}}g_.nextDataId=0,ql()&&hu("webgl",(()=>new g_),2);const m_="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class b_{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=ch(t,n),this.enableShapeUniforms=BR(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const y_="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class x_{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ch(t,n);const s=this.outputShape.length;this.enableShapeUniforms=BR(s);let a="";if(r)if(0===s||1===Lr(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${DR(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=QA("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function v_(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const w_={kernelName:_a,backendName:"webgl",kernelFunc:v_};function k_(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=v_({inputs:{x:r},backend:n}),l=v_({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const S_={kernelName:Gs,backendName:"webgl",kernelFunc:k_},I_="return (a < 0.) ? b * a : a;",C_="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",T_={kernelName:Ma,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",tl(a,"float32")),o=ps().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new x_(C_,s.shape,i.shape):new b_(I_,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},N_="return (a < 0.) ? b * a : a;",E_="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",$_={kernelName:xi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=ps().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new x_(E_,r.shape,s.shape):new b_(N_,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},R_="if (isnan(x)) return x;";function A_({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,l);return o.makeTensorInfo(i.shape,l,t)}let u;return u=ps().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new c_(i.shape,t):new s_(i.shape,e),o.runWebGLProgram(u,[i],l)}}function __({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&"complex64"===l.dtype){const t=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:l.shape},a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new b_(e,l.shape,u.shape);return c.runWebGLProgram(i,[s,a],Ol(n.dtype,r.dtype))})),a=k_({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),a}const h=a||Ol(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const e=c.texData.get(l.dataId).values,t=c.texData.get(u.dataId).values,n="string"===l.dtype?sm(e):e,r="string"===l.dtype?sm(t):t,[a,i]=s(l.shape,u.shape,n,r,h),o=c.makeTensorInfo(i,h);return c.texData.get(o.dataId).values=a,o}let d;return d=ps().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new x_(t,l.shape,u.shape,n):new b_(e,l.shape,u.shape),c.runWebGLProgram(d,[l,u],h)}}function O_(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":o_;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":l_;if("prelu"===e)return t?E_:N_;if("leakyrelu"===e)return t?C_:I_;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class D_{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=BR(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),h=r?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",m="";i&&(g=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,m="result = activation(result);");const b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${y};\n        int batchB = ${x};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class F_{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ch(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const L_="return a * b;";function z_(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=Ol(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new F_("return areal * breal - aimag * bimag;",r.shape,s.shape),i=new F_("return areal * bimag + aimag * breal;",r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=k_({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=SA(r.shape,s.shape,e.values,t.values,a),l=n.makeTensorInfo(o,a);return n.texData.get(l.dataId).values=i,l}let i;return i=ps().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new x_(L_,r.shape,s.shape):new b_(L_,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const M_={kernelName:li,backendName:"webgl",kernelFunc:z_};function P_(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Lr(s.shape),l=Wr(a,o),u=Lr(l);Or(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(s.dataId);return!c.isPacked||hR(s.shape,l)||null!==c.texture&&hR(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[oR(e.shape),...lR(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[oR(t),...lR(t)],i=new ZA(a,r),o=[r],l=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(s,l,i)}const B_={kernelName:Ei,backendName:"webgl",kernelFunc:P_};class U_{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${Mr(e)?e.toPrecision(2):e}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class W_{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function V_(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=fg(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,h;c="mean"===n?0===i?new U_({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new U_({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new W_({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=a,a=r.runWebGLProgram(c,[a],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return a}class G_{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const r=DR(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class H_{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=DR(this.rank),s=YA("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function j_(e,t,n){const r=ps().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new H_(e.shape,t):new G_(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function q_(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=Vr(s,e.shape);let o=i;const l=Ih(o,a),u=null!=l;let c=e;u&&(c=j_(e,l,r),o=Th(o.length,a)),Sh("sum",o,a);const[h,d]=wh(c.shape,o);let p=h;n&&(p=kh(h,i));const f=Lr(d),g=P_({inputs:{x:c},attrs:{shape:[Lr(e.shape)/f,f]},backend:r}),m=V_(g,Dl(e.dtype),"sum",r),b=P_({inputs:{x:m},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(m),u&&r.disposeIntermediateTensorInfo(c),b}(s,a,i,n)}const K_={kernelName:Xi,backendName:"webgl",kernelFunc:q_};function X_(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=KA(e,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=t}else u=j_(s,a,i);return u}const Y_={kernelName:yo,backendName:"webgl",kernelFunc:X_};function Q_({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,h=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],g=e.shape.slice(0,-2),m=t.shape.slice(0,-2),b=Lr(g),y=Lr(m),x=ch(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);Or(h===d,(()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const v=n?[b,h,p]:[b,p,h],w=r?[y,f,d]:[y,d,f],k=P_({inputs:{x:e},backend:s,attrs:{shape:v}}),S=P_({inputs:{x:t},backend:s,attrs:{shape:w}}),I=[k,S],C=Math.max(b,y),T=n?k.shape[1]:k.shape[2],N=null!=a,E=null!=i,$="leakyrelu"===l,R=null!=l?O_(l,!0):null;let A;if((1===p||1===f)&&T>1e3&&!1===(N||E||$||null!=R)){let e=k,t=S;n&&(e=X_({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),I.push(e)),r&&(t=X_({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),I.push(t));const a=1===f;let i=e;1!==f&&(i=P_({inputs:{x:e},backend:s,attrs:{shape:[C,T,1]}}),I.push(i));const o=1===f?2:1;let l=t;a&&(l=P_({inputs:{x:t},backend:s,attrs:{shape:[C,1,T]}}),I.push(l));const u=z_({inputs:{a:i,b:l},backend:s});A=q_({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),I.push(u)}else{const l=Ol(e.dtype,t.dtype),u=new D_(v,w,[C,p,f],n,r,N,R,E,$),c=[k,S];if(null!=a&&c.push(a),E&&c.push(i),$){const e=s.makeTensorInfo([],"float32",tl(o,"float32"));c.push(e),I.push(e)}A=s.runWebGLProgram(u,c,l)}const _=P_({inputs:{x:A},backend:s,attrs:{shape:x}});I.push(A);for(const O of I)s.disposeIntermediateTensorInfo(O);return _}const J_={kernelName:Co,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return Q_({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},Z_="return abs(x);",eO={kernelName:ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=DA(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=ps().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new c_(r.shape,Z_):new s_(r.shape,Z_),n.runWebGLProgram(s,[r],r.dtype)}},tO=A_({opSnippet:a_+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),nO={kernelName:xs,backendName:"webgl",kernelFunc:tO},rO=A_({opSnippet:a_+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),sO={kernelName:vs,backendName:"webgl",kernelFunc:rO},aO="return a + b;",iO=__({opSnippet:aO,packedOpSnippet:aO,supportsComplex:!0,cpuKernelImpl:tA}),oO={kernelName:ws,backendName:"webgl",kernelFunc:iO};class lO{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class uO{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const cO={kernelName:ks,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return v_({inputs:{x:s[0]},backend:r});if(s.length>ps().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map((e=>e.dtype)).reduce(((e,t)=>Ol(e,t))),i=s.map((e=>e.shape)),o=ps().getBool("WEBGL_PACK")?new uO(s[0].shape,i):new lO(s[0].shape,i);return r.runWebGLProgram(o,s,a)}},hO={kernelName:Ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Vr(a,s.shape);let u=l;const c=Ih(u,o);let h=s;null!=c&&(h=X_({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Th(u.length,o)),Sh("all",u,o);const[d,p]=wh(h.shape,u),f=P_({inputs:{x:h},backend:n,attrs:{shape:[-1,Lr(p)]}}),g=V_(f,f.dtype,"all",n);let m;return m=P_(i?{inputs:{x:g},backend:n,attrs:{shape:kh(d,l)}}:{inputs:{x:g},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),m}},dO={kernelName:Is,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Vr(a,s.shape);let u=l;const c=Ih(u,o);let h=s;null!=c&&(h=X_({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Th(u.length,o)),Sh("any",u,o);const[d,p]=wh(h.shape,u),f=P_({inputs:{x:h},backend:n,attrs:{shape:[-1,Lr(p)]}}),g=V_(f,f.dtype,"any",n);let m;return m=P_(i?{inputs:{x:g},backend:n,attrs:{shape:kh(d,l)}}:{inputs:{x:g},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),m}};class pO{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class fO{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Or(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=DR(o),u=QA("coords",o);let c,h;if(1===a){h=o+1;const e=DR(h);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),g=QA("sourceLocR",h-1).concat("inIdx.r"),m=QA("sourceLocG",h-1).concat("inIdx.g"),b=QA("sourceLocB",h-1).concat("inIdx.b"),y=QA("sourceLocA",h-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",v=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,w=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function gO(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=fg(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new pO(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=gO(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function mO(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=fg(s[s.length-1]),i=new fO(s,a,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=mO(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function bO(e,t,n,r){const s=[n];if(Sh("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ps().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=wh(i.shape,s),u=Lr(l),c=P_({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const h=gO(e,c,r);n.push(h);const d=P_({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return mO(e,t,r)}const yO={kernelName:Cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Vr(a,s.shape);const o=Ih(i,s.shape.length);let l=s;const u=[];null!=o&&(l=X_({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Th(i.length,l.shape.length)),Sh("argMax",[i[0]],l.shape.length);const c=bO(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},xO={kernelName:Ts,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Vr(a,s.shape);const o=Ih(i,s.shape.length);let l=s;const u=[];null!=o&&(l=X_({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Th(i.length,l.shape.length)),Sh("argMin",[i[0]],l.shape.length);const c=bO(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},vO=A_({opSnippet:a_+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),wO={kernelName:Ns,backendName:"webgl",kernelFunc:vO},kO=A_({opSnippet:a_+"return log(x + sqrt(x * x + 1.0));"}),SO={kernelName:Es,backendName:"webgl",kernelFunc:kO},IO=A_({opSnippet:a_+"\n  return atan(x);\n"}),CO={kernelName:$s,backendName:"webgl",kernelFunc:IO},TO=__({opSnippet:m_+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+y_+"\n  return result;\n"}),NO={kernelName:As,backendName:"webgl",kernelFunc:TO},EO=A_({opSnippet:a_+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),$O={kernelName:Rs,backendName:"webgl",kernelFunc:EO};class RO{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,m=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?g:m:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let y=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(y="avgValue / max(count, 1.0)");const x=4*Math.floor(a/4),v=a%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${y});\n      }\n    `}}class AO{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,g=e.padInfo.front,m=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const y="avg"===t;let x="0.0";if(y||(x="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${g}, ${m}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(a/4),k=a%4,S=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${g}, ${m}, ${b});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${v});\n      }\n    `}}const _O={kernelName:_s,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;bR(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Or(wc(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hc(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&zr(u.inShape,u.outShape))return v_({inputs:{x:s},backend:n});const c=new RO(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},OO={kernelName:Ds,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=dc(s.shape,a,i,[1,1,1],o,l,u),h=new AO(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class DO{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FO{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=h-1-e.padInfo.top,g=d-1-e.padInfo.left,m=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${g});\n      const float avgMultiplier = float(${m});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const LO={kernelName:Fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=dc(i.shape,o,l,[1,1,1],u,c),d=new FO(h);return n.runWebGLProgram(d,[s],i.dtype)}},zO={kernelName:Os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;bR([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=hc(i.shape,o,l,1,u),h=new DO(c);return n.runWebGLProgram(h,[s],i.dtype)}},MO={kernelName:Ls,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return Q_({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class PO{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],ch(e,t),ch(e,n);let i="0.0";null!=r&&(ch(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(ch(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class BO{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ch(e,t),ch(e,n);let i="vec4(0.0)";null!=r&&(ch(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(ch(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const UO={kernelName:Na,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;Or(s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Or(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Or(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[r,s,a];let c=null;null!=i&&(c=i.shape,u.push(i));let h=null;null!=o&&(h=o.shape,u.push(o));const d=ps().getBool("WEBGL_PACK_NORMALIZATION")?new BO(r.shape,s.shape,a.shape,c,h,l):new PO(r.shape,s.shape,a.shape,c,h,l);return t.runWebGLProgram(d,u,u[0].dtype)}};class WO{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=DR(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return VO.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${VO[t]} = start[${t}] + coords.${VO[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const VO=["x","y","z","w","u","v"];class GO{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=DR(this.rank),n=QA("coords",this.rank),r=QA("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function HO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=Zf(s,a,i);if(Uf(s,o,l),0===Lr(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=FA(e.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId),c=Qf(s.shape,o,l);if(u||!c){const e=ps().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GO(l):new WO(l),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Jf(t,es(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}(s,o,l,n)}const jO={kernelName:Wi,backendName:"webgl",kernelFunc:HO},qO={kernelName:zs,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Or(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=mg(s.shape,a,o),u=bg(l.length,a.length),c=yg(s.shape,a,o),h=xg(i,a.length),d=vg(c,i,a.length),p=[],f=P_({inputs:{x:s},backend:n,attrs:{shape:l}}),g=X_({inputs:{x:f},backend:n,attrs:{perm:u}}),m=P_({inputs:{x:g},backend:n,attrs:{shape:c}}),b=HO({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},KO={kernelName:Ms,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=nA(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}},XO={kernelName:Ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=ps().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ps().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=sA(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let o;return o=a?new x_("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new b_("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}},YO={kernelName:Bs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=ch(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},QO=__({opSnippet:"return float(a != b);",cpuKernelImpl:CA,dtype:"bool"}),JO={kernelName:ci,backendName:"webgl",kernelFunc:QO};function ZO(e){const{inputs:t,backend:n}=e,{input:r}=t;return v_({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const eD={kernelName:Ci,backendName:"webgl",kernelFunc:ZO},tD={kernelName:Us,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return v_({inputs:{x:a},backend:r});const t=bd(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=k_({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=ZO({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!qr(a.dtype,i)){const e=v_({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=aA(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new s_(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Hr("bool",1)),t=QO({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},nD="return ceil(x);",rD=A_({opSnippet:nD,packedOpSnippet:nD,cpuKernelImpl:iA}),sD={kernelName:Ws,backendName:"webgl",kernelFunc:rD};class aD{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class iD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const oD={kernelName:Vs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=ps().getBool("WEBGL_PACK_CLIP")?new iD(s.shape):new aD(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}};class lD{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function uD(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const cD={kernelName:Hs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new lD(r.shape),i=[uD(r,s.complexTensorInfos.real),uD(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class hD{constructor(e){this.outputShape=[],this.outputShape=og(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const e=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${e}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class dD{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=og(e,t);const n=this.outputShape,r=n.length,s=DR(r),a=QA("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];h+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${pD(i,l,e)}),\n            vec2(${pD(u,l,e)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${pD(i,l,p)}),\n          vec2(${pD(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function pD(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function fD(e){const{inputs:t,backend:n}=e,{input:r}=t;return v_({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const gD={kernelName:Da,backendName:"webgl",kernelFunc:fD};function mD(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>ZO({inputs:{input:e},backend:n}))),s=e.map((e=>fD({inputs:{input:e},backend:n}))),a=mD(r,t,n),i=mD(s,t,n),o=k_({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=Lr(e.shape.slice(t));return P_({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=og(s.map((e=>e.shape)),1),o=1===s[0].shape[0],l=oA(a,i,r,o),u=og(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const a=e.filter((e=>Lr(e.shape)>0)),i=ps().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new s_(e[0].shape,u_):new c_(e[0].shape,u_);return n.runWebGLProgram(t,e,r)}const o=ps().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let s=0;s<a.length;s+=o){const r=a.slice(s,s+o);e.push(mD(r,t,n))}const r=mD(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new dD(a.map((e=>e.shape)),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=og(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>P_({inputs:{x:e},attrs:{shape:[-1,Lr(e.shape.slice(t))]},backend:n}))),outShape:r}}(a,t,n),c=new hD(l.map((e=>e.shape))),h=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=P_({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function bD(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Vr(s,t[0].shape)[0];ig(t.map((e=>e.shape)),a);const i=og(t.map((e=>e.shape)),a);if(0===Lr(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Lr(e.shape)>0));return 1===o.length?v_({inputs:{x:o[0]},backend:n}):mD(o,a,n)}const yD={kernelName:js,backendName:"webgl",kernelFunc:bD};class xD{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,g="channelsLast"===e.dataFormat,m=g?1:2,b=g?2:3,y=g?3:1;let x="",v="";n&&(x=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${y}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class vD{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wD{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=BR(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let g=0;g<u;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(c+1)/2;g++){const t=2*g;if(h+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(a%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,h+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=a%2==0?Ar(o):o;o%2==0&&a%2==1||o%2!=0&&a%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):h+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(a%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(h+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(h+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(h+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class kD{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=BR(this.outputShape.length);const{dataFormat:n}=t,r=xR(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function SD(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function ID({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,h=l[0]*l[1]*l[2],d=n.outChannels,p="channelsLast"===n.dataFormat,f=!1;let g;const m=[];if(null!=a){const e=SD(a.shape,p);null!=e&&(a=P_({inputs:{x:a},backend:r,attrs:{shape:e}}),m.push(a))}if(null!=s){const e=SD(s.shape,p);null!=e&&(s=P_({inputs:{x:s},backend:r,attrs:{shape:e}}),m.push(s))}if((1!==h&&1!==d||!(c>1e3))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&zr(u.shape.slice(-3),l.slice(-3))){const c=l[0]*l[1]*(l[2]+1),h={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Or(hR(u.shape,h.shape),(()=>`packed reshape ${u.shape} to ${h.shape} isn't free`));const p=P_({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});m.push(p);const b=Q_({a:h,b:p,backend:r,transposeA:!1,transposeB:f,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),y=r.texData.get(b.dataId);Or(y.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,y.shape=n.outShape,g=v_({inputs:{x:b},backend:r}),g.shape=n.outShape,m.push(b)}else{const l=n.outHeight*n.outWidth,u=P_({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,l,n.inChannels]:[n.batchSize,n.inChannels,l]}}),c=P_({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),h=Q_({a:p?u:c,b:p?c:u,transposeA:!p,transposeB:f,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=P_({inputs:{x:h},backend:r,attrs:{shape:n.outShape}}),m.push(u),m.push(c),m.push(h)}for(const b of m)r.disposeIntermediateTensorInfo(b);return g}function CD({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,g=l*u*c,m=d*h,b=[n.batchSize,g,m],y=[];if(null!=a){const e=SD(a.shape,f);null!=e&&(a=P_({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}if(null!=s){const e=SD(s.shape,f);null!=e&&(s=P_({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}const x=P_({inputs:{x:t},backend:r,attrs:{shape:[1,g,Lr(t.shape)/g]}});y.push(x);const v=new kD(b,n),w=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(v,[e],"float32",w),S=P_({inputs:{x:k},backend:r,attrs:{shape:b}});y.push(k),y.push(S);const I=null!=s,C=null!=a,T="leakyrelu"===o,N=o?O_(o,!0):null,E=new D_(f?S.shape:x.shape,f?x.shape:S.shape,f?[n.batchSize,m,n.outChannels]:[n.batchSize,n.outChannels,m],!0,!1,I,N,C,T),$=f?[S,x]:[x,S];if(s&&$.push(s),C&&$.push(a),T){const e=r.makeTensorInfo([],"float32",tl(i,"float32"));$.push(e),y.push(e)}const R=r.runWebGLProgram(E,$,"float32"),A=P_({inputs:{x:R},backend:r,attrs:{shape:n.outShape}});y.push(R);for(const _ of y)r.disposeIntermediateTensorInfo(_);return A}const TD={kernelName:qs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=Sc(l),d=pc(s.shape,a.shape,i,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&ps().getBool("WEBGL_EXP_CONV")){const e=new wD(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[s,a],"float32",t)}else if(ps().getBool("WEBGL_CONV_IM2COL"))p=CD({x:s,filter:a,convInfo:d,backend:n});else{const e=new xD(d);p=n.runWebGLProgram(e,[s,a],"float32")}else p=ID({x:s,filter:a,convInfo:d,backend:n});const f=P_({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class ND{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ED{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $D{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class RD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const AD={kernelName:Ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=Sc(l),d=pc(s.shape,c,i,1,o,u,!1,h),p=new ND(d);return n.runWebGLProgram(p,[s,a],"float32")}};class _D{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=BR(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const OD={kernelName:Xs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=Sc(u),d=pc(i,a.shape,o,1,l,c,!1,h);if(ps().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new _D(d);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new ED(d);return n.runWebGLProgram(e,[s,a],"float32")}}},DD={kernelName:Ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=fc(s.shape,a.shape,i,l,o),c=new vD(u);return n.runWebGLProgram(c,[s,a],"float32")}},FD={kernelName:Qs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=fc(s.shape,l,i,1,o),c=new $D(u);return n.runWebGLProgram(c,[s,a],"float32")}},LD={kernelName:Js,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=fc(l,a.shape,o,1,i),c=new RD(u);return n.runWebGLProgram(c,[s,a],"float32")}},zD=A_({opSnippet:R_+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${y_}\n  return result;\n`}),MD={kernelName:Zs,backendName:"webgl",kernelFunc:zD},PD=A_({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),BD={kernelName:ea,backendName:"webgl",kernelFunc:PD};class UD{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[g,m,b]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[y,x,v]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${y});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${m};\n        float width_scale = ${x};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const WD={kernelName:ra,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new UD(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};var VD,GD;(GD=VD||(VD={})).Prod="*",GD.Sum="+";class HD{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===VD.Prod?"1.0":"0.0",i=n?a:`getX(${jD(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${DR(s)} coords = getOutputCoords();\n        int end = ${qD(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${qD(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${jD(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function jD(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function qD(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function KD(e,t,n,r,s,a){const i=t.shape.length,o=Ih([r],i);let l=t;null!=o&&(l=X_({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=Th(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=v_({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const t=new HD(e,l.shape,!1,a),r=[[d]],s=h;h=n.runWebGLProgram(t,[h],h.dtype,r),n.disposeIntermediateTensorInfo(s)}if(s){const t=new HD(e,l.shape,s,a),r=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=X_({inputs:{x:h},backend:n,attrs:{perm:Ch(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const XD={kernelName:ta,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return KD(VD.Prod,s,n,a,i,o)}},YD={kernelName:na,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return KD(VD.Sum,s,n,a,i,o)}},QD={kernelName:sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=nA(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=rA(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class JD{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const ZD={kernelName:aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),h=new JD("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(h,[s],s.dtype)}};class eF{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=BR(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class tF{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=BR(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)d+=`\n          vec4 xTexelC${2*m};\n          int xTexelC${2*m}Ready;\n          vec4 xTexelC${2*m+1};\n          int xTexelC${2*m+1}Ready;\n          vec4 xC${m};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let m=0;m<c;m++)d+=`\n          xTexelC${2*m} = vec4(0.0);\n          xTexelC${2*m}Ready = 0;\n          xTexelC${2*m+1} = vec4(0.0);\n          xTexelC${2*m+1}Ready = 0;\n          xC${m} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let m=0;m<(h+1)/2;m++){const e=2*m;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2==1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2==0?Ar(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,d+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2==1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${f}\n        setOutput(result);\n      }\n    `}}const nF={kernelName:ia,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Or(wc(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const h=pc(s.shape,a.shape,i,c,o,u,!0);let d;d=ps().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new tF(h):new eF(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[s,a],"float32",p)}};class rF{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class sF{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const aF={kernelName:oa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,h=pc(s.shape,c,i,o,l,u,!0),d=new rF(h);return n.runWebGLProgram(d,[s,a],"float32")}},iF={kernelName:la,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,h=pc(c,a.shape,i,o,l,u,!0),d=new sF(h);return n.runWebGLProgram(d,[s,a],"float32")}};class oF{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const lF={kernelName:ua,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Lr(r.shape),i=P_({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new oF(a),l=n.runWebGLProgram(o,[i],i.dtype),u=P_({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class uF{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const cF={kernelName:ca,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=cc(s.shape,a.shape,i,o,"NHWC",l);let c;const h=new uF(u);c=n.runWebGLProgram(h,[s,a],"float32");const d=P_({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}},hF={kernelName:fa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=Mg(s,a.length);Bg(i.length,l,a);const{path:u,steps:c}=Ug(o,l),h=c.length;let d=null,p=i.length;const f=[];for(let g=0;g<h;++g){for(const e of c[g]){const{permutationIndices:t,expandDims:r}=Pg(p,l[e]);let s;Wg(t)?s=a[e]:(s=X_({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);zr(s.shape,i)||(s=P_({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=z_({inputs:{a:s,b:d},backend:n}),f.push(d))}g<h-1&&(u[g]>=0&&(d=q_({inputs:{x:d},backend:n,attrs:{axis:u[g]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}},dF=A_({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),pF={kernelName:ga,backendName:"webgl",kernelFunc:dF},fF={kernelName:ma,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=ps().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new x_("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new b_("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},gF=__({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:lA}),mF={kernelName:ya,backendName:"webgl",kernelFunc:gF},bF=A_({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Sg};\n  float a1 = ${Ig};\n  float a2 = ${Cg};\n  float a3 = ${Tg};\n  float a4 = ${Ng};\n  float a5 = ${Eg};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),yF={kernelName:ba,backendName:"webgl",kernelFunc:bF},xF=A_({opSnippet:R_+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:uA,dtype:"float32"}),vF={kernelName:xa,backendName:"webgl",kernelFunc:xF};function wF(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Or(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),P_({inputs:{x:a},backend:r,attrs:{shape:o}})}const kF={kernelName:va,backendName:"webgl",kernelFunc:wF},SF="return exp(x) - 1.0;",IF=A_({opSnippet:SF,packedOpSnippet:SF,cpuKernelImpl:cA}),CF={kernelName:wa,backendName:"webgl",kernelFunc:IF};class TF{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function NF(e,t,n){const r=n.texData.get(e.dataId),s=Lr(e.shape),a=e.shape[e.shape.length-1],i=P_({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,l=new TF("real",o,t),u=new TF("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=k_({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=P_({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const EF={kernelName:ka,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return NF(r,!1,n)}};class $F{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function RF(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Qr(s),"string"===a){const e=jr(a,Lr(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new $F(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const AF={kernelName:Sa,backendName:"webgl",kernelFunc:RF};class _F{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const OF={kernelName:Ia,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new _F(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},DF="return floor(x);",FF=A_({opSnippet:DF,packedOpSnippet:DF,cpuKernelImpl:hA}),LF={kernelName:Ca,backendName:"webgl",kernelFunc:FF},zF=__({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),MF={kernelName:Ta,backendName:"webgl",kernelFunc:zF};class PF{constructor(e){this.variableNames=["A"];const t=xR(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class BF{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=xR(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const UF={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,a];if(o||i){const e=ps().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=WF&&e===VF||(VF=e,WF=document.createElement("canvas").getContext("2d",{willReadFrequently:VF})),WF.canvas.width=l,WF.canvas.height=u,WF.drawImage(s,0,0,l,u),s=WF.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=W$.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=ps().getBool("WEBGL_PACK")?new BF(h):new PF(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let WF,VF=ps().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const GF={kernelName:To,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,g=Sc(c),m=pc(s.shape,a.shape,l,h,u,d,!1,g);let b;const y=[],x=null!=i,v=null!=o,w="leakyrelu"===p,k=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=P_({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return y.push(t),t}return e};if(x&&e.push(t(i,c)),v&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",tl(f,"float32"));e.push(t),y.push(t)}return e};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&ps().getBool("WEBGL_EXP_CONV")){const e=p?O_(p,!0):null,t=new wD(m,x,e,v,w),r=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],s=k();b=n.runWebGLProgram(t,s,"float32",r)}else if(ps().getBool("WEBGL_CONV_IM2COL"))b=CD({x:s,filter:a,convInfo:m,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?O_(p,!1):null,t=new xD(m,x,e,v,w),r=k();b=n.runWebGLProgram(t,r,"float32")}else b=ID({x:s,filter:a,convInfo:m,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=P_({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return y.push(b),y.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}},HF={kernelName:No,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let g=c;null==g&&(g=[1,1]),Or(wc(l,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`));const m=pc(s.shape,a.shape,l,g,u,h,!0),b=ps().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,y=d?O_(d,b):null,x=[s,a],v=null!=i,w=null!=o,k="leakyrelu"===d;if(v&&x.push(i),w&&x.push(o),k){const e=n.makeTensorInfo([],"float32",tl(p,"float32"));x.push(e),f.push(e)}let S;S=b?new tF(m,v,y,w,k):new eF(m,v,y,w,k);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],C=n.runWebGLProgram(S,x,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}};class jF{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=DR(n.length);let a="\n    int index;";for(let i=0;i<this.sliceDim;i++)a+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const qF={kernelName:$a,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Lr(r.shape),[l,u,c,h]=Bf(r,s),d=P_({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=P_({inputs:{x:r},backend:n,attrs:{shape:[Lr(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=dA(e,t,r.dtype,u,i,c,h,r.shape,o);return n.makeTensorInfo(l,r.dtype,a.values)}const f=new jF(i,h,[u,c],r.shape),g=n.runWebGLProgram(f,[p,d],p.dtype),m=P_({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}};class KF{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=DR(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function XF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=Vr(i,s.shape)[0];if(ps().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[l];for(let n=0;n<e.length;++n){const r=e[n];Or(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=nm(s,a,l,o),c=Lr(a.shape),h=[],d=P_({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=P_({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),r=pA(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const g=new KF(d.shape,f),m=n.runWebGLProgram(g,[d,p],d.dtype);h.push(m);const b=P_({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const YF={kernelName:Ea,backendName:"webgl",kernelFunc:XF},QF=__({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:fA,dtype:"bool"}),JF={kernelName:Ra,backendName:"webgl",kernelFunc:QF},ZF=__({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:gA}),eL={kernelName:Aa,backendName:"webgl",kernelFunc:ZF},tL={kernelName:Oa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return NF(r,!0,n)}},nL=A_({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),rL={kernelName:Fa,backendName:"webgl",kernelFunc:nL},sL=A_({opSnippet:"return float(isinf(x));",dtype:"bool"}),aL={kernelName:La,backendName:"webgl",kernelFunc:sL},iL=A_({opSnippet:"return float(isnan(x));",dtype:"bool"}),oL={kernelName:za,backendName:"webgl",kernelFunc:iL},lL=__({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:mA,dtype:"bool"}),uL={kernelName:Pa,backendName:"webgl",kernelFunc:lL},cL=__({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:bA,dtype:"bool"}),hL={kernelName:Ba,backendName:"webgl",kernelFunc:cL},dL={kernelName:Ua,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=yA(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},pL=A_({opSnippet:R_+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:xA}),fL={kernelName:Wa,backendName:"webgl",kernelFunc:pL},gL=A_({opSnippet:R_+"\n  return log(1.0 + x);\n"}),mL={kernelName:Va,backendName:"webgl",kernelFunc:gL},bL=__({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),yL={kernelName:Ga,backendName:"webgl",kernelFunc:bL},xL=A_({opSnippet:"return float(!(x >= 1.0));"}),vL={kernelName:Ha,backendName:"webgl",kernelFunc:xL},wL=__({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),kL={kernelName:ja,backendName:"webgl",kernelFunc:wL};class SL{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class IL{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const CL={kernelName:qa,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=ps().getBool("WEBGL_PACK_NORMALIZATION")?new IL(s.shape,a,i,o,l):new SL(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class TL{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const NL={kernelName:Ka,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,h=new TL(s.shape,o,l,u,c);return n.runWebGLProgram(h,[s,a,i],s.dtype)}};function EL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Vr(a,s.shape);let u=l;const c=Ih(u,o),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=KA(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype),n.texData.get(p.dataId).values=r}else p=j_(s,c,n);u=Th(u.length,o)}Sh("max",u,o);const[f,g]=wh(p.shape,u);let m,b=f;if(i&&(b=kh(f,l)),d){const e=n.texData.get(p.dataId).values,t=vA(e,Lr(g),b,s.dtype);m=n.makeTensorInfo(b,s.dtype),n.texData.get(m.dataId).values=t}else m=function(e,t,n,r){const s=Lr(t),a=P_({inputs:{x:e},attrs:{shape:[Lr(e.shape)/s,s]},backend:r}),i=V_(a,e.dtype,"max",r),o=P_({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,g,b,n);return h&&n.disposeIntermediateTensorInfo(p),m}const $L={kernelName:Xa,backendName:"webgl",kernelFunc:EL},RL=__({opSnippet:m_+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+y_+"\n  return result;\n",cpuKernelImpl:wA}),AL={kernelName:Ya,backendName:"webgl",kernelFunc:RL},_L={kernelName:Qa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;bR(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Or(wc(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hc(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&zr(u.inShape,u.outShape))return v_({inputs:{x:s},backend:n});const c=new RO(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},OL={kernelName:Za,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=dc(s.shape,a,i,[1,1,1],o,u,l),h=new AO(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class DL{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FL{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const LL={kernelName:ei,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,h=dc(i.shape,o,l,[1,1,1],u,c),d=new AO(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new FL(h),g=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),g}},zL={kernelName:Ja,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;bR([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=hc(o.shape,l,u,1,c,h),p=new RO(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),g=new DL(d),m=n.runWebGLProgram(g,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),m}},ML={kernelName:ti,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;Or(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const u=[1,1];Or(wc(a,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`));const c=hc(r.shape,s,a,u,i),[h,d]=function(e,t,n,r){let s=new RO(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new RO(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,o,c,l);return[h,d]}},PL={kernelName:ni,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=Vr(a,r.shape);let u=l;const c=Ih(u,o),h=null!=c,d=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const e=i.texData.get(f.dataId).values,t=new Array(o);for(let s=0;s<t.length;s++)t[s]=r.shape[c[s]];const n=KA(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=j_(r,c,i);p.push(f),u=Th(u.length,o)}Sh("sum",u,o);const[g,m]=wh(f.shape,u);let b=g;s&&(b=kh(g,l));const y=function(e,t,n,r){const s=Lr(t),a=P_({inputs:{x:e},attrs:{shape:[Lr(e.shape)/s,s]},backend:r}),i=V_(a,"float32","mean",r),o=P_({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(f,m,b,i);for(const x of p)i.disposeIntermediateTensorInfo(x);return y}},BL={kernelName:ri,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Vr(a,s.shape);let u=l;const c=Ih(u,o);let h=s;null!=c&&(h=X_({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Th(u.length,s.shape.length)),Sh("min",u,o);const[d,p]=wh(h.shape,u),f=P_({inputs:{x:h},backend:n,attrs:{shape:[-1,Lr(p)]}}),g=V_(f,f.dtype,"min",n);let m;return m=P_(i?{inputs:{x:g},backend:n,attrs:{shape:kh(d,l)}}:{inputs:{x:g},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),m}},UL=__({opSnippet:m_+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+y_+"\n  return result;\n",cpuKernelImpl:kA}),WL={kernelName:si,backendName:"webgl",kernelFunc:UL};class VL{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=DR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class GL{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=DR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=QA("rc",r),l=QA("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const HL={kernelName:ai,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=ps().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GL(r.shape,s,a):new VL(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)}},jL=__({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+y_+"\n  return result;\n"}),qL={kernelName:ii,backendName:"webgl",kernelFunc:jL};class KL{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const XL=__({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),YL={kernelName:pa,backendName:"webgl",kernelFunc:XL},QL="return a - b;",JL=__({opSnippet:QL,packedOpSnippet:QL,supportsComplex:!0,cpuKernelImpl:HA}),ZL={kernelName:ho,backendName:"webgl",kernelFunc:JL};function ez(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Vr([a],s.shape),o=EL({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=kh(o.shape,i),u=P_({inputs:{x:o},backend:n,attrs:{shape:l}}),c=JL({inputs:{a:s,b:u},backend:n}),h=xF({inputs:{x:c},backend:n}),d=q_({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=P_({inputs:{x:d},backend:n,attrs:{shape:l}}),f=XL({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const tz={kernelName:Ji,backendName:"webgl",kernelFunc:ez},nz={kernelName:oi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:ez({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new KL(u,c,a),d=[[i]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}},rz=a_+"\n  return -x;\n",sz={kernelName:ui,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=IA(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=ps().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new c_(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new s_(r.shape,rz),n.runWebGLProgram(s,[r],r.dtype)}},az=of,iz={kernelName:hi,backendName:"webgl",kernelFunc:function(e){Eo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:h}=az(u,c,i,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},oz=lf,lz={kernelName:di,backendName:"webgl",kernelFunc:function(e){Eo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:d,validOutputs:p}=oz(c,h,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},uz=uf,cz={kernelName:pi,backendName:"webgl",kernelFunc:function(e){Eo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),h=n.readSync(a.dataId),d=i,p=o,f=l,g=u,{selectedIndices:m,selectedScores:b}=uz(c,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class hz{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const dz={kernelName:gi,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Lr(s.shape),c=new hz(u,i,o,l),h=P_({inputs:{x:s},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],a);n.disposeIntermediateTensorInfo(h);const p=P_({inputs:{x:d},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(d),p}};function pz(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=ZO({inputs:{input:r},backend:n}),t=pz({inputs:{x:e},backend:n}),s=fD({inputs:{input:r},backend:n}),a=pz({inputs:{x:s},backend:n}),i=k_({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return RF({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const fz={kernelName:ko,backendName:"webgl",kernelFunc:pz},gz={kernelName:fi,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=ZO({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=fD({inputs:{input:s},backend:r}),i=pz({inputs:{x:a},backend:r}),o=k_({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return RF({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},mz={kernelName:mi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return wF({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{Dr(a,e.shape,"All tensors passed to stack must have matching shapes"),Or(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=bD({inputs:t.map((e=>{const t=wF({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class bz{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=DR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class yz{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=DR(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=QA("rc",r),l=QA("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,g=1===r?2:4;f<g;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const xz=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===Lr(s.shape))return RF({backend:n,attrs:{shape:a.map(((e,t)=>e[0]+s.shape[t]+e[1])),value:i,dtype:s.dtype}});const o=ps().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yz(s.shape,a,i):new bz(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},vz={kernelName:bi,backendName:"webgl",kernelFunc:xz},wz=__({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+y_+"\n  return result;\n"}),kz={kernelName:yi,backendName:"webgl",kernelFunc:wz},Sz={kernelName:vi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Vr(a,s.shape);let c=u;const h=Ih(c,o);let d,p=s;if(null!=h&&(p=X_({inputs:{x:s},backend:n,attrs:{perm:h}}),c=Th(c.length,o),l.push(p)),Sh("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=TA(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=wh(p.shape,c),r=Lr(t),a=P_({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=V_(a,Dl(s.dtype),"prod",n);d=P_({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(a),l.push(i)}if(i){l.push(d);const e=kh(d.shape,u);d=P_({inputs:{x:d},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},Iz={kernelName:wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.readSync(e.dataId))),u=s.map((e=>e.shape)),c=n.readSync(a.dataId),h=n.readSync(i.dataId),[d,p,f]=NA(l,u,c,a.shape,a.dtype,h,i.shape,o),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,a.dtype,p);return g.concat([m])}},Cz={kernelName:ki,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=EA(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}},Tz={kernelName:Si,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),h=n.readSync(i.dataId),d=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,g]=$A(u,s.shape,c,a.shape,a.dtype,h,i.shape,d,p,l);return n.makeTensorInfo(f,a.dtype,g)}},Nz=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=RA(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},Ez={kernelName:Ii,backendName:"webgl",kernelFunc:Nz},$z=A_({opSnippet:"return 1.0 / x;"}),Rz={kernelName:Ti,backendName:"webgl",kernelFunc:$z},Az=A_({opSnippet:a_+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),_z={kernelName:Ni,backendName:"webgl",kernelFunc:Az},Oz=A_({opSnippet:a_+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Dz={kernelName:Oi,backendName:"webgl",kernelFunc:Oz};class Fz{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Lz{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const zz={kernelName:Ai,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=ps().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Lz(s.shape,l,u,a,i):new Fz(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}};class Mz{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Pz={kernelName:_i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Mz(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class Bz{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Uz{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],h=r?"0.5":"0.0";let d;d=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Wz={kernelName:$i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=ps().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Uz(s.shape,l,u,a,i):new Bz(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class Vz{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Gz={kernelName:Ri,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Vz(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class Hz{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=DR(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class jz{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=QA("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=DR(n);var o;function l(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o=r.slice(),l(o)};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",l(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",l(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const qz={kernelName:Di,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Vr(a,s.shape);if(0===i)return v_({inputs:{x:s},backend:n});const l=ps().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jz(s.shape,o):new Hz(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class Kz{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Xz={kernelName:Io,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new Kz(r.shape,a),[u,c]=gg(i,r.shape[1],r.shape[2]),h=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,h)}},Yz=A_({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Qz={kernelName:Fi,backendName:"webgl",kernelFunc:Yz},Jz=A_({opSnippet:"return inversesqrt(x);",cpuKernelImpl:AA}),Zz={kernelName:Li,backendName:"webgl",kernelFunc:Jz};class eM{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=DR(s.length),u=DR(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const h=`getIndices(${c})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const p=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const g=`getDefaultValue(${f})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${h});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${g}, sum, float(found)));\n        }\n      `}}class tM{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const l=DR(s.length),u=DR(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const h=`getIndices(${c})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const p=`getUpdates(${d})`;let f="";o&&(f="coords[0], coords[1]");const g=`getDefaultValue(${f})`,m=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${h});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${b};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${g}, sum, found));\n        }\n      `}}const nM={kernelName:zi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Op(0,s,i),d=[h/u,u];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=P_({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=P_({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=ps().getBool("WEBGL_PACK")?new tM(l,o,p.shape.length,f.shape.length,c,d):new eM(l,o,p.shape.length,f.shape.length,c,d);const b=n.runWebGLProgram(m,[f,p,g],f.dtype),y=P_({inputs:{x:b},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),y}};class rM{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===ps().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const sM={kernelName:Pi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new rM(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}};class aM{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=DR(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const iM={kernelName:Bi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new aM(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],Ol(s.dtype,a.dtype))}},oM=A_({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768;\n  float scale = ${kg};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),lM={kernelName:Ui,backendName:"webgl",kernelFunc:oM},uM=A_({opSnippet:R_+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:OA}),cM={kernelName:ji,backendName:"webgl",kernelFunc:uM},hM=A_({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),dM={kernelName:Hi,backendName:"webgl",kernelFunc:hM},pM=A_({opSnippet:R_+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${y_}\n  return result;\n`}),fM={kernelName:Vi,backendName:"webgl",kernelFunc:pM},gM=A_({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),mM={kernelName:Gi,backendName:"webgl",kernelFunc:gM},bM=A_({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),yM={kernelName:qi,backendName:"webgl",kernelFunc:bM},xM={kernelName:Yi,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Or(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let b=1+a.length;b<s.shape.length;++b)l.push([0,0]);const u=[],c=xz({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),h=mg(c.shape,a,o,!1),d=bg(h.length,a.length,!1),p=yg(c.shape,a,o,!1),f=P_({inputs:{x:c},backend:n,attrs:{shape:h}}),g=X_({inputs:{x:f},backend:n,attrs:{perm:d}}),m=P_({inputs:{x:g},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}},vM={kernelName:Zi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,g]=LA(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}},wM={kernelName:eo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,h]=zA(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([h.length],a.dtype,new Int32Array(h))]}},kM={kernelName:to,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=MA(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},SM={kernelName:no,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=MA(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},IM={kernelName:ro,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=Op(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=al(n.readSync(i.dataId)[0]),f=_A(e,t,o,d,c,u,l,h,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new eM(u,l,s.shape.length,a.shape.length,h,[d,1],p),g=n.runWebGLProgram(f,[a,s,i],a.dtype),m=P_({inputs:{x:g},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(g),m}},CM={kernelName:Qi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Vr(i,s.shape)[0],l=Gg(s,a,o),u=s.shape.length,c=new Array(u).fill(0),h=s.shape.slice();return l.map((e=>{const t=[...h];t[o]=e;const r=HO({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},TM="return sqrt(x);",NM=A_({opSnippet:TM,packedOpSnippet:TM,cpuKernelImpl:PA}),EM={kernelName:Ki,backendName:"webgl",kernelFunc:NM},$M={kernelName:ao,backendName:"webgl",kernelFunc:A_({opSnippet:"return x * x;"})},RM="return (a - b) * (a - b);",AM=__({opSnippet:RM,packedOpSnippet:RM}),_M={kernelName:so,backendName:"webgl",kernelFunc:AM},OM={kernelName:io,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=sm(n.readSync(s.dataId)),i=BA(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}},DM={kernelName:So,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=a_+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new s_(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}};class FM{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=DR(n.length),a=DR(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const LM={kernelName:oo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:y,end:x,strides:v}=eg(s.shape,a,i,o,l,u,c,h,d);let w;if(g)w=P_({inputs:{x:s},backend:n,attrs:{shape:f}});else if(m||b){Or(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=Wf(y,x,v),t=HO({inputs:{x:s},backend:n,attrs:{begin:y,size:e}});w=P_({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=Hu(s.shape,s.dtype,e),r=UA(p,t,v,y);w=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new FM(y,v,p);w=n.runWebGLProgram(e,[s],s.dtype)}const k=P_({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}},zM={kernelName:lo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,g]=WA(d,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}},MM={kernelName:uo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,h]=VA(o,l,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},PM={kernelName:co,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=GA(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},BM=A_({opSnippet:"return tan(x);"}),UM={kernelName:po,backendName:"webgl",kernelFunc:BM},WM=A_({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),VM={kernelName:fo,backendName:"webgl",kernelFunc:WM},GM={kernelName:Mi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=Op(0,a,s.shape),d=[h/u,u];if(0===h)return n.makeTensorInfo(s.shape,a.dtype);const p=P_({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=P_({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=P_({inputs:{x:s},backend:n,attrs:{shape:d}}),m=new eM(l,o,p.shape.length,f.shape.length,c,d,!1,!0),b=n.runWebGLProgram(m,[f,p,g],g.dtype),y=P_({inputs:{x:b},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),y}};class HM{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const r=DR(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function jM(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>al(e))):e,r=Hu(s.shape,s.dtype,t),i=jA(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new HM(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const qM={kernelName:go,backendName:"webgl",kernelFunc:jM};class KM{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class XM{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function YM(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function QM(e){let t=1;for(;t<e;)t*=2;return t}const JM={kernelName:mo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=ps().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ps().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const e=n.readSync(s.dataId),[t,r]=qA(e,u,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[s,RF({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(s.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(s):s,f=Lr(u)/c,g=P_({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&YM(n,p);const m=QM(a),b=QM(c);let y=null;const x=()=>null===y?[g,g]:[g,y],v=(e,t,r)=>{const s=x(),a=new KM(r),i=[[c],[null===y?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=y;y=n.runWebGLProgram(a,s,"int32",i),YM(n,o)};for(let C=1;C<m;C*=2){const e=2*C;for(let t=C;t>=1;t/=2)v(e,t,[f,b])}for(let C=b;C>m;C/=2){const e=x(),t=new XM([f,C/2]),r=[[c],[null===y?1:0],[m]],s=y;y=n.runWebGLProgram(t,e,"int32",r),YM(n,s);const a=m/2,i=2*a;for(let n=a;n>=1;n/=2)v(i,n,y.shape)}let w=y;y=HO({inputs:{x:y},backend:n,attrs:{begin:0,size:[f,a]}}),YM(n,w);let k=XF({inputs:{x:g,indices:y},backend:n,attrs:{axis:1,batchDims:1}});YM(n,g);const S=u.slice(0,-1);S.push(a),w=y,y=P_({inputs:{x:y},attrs:{shape:S},backend:n}),YM(n,w);const I=k;return k=P_({inputs:{x:k},attrs:{shape:S},backend:n}),YM(n,I),[k,y]}};class ZM{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const eP={kernelName:bo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[f,g]=null!=u?u:[h,d],m=new ZM(h,d,i,o,l,[c,f,g,p]);return n.runWebGLProgram(m,[s,a],"float32")}},tP={kernelName:xo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;bR(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=XA(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},nP={kernelName:vo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let g=0;g<o;g++)g!==a&&(u[c++]=i.shape[g]);const h=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[a]=g;const e=HO({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=P_({inputs:{x:e},backend:n,attrs:{shape:u}});f[g]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class rP{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const sP=[J_,eO,nO,sO,oO,cO,hO,dO,yO,xO,wO,SO,CO,NO,$O,_O,OO,LO,zO,MO,UO,qO,KO,XO,YO,tD,sD,oD,S_,cD,yD,TD,AD,OD,DD,FD,LD,MD,BD,WD,XD,YD,QD,ZD,nF,aF,iF,lF,cF,hF,pF,fF,mF,yF,vF,kF,CF,EF,AF,OF,LF,MF,UF,GF,HF,qF,YF,JF,eL,w_,tL,gD,rL,aL,oL,T_,uL,hL,dL,fL,mL,yL,vL,kL,CL,NL,$L,AL,_L,OL,LL,zL,ML,PL,BL,WL,HL,qL,nz,M_,sz,iz,lz,cz,JO,dz,gz,mz,vz,kz,$_,Sz,Iz,Cz,Tz,Ez,eD,YL,Rz,_z,Dz,B_,zz,Pz,Wz,Gz,qz,Xz,Qz,Zz,nM,sM,iM,lM,cM,dM,fM,mM,jO,tz,yM,xM,vM,wM,kM,SM,IM,CM,EM,$M,_M,OM,DM,LM,zM,MM,PM,ZL,K_,UM,VM,GM,qM,JM,eP,Y_,tP,nP,{kernelName:wo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=Ih([u],o);let h=s;null!=c&&(h=X_({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(h),u=Th(1,o)[0]);const d=tm(h.shape,u,i),p=Lr([h.shape[u]]),f=P_({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const g=Dl(s.dtype),m=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],u=em(o,a),c=new rP({windowSize:u,inSize:o,batchSize:i,numSegments:a},t),h=n.compileAndRun(c,[e,r],s);if(l.push(h),h.shape[1]===a)return h;const d=Nz({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=jM({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});return l.push(d),l.push(p),m(h,t,p,s,a)},b=P_({inputs:{x:m(f,"unsortedSegmentSum",a,g,i)},backend:n,attrs:{shape:d}});let y=b;if(null!=c){l.push(b);const e=Ch(c);y=X_({inputs:{x:y},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}},fz];for(const FP of sP)Do(FP);let aP=null;const iP=Sr("https://cellvivor-backend.onrender.com"),oP="https://cellvivor-backend.onrender.com";class lP extends Qt.Scene{constructor(){super("Game")}init(e){this.roomCode=e.roomCode||"simple-local",this.myRole=e.role||"guesser",this.startTime=e.startTime||Date.now(),this.score=0,this.playedKeywords=[]}preload(){this.load.image("hint","/assets/hint.png")}create(){this.cameras.main.setBackgroundColor("#FFD700"),this.scoreText=this.add.text(512,160,"Score: 0",{fontSize:"32px",color:"#ffffff"}).setOrigin(.5).setDepth(200),this.updateScoreText=()=>{this.scoreText&&this.scoreText.setText("Score: "+this.score)},"simple-local"!==this.roomCode&&fetch(`${oP}/api/gameplay-score?roomCode=${this.roomCode}`).then((e=>e.json())).then((e=>{this.score=e.score||0,this.updateScoreText()})),iP.on("roleUpdate",(({hinter:e,guesser:t})=>{"guesser"===this.myRole&&e.length>0&&(this.hinterId=e[0]),"hinter"===this.myRole&&t.length>0&&(this.guesserId=t[0])}));const e=this.add.graphics();e.fillStyle(16745239),e.lineStyle(19,16777215);const t=this.cameras.main.centerX-433.5,n=this.cameras.main.centerY-260;e.fillRoundedRect(t,n,867,520,40),e.strokeRoundedRect(t,n,867,520,40),e.setDepth(0),this.add.text(60,77,"<",{fontSize:"48px",color:"#ffffffff"}).setOrigin(.5).setDepth(200).setInteractive({useHandCursor:!0}).on("pointerdown",(()=>{window.confirm("Do you want to quit the game?")&&(iP.emit("player-quit",{roomCode:this.roomCode}),this.scene.stop(),this.children.removeAll(),this.scene.start("Mode"))}));let r="",s="",a=!1,i="";const o=this.add.text(512,300,"Waiting...",{fontSize:"48px",color:"#FFFFFF",fontStyle:"bold",align:"center"}).setOrigin(.5).setDepth(1),l=async()=>{try{localStorage.getItem("userId");const e=this.playedKeywords[this.playedKeywords.length-1],t=await async function(e={result:"FT",difficulty:"easy",chapter:"1"}){aP||(aP=await async function(e,t){if(null==t&&(t={}),"string"==typeof e){const s=(n=e,r=t,vu.getLoadHandlers(n,r));if(0===s.length)s.push(function(e,t){return Pf(e,t)}(e,t));else if(s.length>1)throw new Tb(`Found more than one (${s.length}) load handlers for URL '${e}'`);e=s[0]}var n,r;return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new Tb("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const a=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&a,o=Yx(kv(s),void 0,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new Tb("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=function(e,t){const n=new au(e),r={};let s=0;for(const a of t){const e=pu(a,((e,t)=>n.slice(s+e,s+t)));r[a.name]=fu(a,n.slice(s,s+e)),s+=e}return r}(e,t),r={},s=[];return t.forEach((e=>{"optimizer"===e.group?s.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:s}}(r.weightData,r.weightSpecs);o.loadWeights(e,a),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),uu(e),uu(t.map((e=>e.tensor)))}return o}(e,0,t)}("/model_tfjs/model.json"));const t={easy:0,medium:1,hard:2},n=Ap([[{TT:2,FT:1,FF:0}[e.result],t[e.difficulty],parseInt(e.chapter)]]),r=aP.predict(n).argMax(-1).dataSync()[0],s=Object.keys(t).find((e=>t[e]===r)),a=await fetch(`https://cellvivor-backend.onrender.com/api/next-keyword?difficulty=${s}`);return await a.json()}(e);if(!t||!t.word)throw console.warn("[AI] No keyword returned, fallback to random"),new Error("No AI keyword");r=t.word,s=t.hint||"",this.currentDifficulty=t.level||"medium",this.currentChapter=t.chapter||"1",u(r),"simple-local"!==this.roomCode&&iP.emit("keyword",{roomCode:this.roomCode,keyword:r,hint:s})}catch(DP){console.error("[AI] Failed to get keyword from AI — fallback to default API:",DP.message);const t=await fetch(`${oP}/api/random-keyword`),n=await t.json();r=n.keyword,s=n.hint||"",this.currentDifficulty=n.difficulty||"medium",this.currentChapter=n.chapter||"1",u(r)}};iP.on("keyword",(({keyword:e,hint:t})=>{r=e,s=t,u(r)}));const u=e=>{o.setText(e),i="",a=!1},c=e=>{alert("💡 Hint: "+e)};iP.on("show-hint",(({hint:e})=>{a||(a=!0,c(e))}));const h=this.add.image(900,200,"hint").setOrigin(.5).setScale(.13).setDepth(151).setInteractive({useHandCursor:!0});h.on("pointerdown",(()=>{"guesser"===this.myRole&&!a&&s&&(a=!0,iP.emit("hint-used",{roomCode:this.roomCode,hint:s}),c(s))})),"guesser"!==this.myRole&&h.setVisible(!1);const d=this.add.text(512,200,"",{fontSize:"40px",color:"#ffffff"}).setOrigin(.5).setDepth(150);this.time.addEvent({delay:1e3,callback:()=>{const e=Math.floor((Date.now()-this.startTime)/1e3),t=Math.max(0,300-e);d.setText(this.formatTime(t)),t<=0&&this.scene.start("GameOver",{score:this.score,results:this.playedKeywords,userId:localStorage.getItem("userId")})},callbackScope:this,loop:!0});const p=async e=>{if(i=e,this.playedKeywords.push({word:r,difficulty:this.currentDifficulty,chapter:this.currentChapter}),"simple-local"===this.roomCode)"TT"===i?this.score+=2:"FT"===i&&(this.score+=1),this.updateScoreText();else{"TT"===i?this.score+=2:"FT"===i&&(this.score+=1),this.updateScoreText();try{await fetch(`${oP}/api/save-player-result`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({roomCode:this.roomCode,userId:localStorage.getItem("userId"),role:"guesser",keyword:r,result:i,usedHint:a})})}catch(DP){console.error("Error saving guesser result:",DP)}if("guesser"===this.myRole&&this.hinterId){const e="TT"===i?"T":"F";try{await fetch(`${oP}/api/save-player-result`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({roomCode:this.roomCode,userId:this.hinterId,role:"hinter",keyword:r,result:e,usedHint:!1})})}catch(DP){console.error("Error saving hinter result:",DP)}}}l()};iP.on("score-update",(({score:e})=>{this.score=e,this.updateScoreText()}));const f=this.add.text(412,400,"Skip",{fontSize:"32px",color:"#fff",backgroundColor:"#6067FE",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(102).setInteractive({useHandCursor:!0}),g=this.add.text(612,400,"Correct",{fontSize:"32px",color:"#fff",backgroundColor:"#6067FE",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(102).setInteractive({useHandCursor:!0});f.on("pointerdown",(()=>{"guesser"===this.myRole&&p("FF")})),g.on("pointerdown",(()=>{"guesser"===this.myRole&&p(a?"FT":"TT")})),"guesser"!==this.myRole&&(f.setVisible(!1),g.setVisible(!1)),tn.emit("current-scene-ready",this)}formatTime(e){return`${Math.floor(e/60).toString().padStart(2,"0")}:${(e%60).toString().padStart(2,"0")}`}}class uP extends Qt.Scene{constructor(){super("Storyboard")}create(){}changeScene(){this.scene.start("MainMenu")}}class cP extends Qt.Scene{constructor(){super("GameOver")}init(e){this.score=e.score||0,this.results=e.results||[],this.userId=e.userId||null}create(){this.cameras.main.setBackgroundColor("#333"),this.add.text(60,90,"<",{fontSize:"48px",color:"#ffffffff",align:"Left"}).setOrigin(.5).setDepth(200).setInteractive().on("pointerdown",(()=>{this.scene.stop(),this.children.removeAll(),this.scene.start("Mode")})),this.add.text(512,100,"Game Over",{fontSize:"64px",color:"#ffffff",fontStyle:"bold"}).setOrigin(.5),this.add.text(512,180,`Final Score: ${this.score}`,{fontSize:"40px",color:"#00ff00"}).setOrigin(.5),this.add.text(512,250,"Keywords Played:",{fontSize:"32px",color:"#ffffff"}).setOrigin(.5),0===this.results.length?this.add.text(512,300,"No rounds played.",{fontSize:"24px",color:"#ffcc00"}).setOrigin(.5):this.results.forEach(((e,t)=>{const n=`Keyword: ${e.word} — ${"TT"===e.result||"FT"===e.result?"✔ Correct":"✘ Wrong"}`;this.add.text(512,300+36*t,n,{fontSize:"24px",color:"TT"===e.result||"FT"===e.result?"#00ff00":"#ff4d4d"}).setOrigin(.5)}));const e=this.results.filter((e=>"FF"===e.result||"FT"===e.result)).map((e=>e.word));e.length>0&&this.add.text(512,300+36*this.results.length+30,`Words to review: ${e.join(", ")}`,{fontSize:"22px",color:"#ff4d4d",wordWrap:{width:800}}).setOrigin(.5),this.add.text(512,600,"Click to Navigate to Dashboard",{fontSize:"24px",color:"#ffffff"}).setOrigin(.5),this.updateWeakness(this.userId,e),this.input.once("pointerdown",(()=>{this.scene.start("Dashboard")}))}async updateWeakness(e,t){if(e&&0!==t.length)try{const n=await fetch(`https://cellvivor-backend.onrender.com/api/users/${e}/add-weakness`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify({newWeakness:t})}),r=await n.json();r.success?console.log("Weakness updated successfully:",r.weakness):console.warn("Failed to update weakness:",r)}catch(DP){console.error("Error updating weakness:",DP)}}}function hP(e,t={}){let n=null,r=null,s=null,a=[];function i(t,i=!1){n||(n=e.add.rectangle(512,384,1024,768,0,.66).setOrigin(.5).setDepth(199).setInteractive().on("pointerdown",(()=>{i||(n&&n.destroy(),r&&r.destroy(),s&&s.destroy(),a.forEach((e=>e.destroy())),n=r=s=null,a=[])})),r=e.add.rectangle(512,370,850,550,16777215,.5).setOrigin(.5).setDepth(200),s=t?t(e,r):null,r.setInteractive().on("pointerdown",((e,t,n,r)=>{r&&r.stopPropagation()})))}const o=820;[{key:"book",x:o,cb:()=>i(t.onBook||fP)},{key:"magnifying",x:o+70,cb:()=>i(t.onHowToPlay||dP)},{key:"setting",x:o+140,cb:()=>i(t.onSettings||pP)}].forEach((t=>{e.add.image(t.x,90,t.key).setOrigin(.5).setScale(.1).setDepth(120).setInteractive({useHandCursor:!0}).on("pointerdown",(()=>{n||t.cb()}))})),e.add.text(60,90,"<",{fontSize:"48px",color:"#ffffffff",align:"Left",borderRadius:12}).setOrigin(.5).setDepth(200).setInteractive({useHandCursor:!0}).on("pointerdown",(()=>{n||(window.confirm("Do you want to quit the storyboard mode?")?(console.log("User chose to quit the game."),e.scene.start("Mode"),this.scene.stop(),this.children.removeAll()):console.log("User chose to stay in the game."))}))}function dP(e,t){const n=["5.png","6.png","7.png","8.png","9.png"];let r=0,s=e.add.image(t.x,t.y,n[r]).setDisplaySize(850,550).setDepth(201);const a=e.add.text(t.x-320,t.y+300,"Previous",{fontSize:"28px",color:"#fff",padding:{left:20,right:20,top:10,bottom:-1}}).setOrigin(.5).setDepth(202).setInteractive({useHandCursor:!0}),i=e.add.text(t.x+320,t.y+300,"Next",{fontSize:"28px",color:"#fff",padding:{left:20,right:20,top:10,bottom:-1}}).setOrigin(.5).setDepth(202).setInteractive({useHandCursor:!0});function o(){s.setTexture(n[r]),a.setAlpha(0===r?.5:1),a.disableInteractive(),i.setAlpha(r===n.length-1?.5:1),i.disableInteractive(),r>0&&a.setInteractive({useHandCursor:!0}),r<n.length-1&&i.setInteractive({useHandCursor:!0})}return a.on("pointerdown",(()=>{r>0&&(r--,o())})),i.on("pointerdown",(()=>{r<n.length-1&&(r++,o())})),o(),e.events.once("shutdown",(()=>{s.destroy(),a.destroy(),i.destroy()})),{destroy:()=>{s.destroy(),a.destroy(),i.destroy()}}}function pP(e,t){return e.add.text(t.x,t.y,"Settings\n\nSettings options go here.",{fontSize:"32px",color:"#222",align:"center",wordWrap:{width:750}}).setOrigin(.5).setDepth(201)}function fP(e,t){return e.add.text(t.x,t.y,"Book\n\nBook content goes here.",{fontSize:"32px",color:"#222",align:"center",wordWrap:{width:750}}).setOrigin(.5).setDepth(201)}class gP{constructor(e){this.scene=e,this.dialogueBox=null,this.text=null,this.speakerText=null,this.currentDialogue=[],this.currentLineIndex=0,this.typing=!1,this.choiceButtons=[],this.isDialogueActive=!1,this.onLineComplete=null,this.typingInterval=null}createDialogueBox(){this.dialogueBox&&this.dialogueBox.destroy(),this.speakerText&&this.speakerText.destroy(),this.text&&this.text.destroy();const e=this.scene.add.graphics();e.fillStyle(0,.7),e.fillRect(50,this.scene.cameras.main.height-150,this.scene.cameras.main.width-100,100),this.dialogueBox=e,this.speakerText=this.scene.add.text(60,this.scene.cameras.main.height-145,"",{fontSize:"20px",fill:"#ffffff"}),this.text=this.scene.add.text(60,this.scene.cameras.main.height-123,"",{fontSize:"16px",fill:"#ffffff",wordWrap:{width:this.scene.cameras.main.width-120}})}startDialogue(e){this.currentDialogue=e,this.currentLineIndex=0,this.isDialogueActive=!0,this.createDialogueBox(),this.showNextLine()}showLine(e){this.speakerText&&this.speakerText.setText(""),this.text&&this.text.setText("");const t=this.currentDialogue[e];t&&(this.speakerText.setText(t.speaker),this.text.setText(""),this.typing=!0,this.currentLineIndex=e,this.typeText(t.text))}showNextLine(){this.currentLineIndex<this.currentDialogue.length?(this.showLine(this.currentLineIndex),this.currentLineIndex++):(this.endDialogue(),"function"==typeof this.onLineComplete&&this.onLineComplete())}typeText(e){let t=0;this.typingInterval&&clearInterval(this.typingInterval),this.typingInterval=setInterval((()=>{t<e.length?(this.text.setText(this.text.text+e.charAt(t)),t++):(clearInterval(this.typingInterval),this.typing=!1,this.typingInterval=null,this.checkForChoices())}),50)}skipTyping(){var e;if(!this.typing)return;clearInterval(this.typingInterval);const t=(null==(e=this.currentDialogue[this.currentLineIndex-1])?void 0:e.text)||"";this.text.setText(t),this.typing=!1,this.typingInterval=null,this.checkForChoices()}advance(){this.typing?this.skipTyping():(this.clearChoices(),"function"==typeof this.onLineComplete&&this.onLineComplete())}goBack(){this.typing?this.skipTyping():this.currentLineIndex<=1||(this.currentLineIndex-=2,this.currentLineIndex<0&&(this.currentLineIndex=0),this.clearChoices(),this.showLine(this.currentLineIndex))}checkForChoices(){var e;const t=this.currentDialogue[this.currentLineIndex-1];(null==(e=null==t?void 0:t.choices)?void 0:e.length)>0&&this.showChoices(t.choices)}showChoices(e){e.forEach(((e,t)=>{const n=this.scene.add.text(60,this.scene.cameras.main.height-50+30*t,e.text,{fontSize:"16px",fill:"#ffffff"}).setInteractive();n.on("pointerdown",(()=>{this.currentLineIndex=e.nextId,this.clearChoices(),this.showNextLine()})),this.choiceButtons.push(n)}))}clearChoices(){this.choiceButtons.forEach((e=>e.destroy())),this.choiceButtons=[]}nextLine(){this.typing||(this.clearChoices(),this.showNextLine())}endDialogue(){this.dialogueBox&&this.dialogueBox.destroy(),this.speakerText&&this.speakerText.destroy(),this.text&&this.text.destroy(),this.isDialogueActive=!1}}async function mP(e,t){if(e&&t&&""!==t.trim())try{const n=await fetch("https://cellvivor-backend.onrender.comprogress/save",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:e,scene:t})});n.ok?console.log("Game progress saved:",t):console.warn("Failed to save progress:",n.statusText)}catch(n){console.error("Error saving progress:",n)}else console.warn("saveGameProgress: Missing or invalid userId or currentChapter")}class bP extends Qt.Scene{constructor(){super("Chapter1"),this.coverImage=null,this.background=null,this.startButton=null,this.dialogueUI=null,this.script=[],this.currentLine=0,this.bgSteps=["Chapter1scene2","bone","bone1","bone2","Bonemarrow","noobysleep","noobywake","CellBorn","Blood","body","bloodvess","noobywalkyellow","RBCIntro","RBCwalkpink","BloodVessel","BloodVesselA","BloodVesselB"],this.bgStepIndex=0}preload(){this.load.image("Chapter1scene1","/assets/Chapter1scene1.png"),this.load.image("Chapter1scene2","/assets/Chapter1scene2.png"),this.load.image("bone","/assets/Bone.png"),this.load.image("bone1","/assets/Bone1.png"),this.load.image("bone2","/assets/Bone2.png"),this.load.image("Bonemarrow","/assets/Bonemarrow.png"),this.load.image("noobysleep","/assets/noobysleep.png"),this.load.image("noobywake","/assets/noobywake.png"),this.load.video("CellBorn","/assets/CellBorn.mp4"),this.load.video("Blood","/assets/Blood.mp4"),this.load.video("body","/assets/body.mp4"),this.load.video("bloodvess","/assets/bloodvess.mp4"),this.load.video("noobywalkyellow","/assets/noobywalkyellow.mp4"),this.load.video("RBCIntro","/assets/RBCIntro.mp4"),this.load.video("RBCwalkpink","/assets/RBCwalkpink.mp4"),this.load.image("BloodVessel","/assets/BloodVessel.png"),this.load.image("BloodVesselA","/assets/BloodVesselA.png"),this.load.image("BloodVesselB","/assets/BloodVesselB.png"),this.load.image("magnifying","/assets/magnifying.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("5.png","/assets/5.png"),this.load.image("6.png","/assets/6.png"),this.load.image("7.png","/assets/7.png"),this.load.image("8.png","/assets/8.png"),this.load.image("9.png","/assets/9.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter1";console.log("userId:",t,"currentChapter:",n),mP(t,n),this.cameras.main.setBackgroundColor("#000000"),this.coverImage=this.add.image(0,0,"Chapter1scene1").setOrigin(0,0).setDepth(0).setDisplaySize(this.sys.game.config.width,this.sys.game.config.height),this.startButton=this.add.text(this.cameras.main.centerX,this.cameras.main.centerY+300,"Start",{fontSize:"48px",color:"#ffffff",padding:{left:32,right:32,top:16,bottom:16},borderRadius:12}).setOrigin(.5).setDepth(10).setInteractive({useHandCursor:!0}),hP(this,{onSettings:(e,t)=>e.add.text(t.x,t.y,"Custom Settings",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201),onBook:(e,t)=>e.add.text(t.x,t.y,"Custom Book",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201)}),this.script=[{speaker:"Narrator:",text:'Welcome to your journey inside the body, This is "CELLVIVOR".'},{speaker:"Narrator:",text:" a vast network of cells works relentlessly to keep us alive.",sceneStep:2},{speaker:"Narrator",text:"And here, deep inside, is the marrow.",sceneStep:3},{speaker:"Narrator:",text:"The marrow is bustling with activity.",sceneStep:4},{speaker:"Noobyzom:",text:"☆*: .｡. o(≧▽≦)o .｡.:*☆",sceneStep:5},{speaker:"Narrator:",text:"You are Noobyzom",sceneStep:6},{speaker:"Narrator:",text:"A newborn red blood cell, just created in the bone marrow, the body’s blood cell factory.",sceneStep:7},{speaker:"Narrator:",text:" Born from hematopoietic stem cells, you have developed into a biconcave, flexible, nucleus-free hero",sceneStep:8},{speaker:"Narrator:",text:"  perfectly designed to carry one of life’s most precious elements: oxygen.",sceneStep:8},{speaker:"Narrator:",text:"Your journey starts here. From the bone marrow, \nyou will enter the bloodstream through the vessels.",sceneStep:10},{speaker:"Narrator:",text:"Your mission: Deliver oxygen to every cell in the body and maintain life.",sceneStep:9},{speaker:"Narrator:",text:"This is not just a task — it's the purpose of your existence.",sceneStep:11},{speaker:"Senior Red Blood Cell:",text:" Ah, fresh from the marrow, huh? I’m your senior — a well-traveled, oxygen-delivering expert.",sceneStep:12},{speaker:"Senior Red Blood Cell:",text:" And lucky you — I’ve got a heart map just for you.",sceneStep:12},{speaker:"Noobyzom:",text:"“A map? Wait… where exactly is the heart?",sceneStep:11},{speaker:"Senior Red Blood Cell:",text:"Haha, rookie move! Don't worry, you’ll learn quickly.\nThe heart is our command center — the engine that pumps us through the body.",sceneStep:13},{speaker:"Senior Red Blood Cell:",text:" Now listen up, I’ll walk you through the main routes: \nthe atria, ventricles, arteries, veins… It’s like a highway system in here!",sceneStep:14},{speaker:"☆Arteries☆",text:"Arteries have thick, elastic walls that allow them to handle the high pressure of blood being pumped directly from the heart. They do not contain valves, and blood pulses strongly through them with each heartbeat. ",sceneStep:15},{speaker:"☆Veins☆",text:"Veins have thinner walls than arteries and carry blood under lower pressure. They contain valves to prevent the backward flow of blood, and blood movement is aided by surrounding muscles and these valves. ",sceneStep:16},{speaker:"☆Capillaries☆",text:"Capillaries are the smallest blood vessels, with walls only one cell thick. They are the sites where the exchange of gases, nutrients, and waste occurs between the blood and body cells. ",sceneStep:14}],this.startButton.on("pointerdown",(()=>{this.startButton.destroy(),this.coverImage.destroy(),this.startStorySequence()})),this.input.keyboard.on("keydown",(e=>{("Space"===e.code||"Enter"===e.code)&&this.startButton&&this.startButton.active&&this.startButton.emit("pointerdown")}))}startStorySequence(){this.background&&this.background.destroy(),this.background=this.add.image(0,0,this.bgSteps[0]).setOrigin(0,0).setDepth(0).setDisplaySize(this.sys.game.config.width,this.sys.game.config.height),this.dialogueUI||(this.dialogueUI=new gP(this)),this.nextButton&&this.nextButton.destroy(),this.backButton&&this.backButton.destroy(),this.nextButton=this.add.text(900,680,"▶ Next",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.nextButton.on("pointerdown",(()=>{this.dialogueUI.advance()})),this.backButton=this.add.text(820,680,"◀ Back",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.backButton.on("pointerdown",(()=>{this.currentLine>0&&(this.currentLine-=2,this.currentLine<0&&(this.currentLine=0),this.showCurrentLine())})),this.input.keyboard.on("keydown-ENTER",(()=>{this.dialogueUI.advance()})),this.input.keyboard.on("keydown-SPACE",(()=>{this.dialogueUI.advance()})),this.input.keyboard.on("keydown-RIGHT",(()=>{this.dialogueUI.advance()})),this.input.keyboard.on("keydown-LEFT",(()=>{this.currentLine>0&&(this.currentLine-=2,this.currentLine<0&&(this.currentLine=0),this.showCurrentLine())})),this.currentLine=0,this.showCurrentLine()}showCurrentLine(){if(this.currentLine>=this.script.length)return this.scene.launch("LoadingOverlay"),void this.scene.start("Chapter1game");const e=this.script[this.currentLine];if(this.dialogueUI.onLineComplete=()=>{this.currentLine++,this.showCurrentLine()},"number"==typeof e.sceneStep&&e.sceneStep!==this.bgStepIndex&&this.bgSteps[e.sceneStep]){this.bgStepIndex=e.sceneStep,this.background&&(this.background.destroy(),this.background=null),this.bgVideo&&(this.bgVideo.destroy(),this.bgVideo=null);const t=this.bgSteps[this.bgStepIndex];this.cache.video.exists(t)?(this.bgVideo=this.add.video(0,0,t).setOrigin(0,0).setDepth(0),this.bgVideo.on("play",(()=>{const e=this.bgVideo.video.videoWidth,t=this.bgVideo.video.videoHeight,n=this.sys.game.config.width,r=this.sys.game.config.height;let s=Math.min(n/e,r/t);this.bgVideo.setDisplaySize(e*s,t*s)})),this.bgVideo.play(!0),this.bgVideo.setLoop(!0)):this.background=this.add.image(0,0,t).setOrigin(0,0).setDepth(0).setDisplaySize(this.sys.game.config.width,this.sys.game.config.height)}if(this.backButton&&this.backButton.setVisible(this.currentLine>0),"Senior Red Blood Cell"===e.speaker&&e.text.includes("heart map"))this.dialogueUI.startDialogue([e]),this.time.delayedCall(600,(()=>{if(this.popupContainer)return;this.popupContainer=this.add.rectangle(512,360,1024,800,0,.5).setOrigin(.5).setDepth(299).setInteractive();const e=this.add.rectangle(512,320,500,200,13092807,1).setOrigin(.5).setDepth(300).setInteractive();this.popupBook=this.add.image(332,320,"book").setOrigin(.5).setDisplaySize(80,80).setDepth(301),this.popupText=this.add.text(547,320,"You received a heart map!\nUse it to navigate the body.",{fontSize:"28px",color:"#222",wordWrap:{width:340}}).setOrigin(.5).setDepth(301),this.popupContainer.on("pointerdown",(t=>{const n=t.x,r=t.y;(n<e.x-e.width/2||n>e.x+e.width/2||r<e.y-e.height/2||r>e.y+e.height/2)&&(this.popupContainer.destroy(),e.destroy(),this.popupBook.destroy(),this.popupText.destroy(),this.popupContainer=null,this.popupBook=null,this.popupText=null)}));const t=()=>{this.popupContainer&&this.popupContainer.destroy(),e&&e.destroy(),this.popupBook&&this.popupBook.destroy(),this.popupText&&this.popupText.destroy(),this.popupContainer=null,this.popupBook=null,this.popupText=null};this.input.off("pointerdown",t,this),this.input.on("pointerdown",t,this),this.dialogueUI.onLineComplete=()=>{t(),this.currentLine++,this.showCurrentLine()}}));else if("Senior Red Blood Cell"===e.speaker&&e.text.includes("main routes")){this.dialogueUI.startDialogue([e]),this.popupContainer.on("pointerdown",(e=>{const t=e.x,n=e.y;(t<popupBox.x-popupBox.width/2||t>popupBox.x+popupBox.width/2||n<popupBox.y-popupBox.height/2||n>popupBox.y+popupBox.height/2)&&(this.popupContainer.destroy(),popupBox.destroy(),this.popupText.destroy(),this.popupContainer=null,this.popupText=null)}));const t=()=>{this.popupContainer&&this.popupContainer.destroy(),popupBox&&popupBox.destroy(),this.popupText&&this.popupText.destroy(),this.popupContainer=null,this.popupText=null};this.input.off("pointerdown",t,this),this.input.on("pointerdown",t,this),this.dialogueUI.onLineComplete=()=>{t(),this.currentLine++,this.showCurrentLine()}}else this.dialogueUI.startDialogue([e])}}class yP extends Qt.Scene{constructor(){super("Chapter2"),this.coverImage=null,this.background=null,this.bgVideo=null,this.startButton=null,this.dialogueUI=null,this.script=[],this.currentLine=0,this.bgSteps=["Chapter2scene1","map","P1","P2","P3","P4","P5","P6","P7","body"],this.bgStepIndex=0}preload(){this.load.video("Chapter2scene1","/assets/Chapter2fr.mp4"),this.load.image("map","/assets/map.jpg"),this.load.image("P1","/assets/C2P1.jpg"),this.load.image("P2","/assets/48.jpg"),this.load.image("P3","/assets/49.jpg"),this.load.image("P4","/assets/50.jpg"),this.load.image("P5","/assets/52.jpg"),this.load.image("P6","/assets/53.jpg"),this.load.image("P7","/assets/54.jpg"),this.load.video("body","/assets/body.mp4"),this.load.image("magnifying","/assets/magnifying.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("5.png","/assets/5.png"),this.load.image("6.png","/assets/6.png"),this.load.image("7.png","/assets/7.png"),this.load.image("8.png","/assets/8.png"),this.load.image("9.png","/assets/9.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter2";console.log("userId:",t,"currentChapter:",n),mP(t,n),this.cameras.main.setBackgroundColor("#000000"),this.coverImage=this.add.video(0,0,"Chapter2scene1").setOrigin(0,0).setDepth(0),this.coverImage.setMute(!0),this.coverImage.play(!0),this.coverImage.on("play",(()=>{const e=this.coverImage.video.videoWidth,t=this.coverImage.video.videoHeight,n=this.sys.game.config.width,r=this.sys.game.config.height;let s=Math.min(n/e,r/t);this.coverImage.setDisplaySize(e*s,t*s)})),this.startButton=this.add.text(this.cameras.main.centerX,this.cameras.main.centerY+300,"Start",{fontSize:"48px",color:"#ffffff",padding:{left:32,right:32,top:16,bottom:16},borderRadius:12}).setOrigin(.5).setDepth(10).setInteractive({useHandCursor:!0}),hP(this,{onSettings:(e,t)=>e.add.text(t.x,t.y,"Custom Settings",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201),onBook:(e,t)=>e.add.text(t.x,t.y,"Custom Book",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201)}),this.script=[{speaker:"Senior Red Blood Cell (narrating):",text:"After a long journey through the dark, winding vein called the Inferior Vena Cava, you finally approach the mighty heart — the body’s powerful pump."},{speaker:"Senior Red Blood Cell (narrating):",text:"And your new friend just arrived from the Superior Vena Cava, bringing blood back from the upper body."},{speaker:"Senior Red Blood Cell (narrating):",text:"As you enter the heart, you spot a fellow red blood cell gliding smoothly toward you."},{speaker:"New Red Blood Cell:",text:"Hey there! I just arrived from the Superior Vena Cava. Looks like we’re teammates now!"},{speaker:"Narrator:",text:"Noobyzom has reached the heart, the control center of the circulatory system. Your next mission: navigate the heart’s four chambers — two atria and two ventricles — to continue the journey."},{speaker:"Narrator:",text:"Get ready to learn the path blood takes through the heart and help Noobyzom move forward."},{speaker:"Narrator:",text:"Now that you’ve reached the heart, it’s time to step up and become a true red blood cell.",sceneStep:2},{speaker:"Narrator:",text:"Your real mission begins here: delivering oxygen (O₂) to every part of the body!",sceneStep:2},{speaker:"Narrator:",text:"The Right Atrium is the first chamber of the heart to receive blood.",sceneStep:3},{speaker:"Narrator:",text:"It collects deoxygenated blood returning from the whole body through the Superior and Inferior Vena Cava.",sceneStep:3},{speaker:"Narrator:",text:"When the atrium fills, the heart contracts, pushing blood through the tricuspid valve into the Right Ventricle.",sceneStep:3},{speaker:"Narrator:",text:"The Right Ventricle contracts to pump oxygen-poor blood through the pulmonic valve into the pulmonary artery.",sceneStep:4},{speaker:"Narrator:",text:"This artery carries blood to the lungs, where it picks up fresh oxygen.",sceneStep:4},{speaker:"Narrator:",text:"Oxygen-poor blood flows through the tiny capillaries in the lungs.",sceneStep:5},{speaker:"Narrator:",text:"Oxygen molecules diffuse across the thin walls into the red blood cells, where hemoglobin quickly binds with the oxygen.",sceneStep:5},{speaker:"Narrator:",text:"The Left Atrium receives oxygen-rich blood from the lungs through the pulmonary veins.",sceneStep:6},{speaker:"Narrator:",text:"When the atrium is full, the heart contracts to push blood through the mitral valve into the Left Ventricle.",sceneStep:6},{speaker:"Narrator:",text:"The Left Ventricle receives oxygen-rich blood from the Left Atrium through the mitral valve.",sceneStep:7},{speaker:"Narrator:",text:"It has the thickest walls because it must contract forcefully enough to pump oxygenated blood through the aorta to the entire body!",sceneStep:7}],this.startButton.on("pointerdown",(()=>{this.startButton.destroy(),this.coverImage.destroy(),this.startStorySequence()})),this.input.keyboard.on("keydown",(e=>{("Space"===e.code||"Enter"===e.code)&&this.startButton&&this.startButton.active&&this.startButton.emit("pointerdown")}))}startStorySequence(){this.background&&this.background.destroy(),this.bgStepIndex=1,this.background=this.add.image(0,0,this.bgSteps[this.bgStepIndex]).setOrigin(0,0).setDepth(0).setDisplaySize(this.sys.game.config.width,this.sys.game.config.height),this.dialogueUI||(this.dialogueUI=new gP(this)),this.nextButton&&this.nextButton.destroy(),this.backButton&&this.backButton.destroy(),this.nextButton=this.add.text(900,680,"▶ Next",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.backButton=this.add.text(820,680,"◀ Back",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.nextButton.on("pointerdown",(()=>this.dialogueUI.advance())),this.backButton.on("pointerdown",(()=>{this.currentLine>0&&(this.currentLine-=2,this.currentLine<0&&(this.currentLine=0),this.showCurrentLine())})),this.input.keyboard.on("keydown-ENTER",(()=>this.dialogueUI.advance())),this.input.keyboard.on("keydown-SPACE",(()=>this.dialogueUI.advance())),this.input.keyboard.on("keydown-RIGHT",(()=>this.dialogueUI.advance())),this.input.keyboard.on("keydown-LEFT",(()=>{this.currentLine>0&&(this.currentLine-=2,this.currentLine<0&&(this.currentLine=0),this.showCurrentLine())})),this.currentLine=0,this.showCurrentLine()}showCurrentLine(){if(this.currentLine>=this.script.length)return this.scene.launch("LoadingOverlay"),void this.scene.start("Chapter2game");const e=this.script[this.currentLine];if(this.dialogueUI.onLineComplete=()=>{this.currentLine++,this.showCurrentLine()},"number"==typeof e.sceneStep&&e.sceneStep!==this.bgStepIndex&&this.bgSteps[e.sceneStep]){this.bgStepIndex=e.sceneStep,this.background&&this.background.destroy(),this.bgVideo&&this.bgVideo.destroy();const t=this.bgSteps[this.bgStepIndex];this.cache.video.exists(t)?(this.bgVideo=this.add.video(0,0,t).setOrigin(0,0).setDepth(0),this.bgVideo.on("play",(()=>{const e=this.bgVideo.video.videoWidth,t=this.bgVideo.video.videoHeight,n=this.sys.game.config.width,r=this.sys.game.config.height;let s=Math.min(n/e,r/t);this.bgVideo.setDisplaySize(e*s,t*s)})),this.bgVideo.play(!0),this.bgVideo.setLoop(!0)):this.background=this.add.image(0,0,t).setOrigin(0,0).setDepth(0).setDisplaySize(this.sys.game.config.width,this.sys.game.config.height)}this.backButton.setVisible(this.currentLine>0),this.dialogueUI.startDialogue([e])}}class xP extends Jt.Scene{constructor(){super("Chapter1game"),this.dropZones={},this.properties=[],this.currentIndex=0,this.correctCount=0,this.totalCount=0,this.progressText=null}preload(){this.load.image("BloodVessel","/assets/BloodVessel_Capi.png"),this.load.image("Vein","/assets/Vein.png"),this.load.image("Artery","/assets/Artery.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("correct","/assets/correct.png"),this.load.image("tryAgain","/assets/tryAgain.png"),this.load.image("quest1","/assets/quest1.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter1game";console.log("userId:",t,"currentChapter:",n),mP(t,n),hP(this,{onSettings:(e,t)=>e.add.text(t.x,t.y,"Custom Settings",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201),onBook:(e,t)=>e.add.text(t.x,t.y,"Custom Book",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201)});const r=[{key:"Artery",label:"Arteries",type:"arteries"},{key:"Vein",label:"Veins",type:"veins"},{key:"BloodVessel",label:"Capillaries",type:"capillaries"}],s=this.sys.game.config.width,a=s/(r.length+1);r.forEach(((e,t)=>{const n=a*(t+1),r=this.add.image(n,380,e.key).setScale(.15).setOrigin(.5),s=this.add.zone(n,380,r.displayWidth,r.displayHeight).setRectangleDropZone(r.displayWidth,r.displayHeight);this.add.text(n,380+r.displayHeight/2+30,e.label,{fontSize:"22px",color:"#000"}).setOrigin(.5),s.zoneType=e.type,this.dropZones[e.type]=s})),this.properties=Jt.Utils.Array.Shuffle([{text:"Thick, elastic walls",type:"arteries"},{text:"Blood pulses strongly with each heartbeat",type:"arteries"},{text:"Have valves to prevent blood from flowing backward",type:"veins"},{text:"Lower pressure",type:"veins"},{text:"The smallest vessels",type:"capillaries"},{text:"Sites of exchange between blood and body cell",type:"capillaries"}]),this.totalCount=this.properties.length,this.correctCount=0,this.progressText=this.add.text(s/2,120,`0/${this.totalCount}`,{fontSize:"26px",color:"#333",fontStyle:"bold"}).setOrigin(.5),this.showHowToPlayPopup((()=>{this.showNextProperty()})),this.input.on("drop",((e,t,n)=>{n&&t&&(n.zoneType===t.propType?(this.correctCount++,this.progressText.setText(`${this.correctCount}/${this.totalCount}`),this.showImagePopup("correct",(()=>{t.textObj.destroy(),t.destroy(),this.showNextProperty()}))):this.showImagePopup("tryAgain",(()=>{this.tweens.add({targets:[t,t.textObj],x:t.originalX,y:t.originalY,duration:300,ease:"Sine.easeInOut"})})))})),this.add.text(s/2,170,"Match the property to the\ncorrect blood vessel type!",{fontSize:"30px",color:"#222",fontStyle:"bold"}).setOrigin(.5)}showNextProperty(){if(this.currentIndex>=this.properties.length)return this.add.rectangle(512,384,1024,768,0,.85).setOrigin(.5).setDepth(1e3),this.add.text(512,384,"All done!\nContinue to Chapter 2...",{fontSize:"32px",color:"#fff",align:"center"}).setOrigin(.5).setDepth(1001),void this.time.delayedCall(1e3,(()=>{this.scene.launch("LoadingOverlay"),this.scene.start("Chapter2")}));const e=this.properties[this.currentIndex++],t=this.sys.game.config.width/2,n=this.add.text(0,0,e.text,{fontSize:"18px",color:"#000",wordWrap:{width:340}}).setWordWrapWidth(340).setVisible(!1),r=n.height;n.destroy();const s=r+32,a=this.add.rectangle(t,660,360,s,16777215).setStrokeStyle(2,8947848).setDepth(3).setInteractive({draggable:!0}),i=this.add.text(t,660,e.text,{fontSize:"18px",color:"#000",wordWrap:{width:340},align:"center"}).setOrigin(.5).setDepth(4);a.propType=e.type,a.textObj=i,a.originalX=t,a.originalY=660,this.input.setDraggable(a),a.on("drag",((e,t,n)=>{a.x=t,a.y=n,i.x=t,i.y=n}))}showImagePopup(e,t){const n=this.add.rectangle(this.cameras.main.centerX,this.cameras.main.centerY,this.cameras.main.width,this.cameras.main.height,0,.6).setDepth(998),r=this.add.image(this.cameras.main.centerX,this.cameras.main.centerY,e).setOrigin(.5).setDepth(999).setScale(.8).setAlpha(0);this.tweens.add({targets:r,alpha:1,duration:300,yoyo:!0,hold:700,onComplete:()=>{r.destroy(),n.destroy(),t&&t()}})}showHowToPlayPopup(e){const t=this.add.rectangle(512,360,1024,800,0,.66).setOrigin(.5).setInteractive().setDepth(1e3),n=this.add.image(512,360,"quest1").setOrigin(.5).setDepth(1001).setScale(.5);t.once("pointerdown",(()=>{t.destroy(),n.destroy(),e&&e()}))}}class vP extends Jt.Scene{constructor(){super("Chapter2game"),this.player=null,this.cursors=null,this.score=0,this.hearts=3,this.heartIcons=[],this.questionIndex=0,this.questions=[],this.answeredRooms=new Set,this.enemies=[],this.zones={},this.canCheckZone=!1}preload(){this.load.image("magnifying","/assets/magnifying.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("map","/assets/map.jpg"),this.load.image("player","/assets/noobynooby.png"),this.load.image("enemy","/assets/enemy.png"),this.load.image("star","/assets/star.png"),this.load.image("correct","/assets/correct.png"),this.load.image("tryAgain","/assets/tryAgain.png"),this.load.image("quest2","/assets/quest2.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter2game";console.log("userId:",t,"currentChapter:",n),mP(t,n),this.hearts=3,this.heartIcons=[],this.add.image(512,384,"map").setDepth(0),hP(this,{onSettings:(e,t)=>e.add.text(t.x,t.y,"Custom Settings",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201),onBook:(e,t)=>e.add.text(t.x,t.y,"Custom Book",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201)}),this.questions=Jt.Utils.Array.Shuffle([{room:"Right Atrium",text:"The Right Atrium receives blood from the vena cava."},{room:"Right Ventricle",text:"The Right Ventricle pumps blood to the lungs."},{room:"Left Atrium",text:"The Left Atrium receives oxygenated blood from the lungs."},{room:"Left Ventricle",text:"The Left Ventricle pumps oxygenated blood to the body."}]),this.player=this.physics.add.sprite(100,700,"player"),this.player.setDisplaySize(64,64),this.player.setCollideWorldBounds(!0),this.cursors=this.input.keyboard.createCursorKeys()||this.input.touch.createCursorKeys(),this.createZones(),this.createEnemies(),this.scoreText=this.add.text(80,130,"Score: 0",{fontSize:"24px",color:"#fff"}).setScrollFactor(0),this.progressText=this.add.text(80,100,"Progress: 0/4",{fontSize:"24px",color:"#fff"}).setScrollFactor(0);for(let r=0;r<this.hearts;r++){const e=this.add.image(100+40*r,70,"star").setScrollFactor(0).setDisplaySize(32,32).setDepth(10);this.heartIcons.push(e)}this.showHowToPlayPopup((()=>this.askQuestion()))}showHowToPlayPopup(e){const t=this.add.rectangle(512,344,1024,768,0,.7).setOrigin(.5).setInteractive().setDepth(1e3),n=this.add.image(512,384,"quest2").setOrigin(.5).setDepth(1001).setScale(.5);t.once("pointerdown",(()=>{t.destroy(),n.destroy(),e&&e()}))}showQuestionPopup(e){this.physics.pause(),this.canCheckZone=!1;const t=this.add.rectangle(512,384,1024,768,0,.5).setDepth(299),n=this.add.rectangle(512,320,700,200,16777215).setDepth(300),r=this.add.text(512,320,e,{fontSize:"26px",color:"#222",align:"center",wordWrap:{width:640}}).setOrigin(.5).setDepth(301),s=this.add.text(512,410,"Close",{fontSize:"24px",color:"#FFD700",backgroundColor:"#333",padding:{left:16,right:16,top:8,bottom:8}}).setOrigin(.5).setDepth(302).setInteractive({useHandCursor:!0});s.on("pointerdown",(()=>{t.destroy(),n.destroy(),r.destroy(),s.destroy(),this.physics.resume(),this.time.delayedCall(500,(()=>{this.canCheckZone=!0}))}))}showImagePopup(e,t){this.physics.pause(),this.canCheckZone=!1;const n=this.add.rectangle(512,384,1024,768,0,.66).setOrigin(.5).setDepth(998).setInteractive(),r=this.add.image(512,384,e).setOrigin(.5).setDepth(999).setScale(.8),s=this.add.text(512,500,"Close",{fontSize:"28px",color:"#FFD700",backgroundColor:"#333",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(1e3).setInteractive({useHandCursor:!0});s.on("pointerdown",(()=>{n.destroy(),r.destroy(),s.destroy(),this.physics.resume(),this.time.delayedCall(500,(()=>{this.canCheckZone=!0})),t&&t()}))}createZones(){const e={"Right Atrium":new Jt.Geom.Rectangle(530,270,160,100),"Right Ventricle":new Jt.Geom.Rectangle(520,400,200,130),"Left Atrium":new Jt.Geom.Rectangle(310,270,180,90),"Left Ventricle":new Jt.Geom.Rectangle(260,390,200,130)};for(const[t,n]of Object.entries(e))this.zones[t]=n}createEnemies(){[{x:400,y:300},{x:600,y:400}].forEach((e=>{const t=this.physics.add.sprite(e.x,e.y,"enemy");t.setDisplaySize(48,48),this.enemies.push(t)}))}askQuestion(){if(this.questionIndex>=this.questions.length)return;const e=this.questions[this.questionIndex];this.showQuestionPopup(e.text)}checkZoneEntry(){const{x:e,y:t}=this.player,n=this.questions[this.questionIndex];if(this.answeredRooms.has(n.room))return;const r=this.zones[n.room];if(r&&r.contains(e,t))this.answeredRooms.add(n.room),this.handleAnswer(!0);else for(const[s,a]of Object.entries(this.zones))a.contains(e,t)&&s!==n.room&&this.handleAnswer(!1)}handleAnswer(e){e?this.showImagePopup("correct",(()=>{this.score+=10,this.scoreText.setText("Score: "+this.score),this.questionIndex++,this.progressText.setText(`Progress: ${this.questionIndex}/4`);const e=this.add.circle(this.player.x,this.player.y,10,16777215,.5).setDepth(9);this.tweens.add({targets:e,radius:60,alpha:0,duration:400,ease:"Cubic.easeOut",onComplete:()=>e.destroy()});const t=this.add.text(this.player.x,this.player.y-80,"+10",{fontSize:"28px",color:"#FFD700",fontStyle:"bold",stroke:"#000",strokeThickness:4}).setOrigin(.5).setDepth(10);if(this.tweens.add({targets:t,y:this.player.y-120,alpha:0,duration:700,ease:"Cubic.easeOut",onComplete:()=>t.destroy()}),this.hearts<this.heartIcons.length)this.heartIcons[this.hearts].setVisible(!0).setAlpha(1).setDisplaySize(32,32);else{const e=this.add.image(100+40*this.hearts,70,"star").setScrollFactor(0).setDisplaySize(32,32).setDepth(10);this.heartIcons.push(e)}this.hearts++,this.questionIndex>=this.questions.length?this.endGame(!0):(this.player.setPosition(100,700),this.askQuestion())})):this.showImagePopup("tryAgain",(()=>{if(this.hearts>0){this.hearts--;const e=this.heartIcons[this.hearts];e&&(this.tweens.add({targets:e,alpha:0,scale:1,duration:300,ease:"Back.easeIn",onComplete:()=>e.setVisible(!1)}),this.cameras.main.shake(200,.01))}this.hearts<=0?this.endGame(!1):(this.player.setPosition(100,700),this.askQuestion())}))}moveEnemies(){this.enemies.forEach((e=>{if(!e||!e.body)return;const t=this.player.x-e.x,n=this.player.y-e.y,r=Math.sqrt(t*t+n*n);if(r>0){const s=50;e.setVelocity(t/r*s,n/r*s)}}))}checkEnemyCollisions(){this.enemies.forEach((e=>{Jt.Math.Distance.Between(e.x,e.y,this.player.x,this.player.y)<30&&this.handleAnswer(!1)}))}handleMovement(){this.player.setVelocity(0),this.cursors.left.isDown?this.player.setVelocityX(-160):this.cursors.right.isDown&&this.player.setVelocityX(160),this.cursors.up.isDown?this.player.setVelocityY(-160):this.cursors.down.isDown&&this.player.setVelocityY(160)}update(){this.player&&(this.handleMovement(),this.canCheckZone&&this.checkZoneEntry(),this.moveEnemies(),this.checkEnemyCollisions())}endGame(e=!1){this.physics.pause(),this.add.rectangle(512,384,1024,768,0,.85).setDepth(1e3).setOrigin(.5).setInteractive();const t=e?"You Win!":"Game Over!";this.add.text(512,300,t,{fontSize:"48px",color:"#fff"}).setOrigin(.5).setDepth(1001);const n=this.add.text(512,400,"Play Again",{fontSize:"28px",color:"#FFD700",backgroundColor:"#333",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(1002).setInteractive({useHandCursor:!0});n.on("pointerdown",(()=>{n.destroy(),r.destroy(),this.scene.restart()}));const r=this.add.text(512,470,"Proceed to Chapter 3",{fontSize:"28px",color:"#FFD700",backgroundColor:"#333",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(1002).setInteractive({useHandCursor:!0});r.on("pointerdown",(()=>{n.destroy(),r.destroy(),this.scene.launch("LoadingOverlay"),this.scene.start("Chapter3")}))}}class wP extends Qt.Scene{constructor(){super("Chapter3"),this.characterSprites={},this.currentWiggleTween=null,this.propertyText=null,this.hasShaken=!1}preload(){this.load.image("Chapter3scene1","/assets/Chapter3scene1.png"),this.load.video("bloodflow","/assets/bloodflow.mp4"),this.load.image("rbc","/assets/rbc.png"),this.load.image("wbc","/assets/wbc.png"),this.load.image("platelet","/assets/platelet.png"),this.load.image("plasma","/assets/plasma.png"),this.load.image("magnifying","/assets/magnifying.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("5.png","/assets/5.png"),this.load.image("6.png","/assets/6.png"),this.load.image("7.png","/assets/7.png"),this.load.image("8.png","/assets/8.png"),this.load.image("9.png","/assets/9.png"),this.load.image("quest3","/assets/quest3.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter3";console.log("userId:",t,"currentChapter:",n),mP(t,n),this.cameras.main.setBackgroundColor("#000000"),this.coverImage=this.add.image(0,0,"Chapter3scene1").setOrigin(0,0).setDepth(0).setDisplaySize(this.sys.game.config.width,this.sys.game.config.height),this.startButton=this.add.text(this.cameras.main.centerX,this.cameras.main.centerY+300,"Start",{fontSize:"48px",color:"#ffffff",padding:{left:32,right:32,top:16,bottom:16}}).setOrigin(.5).setDepth(10).setInteractive({useHandCursor:!0}),hP(this,{onSettings:(e,t)=>e.add.text(t.x,t.y,"Settings",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201),onBook:(e,t)=>e.add.text(t.x,t.y,"Book",{fontSize:"32px",color:"#222"}).setOrigin(.5).setDepth(201)}),this.script=[{speaker:"Narrator",text:"Let’s meet the blood components.",sceneStep:1},{speaker:"Red Blood Cells (Erythrocytes)",text:"They carry oxygen from the lungs to all the cells.",character:"rbc",property:"Carry oxygen from the lungs to all body cells.\nContain hemoglobin, the protein that binds oxygen."},{speaker:"White Blood Cells (Leukocytes)",text:"They fight infection and remove invaders.",character:"wbc",property:"Protect the body by fighting infections.\nPlay a key role in the immune system."},{speaker:"Platelets (Thrombocytes)",text:"They help blood clot when you're injured.",character:"platelet",property:"Help blood clot, preventing excessive bleeding.\nGather at wounds to seal vessels."},{speaker:"Plasma",text:"The yellow fluid that carries nutrients and cells.",character:"plasma",property:"Transports nutrients, hormones, and blood cells.\nHelps maintain blood pressure and volume."},{speaker:"Narrator",text:"Now that you’ve met them all, let's begin your mission!"}],this.startButton.on("pointerdown",(()=>{this.startButton.destroy(),this.coverImage.destroy(),this.startStorySequence()})),this.input.keyboard.on("keydown",(e=>{("Space"===e.code||"Enter"===e.code)&&this.startButton&&this.startButton.active&&this.startButton.emit("pointerdown")}))}startStorySequence(){const e="bloodflow";this.cache.video.exists(e)&&(this.bgVideo=this.add.video(0,0,e).setOrigin(0,0).setDepth(0),this.bgVideo.play(!0).setLoop(!0));const t=["rbc","wbc","platelet","plasma"],n=this.sys.game.config.width/2-200*(t.length-1)/2;t.forEach(((e,t)=>{const r=this.add.image(n+200*t,480,e).setScale(.5).setDepth(100);this.characterSprites[e]=r})),this.dialogueUI||(this.dialogueUI=new gP(this)),this.nextButton=this.add.text(900,680,"▶ Next",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.backButton=this.add.text(820,680,"◀ Back",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.nextButton.on("pointerdown",(()=>this.dialogueUI.advance())),this.backButton.on("pointerdown",(()=>{this.currentLine>0&&(this.currentLine-=2,this.currentLine<0&&(this.currentLine=0),this.showCurrentLine())})),this.input.keyboard.on("keydown-ENTER",(()=>this.dialogueUI.advance())),this.input.keyboard.on("keydown-SPACE",(()=>this.dialogueUI.advance())),this.input.keyboard.on("keydown-RIGHT",(()=>this.dialogueUI.advance())),this.input.keyboard.on("keydown-LEFT",(()=>{this.currentLine>0&&(this.currentLine-=2,this.currentLine<0&&(this.currentLine=0),this.showCurrentLine())})),this.currentLine=0,this.showCurrentLine()}showCurrentLine(){if(this.currentLine>=this.script.length)return void this.triggerEarthquakePopup();const e=this.script[this.currentLine];if(this.currentWiggleTween&&(this.currentWiggleTween.stop(),this.currentWiggleTween=null),Object.values(this.characterSprites).forEach((e=>{this.tweens.killTweensOf(e),e.setScale(.5),e.setAngle(0)})),e.character&&this.characterSprites[e.character]){const t=this.characterSprites[e.character];t.setScale(.65),this.currentWiggleTween=this.tweens.add({targets:t,angle:{from:-6,to:6},duration:150,yoyo:!0,repeat:-1})}if(this.propertyText&&this.propertyText.destroy(),e.property){let t="";switch(e.character){case"rbc":t="🧬 ";break;case"wbc":t="🛡️ ";break;case"platelet":t="🩹 ";break;case"plasma":t="💧 "}const n=e.property.split("\n").map((e=>`${t}${e}`)).join("\n");this.propertyText=this.add.text(540,160,n,{fontSize:"26px",color:"#ffffff",wordWrap:{width:480},backgroundColor:"rgba(0,0,0,0.4)",padding:{left:16,right:16,top:10,bottom:10}}).setAlpha(0).setDepth(200),this.tweens.add({targets:this.propertyText,alpha:1,duration:400,ease:"Power2"})}this.backButton.setVisible(this.currentLine>0),this.dialogueUI.onLineComplete=()=>{this.currentLine++,this.showCurrentLine()},this.dialogueUI.startDialogue([e])}triggerEarthquakePopup(){this.hasShaken||(this.hasShaken=!0,this.cameras.main.shake(900,.04),this.time.delayedCall(1400,(()=>{const e=this.add.rectangle(512,384,1024,768,0,.7).setOrigin(.5).setInteractive().setDepth(1e3),t=this.add.image(512,384,"quest3").setOrigin(.5).setDepth(1001).setScale(.48),n=this.add.text(512,680,"Start Game",{fontSize:"28px",color:"#FFD700",backgroundColor:"#333",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(1002).setInteractive({useHandCursor:!0});n.on("pointerdown",(()=>{e.destroy(),t.destroy(),n.destroy(),this.scene.launch("LoadingOverlay"),this.scene.start("Chapter3game")}))})))}}class kP extends Jt.Scene{constructor(){super("Chapter3game"),this.timer=60,this.score=0,this.hearts=3,this.heartIcons=[],this.currentItem=null,this.totalItems=7,this.correctCount=0}preload(){this.load.video("bloodflow","/assets/bloodflow.mp4"),this.load.image("star","/assets/star.png"),this.load.image("magnifying","/assets/magnifying.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("rbc","/assets/rbc.png"),this.load.image("wbc","/assets/wbc.png"),this.load.image("platelet","/assets/platelet.png"),this.load.image("plasma","/assets/plasma.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter3game";console.log("userId:",t,"currentChapter:",n),mP(t,n),this.timer=60,this.score=0,this.hearts=3,this.correctCount=0,this.currentItem=null,this.heartIcons=[],this.add.video(0,0,"bloodflow").setOrigin(0,0).play(!0).setLoop(!0),hP(this,{onSettings:(e,t)=>e.add.text(t.x,t.y,"Settings",{fontSize:"24px",color:"#222"}).setOrigin(.5).setDepth(201),onBook:(e,t)=>e.add.text(t.x,t.y,"Book",{fontSize:"24px",color:"#222"}).setOrigin(.5).setDepth(201)}),this.cursors=this.input.keyboard.createCursorKeys()||this.input.touch.createCursorKeys(),this.targetBoxes=this.physics.add.staticGroup(),[{key:"rbc",label:"RBC"},{key:"wbc",label:"WBC"},{key:"platelet",label:"Platelets"},{key:"plasma",label:"Plasma"}].forEach(((e,t)=>{const n=180+220*t,r=this.add.image(n,581,e.key).setDisplaySize(100,100).setDepth(1).setScale(.5);this.add.text(n,710,e.label,{fontSize:"24px",color:"#fff"}).setOrigin(.5),this.targetBoxes.add(r),r.label=e.label}));for(let r=0;r<3;r++){const e=this.add.image(100+40*r,70,"star").setScrollFactor(0).setDisplaySize(28,28).setDepth(10);this.heartIcons.push(e)}this.scoreText=this.add.text(80,130,"Score: 0",{fontSize:"24px",color:"#fff"}).setScrollFactor(0).setDepth(11),this.progressText=this.add.text(80,100,"Progress: 0/7",{fontSize:"24px",color:"#fff"}).setScrollFactor(0).setDepth(11),this.timerText=this.add.text(512,92,"Time: 60",{fontSize:"32px",color:"#fff",fontStyle:"bold"}).setOrigin(.5).setDepth(11),this.startCountdown((()=>this.startGame()))}startCountdown(e){const t=this.add.text(512,384,"",{fontSize:"80px",color:"#fff"}).setOrigin(.5),n=["3","2","1","GO!"];let r=0;this.time.addEvent({delay:1e3,repeat:n.length-1,callback:()=>{t.setText(n[r]),r++,r===n.length&&(t.destroy(),e())}})}startGame(){this.time.addEvent({delay:1e3,loop:!0,callback:()=>{this.timer--,this.timerText.setText("Time: "+this.timer),this.timer<=0&&this.endGame(!0)}}),this.time.addEvent({delay:1200,loop:!0,callback:()=>{this.currentItem||this.spawnItem()}})}spawnItem(){const e=Jt.Utils.Array.GetRandom([{label:"bloodclot",target:"Platelets"},{label:"hormone",target:"Plasma"},{label:"food",target:"Plasma"},{label:"waste",target:"Plasma"},{label:"bacteria",target:"WBC"},{label:"poison",target:"WBC"},{label:"oxygen",target:"RBC"}]),t=Jt.Math.Between(100,924),n=this.add.rectangle(0,0,100,40,16777215).setStrokeStyle(2,0),r=this.add.text(0,0,e.label,{fontSize:"18px",color:"#000"}).setOrigin(.5),s=this.add.container(t,0,[n,r]);this.physics.world.enable(s),s.body.setVelocityY(100),s.setData("target",e.target),this.currentItem=s}update(){!this.currentItem||this.timer<=0||(this.cursors.left.isDown?this.currentItem.x-=4:this.cursors.right.isDown&&(this.currentItem.x+=4),this.currentItem.y>=620&&this.evaluateItem())}evaluateItem(){const e=this.targetBoxes.getChildren().find((e=>Jt.Geom.Rectangle.Contains(e.getBounds(),this.currentItem.x,this.currentItem.y))),t=this.currentItem.getData("target");if(e&&e.label===t){if(this.score+=10,this.correctCount++,this.scoreText.setText("Score: "+this.score),this.progressText.setText(`Progress: ${this.correctCount}/${this.totalItems}`),this.hearts<3){const e=this.heartIcons[this.hearts];e.setAlpha(1).setVisible(!0).setScale(.5),this.tweens.add({targets:e,scale:{from:.5,to:1.2},yoyo:!0,duration:300,ease:"Sine.easeInOut",onComplete:()=>{e.setScale(.5)}}),this.hearts++}const e=this.add.text(this.currentItem.x,this.currentItem.y-80,"+10",{fontSize:"28px",color:"#FFD700",fontStyle:"bold",stroke:"#000",strokeThickness:4}).setOrigin(.5).setDepth(10);this.tweens.add({targets:e,y:this.currentItem.y-120,alpha:0,duration:700,ease:"Cubic.easeOut",onComplete:()=>e.destroy()})}else this.hearts>0&&(this.hearts--,this.tweens.add({targets:this.heartIcons[this.hearts],alpha:0,duration:300,scale:.5})),this.cameras.main.shake(200,.01),this.targetBoxes.getChildren().forEach((e=>{this.tweens.add({targets:e,scaleX:1.1,scaleY:1.1,duration:100,yoyo:!0,ease:"Quad.easeInOut",onComplete:()=>e.setScale(.5)})}));this.currentItem.destroy(!0),this.currentItem=null,this.hearts<=0&&this.endGame(!1),this.correctCount>=this.totalItems&&this.endGame(!0)}endGame(e=!1){this.physics.pause(),this.add.rectangle(512,384,1024,768,0,.85).setDepth(1e3).setOrigin(.5).setInteractive();const t=e?"You Win!":"Game Over!";this.add.text(512,300,t,{fontSize:"48px",color:"#fff"}).setOrigin(.5).setDepth(1001),this.add.text(512,400,"Play Again",{fontSize:"28px",color:"#FFD700",backgroundColor:"#333",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(1002).setInteractive({useHandCursor:!0}).on("pointerdown",(()=>{this.scene.restart()})),this.add.text(512,470,"Proceed to Chapter 4",{fontSize:"28px",color:"#FFD700",backgroundColor:"#333",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(1002).setInteractive({useHandCursor:!0}).on("pointerdown",(()=>{this.scene.launch("LoadingOverlay"),this.scene.start("Chapter4")}))}}class SP extends Qt.Scene{constructor(){super("Chapter4"),this.currentLine=0,this.thoughtBubbles=[],this.activityImage=null}preload(){this.load.video("Chapter4scene1","/assets/Chapter4scene1.mp4"),this.load.video("heartbeat","/assets/heartbeat.mp4"),this.load.image("relaxing","/assets/relaxing.png"),this.load.image("resting","/assets/resting.png"),this.load.image("walking","/assets/walking.png"),this.load.image("Jogging","/assets/jogging.png"),this.load.image("running","/assets/running.png"),this.load.video("Blood","/assets/Blood.mp4"),this.load.video("Bloodflow","/assets/Bloodflow.mp4"),this.load.image("magnifying","/assets/magnifying.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("quest4","/assets/quest4.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter4";console.log("userId:",t,"currentChapter:",n),mP(t,n),this.cameras.main.setBackgroundColor("#000000"),this.coverImage=this.add.video(0,0,"Chapter4scene1").setOrigin(0,0).setDepth(0),this.coverImage.setMute(!0),this.coverImage.play(!0),this.coverImage.on("play",(()=>{const e=Math.min(this.sys.game.config.width/this.coverImage.video.videoWidth,this.sys.game.config.height/this.coverImage.video.videoHeight);this.coverImage.setDisplaySize(this.coverImage.video.videoWidth*e,this.coverImage.video.videoHeight*e)})),this.startButton=this.add.text(512,680,"Start",{fontSize:"48px",color:"#ffffff",padding:{left:24,right:24,top:12,bottom:12}}).setOrigin(.5).setDepth(10).setInteractive({useHandCursor:!0}),hP(this,{onSettings:(e,t)=>e.add.text(t.x,t.y,"Settings",{fontSize:"28px",color:"#222"}).setOrigin(.5).setDepth(201),onBook:(e,t)=>e.add.text(t.x,t.y,"Book",{fontSize:"28px",color:"#222"}).setOrigin(.5).setDepth(201)}),this.startButton.on("pointerdown",(()=>{this.startButton.destroy(),this.coverImage.destroy(),this.startStorySequence()}))}startStorySequence(){this.bgVideo=this.add.video(30,100,"heartbeat").setOrigin(-.25,0).setDepth(0),this.bgVideo.play(!0).setLoop(!0),this.dialogueUI=new gP(this),this.script=[{text:"Boom... boom... boom... Can you feel that?",speed:.8},{text:"The pulse is the rhythmic throbbing you can feel in your arteries, caused by the beating of the heart.",video:"Bloodflow"},{text:" It’s like the body's natural drumbeat, marking each heartbeat as blood is pumped through your arteries.",video:"Blood"},{text:"When you're relaxing 🧘 → ~50–60 bpm",speed:.2,bubble:"💨 Deep breathing... low pulse",image:"relaxing"},{text:"When you're resting 🛌 → ~60–80 bpm",speed:.5,bubble:"🛌 Resting... conserving energy",image:"resting"},{text:"When you're walking 🚶 → ~80–100 bpm",speed:1,bubble:"🚶 Gentle movement... light pump",image:"walking"},{text:"Jogging 🏃‍♂️ → ~100–140 bpm",speed:2.5,bubble:"🏃 Jogging... moderate effort",image:"running"},{text:"Running 🏃💨 → ~140–180 bpm",speed:3,bubble:"💥 Intense exercise!",image:"running"},{text:"Now it’s your mission to match your heartbeat to the activity shown."}],this.nextButton=this.add.text(900,680,"▶ Next",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.backButton=this.add.text(820,680,"◀ Back",{fontSize:"20px",fill:"#ffffff",backgroundColor:"#333",padding:{left:10,right:10,top:5,bottom:5}}).setInteractive().setDepth(1e3),this.nextButton.on("pointerdown",(()=>this.advanceDialogue())),this.backButton.on("pointerdown",(()=>{this.currentLine>0&&(this.currentLine-=2,this.showCurrentLine())})),this.input.keyboard.on("keydown-RIGHT",(()=>this.advanceDialogue())),this.input.keyboard.on("keydown-ENTER",(()=>this.advanceDialogue())),this.input.keyboard.on("keydown-SPACE",(()=>this.advanceDialogue())),this.input.keyboard.on("keydown-LEFT",(()=>{this.currentLine>0&&(this.currentLine-=2,this.showCurrentLine())})),this.showCurrentLine()}advanceDialogue(){this.dialogueUI.advance()}showCurrentLine(){if(this.currentLine>=this.script.length)return this.nextButton.destroy(),this.backButton.destroy(),void this.showGameTransition();const e=this.script[this.currentLine];if(this.bgVideo&&(this.bgVideo.destroy(),this.bgVideo=null),e.video?(this.bgVideo=this.add.video(0,0,e.video).setOrigin(0,0).setDepth(0),this.bgVideo.setMute(!0),this.bgVideo.play(!0)):(this.bgVideo=this.add.video(30,100,"heartbeat").setOrigin(-.25,0).setDepth(0),this.bgVideo.setMute(!0),this.bgVideo.play(!0),e.speed&&this.bgVideo.setPlaybackRate(e.speed)),this.activityImage&&this.activityImage.destroy(),this.thoughtBubbles.forEach((e=>e.destroy())),this.thoughtBubbles=[],e.bubble){const t=this.add.text(830,200,e.bubble,{fontSize:"22px",color:"#000",backgroundColor:"#ffffff",padding:{left:12,right:12,top:8,bottom:8}}).setOrigin(1,1.3).setAlpha(0).setDepth(10);this.tweens.add({targets:t,x:920,alpha:1,duration:600,ease:"Sine.easeInOut"}),this.thoughtBubbles.push(t)}e.image&&(this.activityImage=this.add.image(830,200,e.image).setOrigin(.8,.1).setScale(1).setDepth(9)),this.dialogueUI.onLineComplete=()=>{this.currentLine++,this.showCurrentLine()},this.backButton.setVisible(this.currentLine>0),this.dialogueUI.startDialogue([{speaker:"Narrator",text:e.text}])}showGameTransition(){const e=this.add.rectangle(512,384,1024,768,0,.7).setOrigin(.5).setInteractive().setDepth(1e3),t=this.add.image(512,384,"quest4").setOrigin(.5).setDepth(1001).setScale(.48),n=this.add.text(512,680,"Start Game",{fontSize:"28px",color:"#FFD700",backgroundColor:"#333",padding:{left:20,right:20,top:10,bottom:10}}).setOrigin(.5).setDepth(1002).setInteractive({useHandCursor:!0});n.on("pointerdown",(()=>{e.destroy(),t.destroy(),n.destroy(),this.scene.launch("LoadingOverlay"),this.scene.start("Chapter4game")}))}}class IP extends Jt.Scene{constructor(){super("Chapter4game"),this.rounds=[],this.currentRound=0,this.score=0,this.hearts=3,this.heartIcons=[],this.requiredTaps=0,this.currentTaps=0,this.character=null,this.heartbeatVideo=null,this.progressText=null,this.scoreText=null,this.targetBpmText=null,this.correctPopup=null,this.correctOverlay=null}preload(){this.load.image("star","/assets/star.png"),this.load.image("relaxing","/assets/relaxing.png"),this.load.image("resting","/assets/resting.png"),this.load.image("walking","/assets/walking.png"),this.load.image("jogging","/assets/jogging.png"),this.load.image("running","/assets/running.png"),this.load.video("heartbeat","/assets/heartbeat.mp4"),this.load.image("magnifying","/assets/magnifying.png"),this.load.image("setting","/assets/setting.png"),this.load.image("book","/assets/book.png"),this.load.image("correct","/assets/correct.png"),this.load.image("End","/assets/End.png")}create(){const e=JSON.parse(localStorage.getItem("currentUser")),t=null==e?void 0:e._id,n="Chapter4game";console.log("userId:",t,"currentChapter:",n),mP(t,n),this.cameras.main.setBackgroundColor("#000"),this.heartbeatVideo=this.add.video(240,400,"heartbeat").setScale(1).setDepth(1).play(!0),this.heartbeatVideo.setLoop(!0),hP(this),this.createUI(),this.generateRounds(),this.startRound(),this.input.keyboard.on("keydown-SPACE",(()=>this.handleTap())),this.input.on("click",(()=>this.handleTap())),this.input.on("pointerdown",(()=>this.handleTap())),this.correctOverlay=this.add.rectangle(this.cameras.main.centerX,this.cameras.main.centerY,this.cameras.main.width,this.cameras.main.height,0,.6).setDepth(199).setVisible(!1),this.correctPopup=this.add.container(this.cameras.main.centerX,this.cameras.main.centerY).setDepth(200).setVisible(!1);const r=this.add.image(0,0,"correct").setOrigin(.5);this.correctPopup.add(r)}createUI(){this.progressText=this.add.text(80,100,"Progress: 0/2",{fontSize:"24px",color:"#fff"}).setScrollFactor(0).setDepth(100),this.scoreText=this.add.text(80,130,"Score: 0",{fontSize:"24px",color:"#fff"}).setScrollFactor(0).setDepth(100),this.targetBpmText=this.add.text(750,180,"Target BPM: --",{fontSize:"28px",color:"#ffff00",fontStyle:"bold"}).setOrigin(.5);for(let e=0;e<3;e++){const t=this.add.image(100+40*e,70,"star").setScrollFactor(0).setDisplaySize(28,28).setDepth(100);this.heartIcons.push(t)}}generateRounds(){const e=[{label:"Relaxing (Trial)",targetInterval:1e3,image:"relaxing"},{label:"Resting",targetInterval:1090,image:"resting"},{label:"Walking",targetInterval:860,image:"walking"},{label:"Jogging",targetInterval:500,image:"jogging"},{label:"Running",targetInterval:400,image:"running"}];Jt.Utils.Array.Shuffle(e),this.rounds=[e[0],e[1]]}startRound(){if(this.currentRound>=2)return this.endGame();const e=this.rounds[this.currentRound],t=Math.round(6e4/e.targetInterval);this.requiredTaps=Math.round(t/10),this.currentTaps=0,this.progressText.setText(`Round ${this.currentRound+1} of 2`),this.targetBpmText.setText(`Target BPM: ${t} \n (Tap ${this.requiredTaps} times)`),this.character&&this.character.destroy(),this.character=this.add.image(750,400,e.image).setScale(.6)}handleTap(){this.currentTaps++,this.currentTaps===this.requiredTaps?(this.score+=10,this.scoreText.setText("Score: "+this.score),this.addHeart(),this.showCorrectPopup()):this.currentTaps>this.requiredTaps&&(this.loseHeart(),this.cameras.main.shake(200,.01),this.currentRound++,this.startRound())}loseHeart(){if(this.hearts>0){this.hearts--;const e=this.heartIcons[this.hearts];this.tweens.add({targets:e,alpha:0,duration:300})}}addHeart(){if(this.hearts<3){const e=this.heartIcons[this.hearts];e.setAlpha(1),this.tweens.add({targets:e,scale:.06,yoyo:!0,duration:300,onComplete:()=>e.setScale(.04)}),this.hearts++}}showCorrectPopup(){this.correctOverlay.setVisible(!0),this.correctPopup.setVisible(!0),this.input.enabled=!1,this.time.delayedCall(1500,(()=>{this.correctPopup.setVisible(!1),this.correctOverlay.setVisible(!1),this.input.enabled=!0,this.currentRound++,this.startRound()}))}endGame(){this.image=this.add.image(this.cameras.main.centerX,this.cameras.main.centerY,"End").setOrigin(.5).setScale(.7).setDepth(200),this.overlay=this.add.rectangle(this.cameras.main.centerX,this.cameras.main.centerY,this.cameras.main.width,this.cameras.main.height,0,.6).setDepth(199),this.continueButton=this.add.text(this.cameras.main.centerX,this.cameras.main.centerY+200,"Continue",{fontSize:"32px",backgroundColor:"#4BC6F0",color:"#fff",padding:{x:20,y:10},fontStyle:"bold",align:"center",fixedWidth:200}).setOrigin(.5).setDepth(201).setInteractive({useHandCursor:!0}),this.continueButton.on("pointerdown",(()=>{this.scene.start("Mode",{score:this.score})}))}}const CP="https://cellvivor-backend.onrender.com";class TP extends Qt.Scene{constructor(){super("Dashboard")}preload(){this.load.image("Chapter1scene1","/assets/Chapter1scene1.png"),this.load.video("Chapter2scene1","/assets/Chapter2fr.mp4"),this.load.image("Chapter3scene1","/assets/Chapter3scene1.png"),this.load.video("Chapter4scene1","/assets/Chapter4scene1.mp4"),this.load.image("star","/assets/star.png")}showTooltip(e,t,n){this.tooltipText&&this.tooltipText.destroy(),this.tooltipText=this.add.text(t,n,e,{fontSize:"16px",color:"#fff",backgroundColor:"#000a",padding:{left:8,right:8,top:4,bottom:4},align:"center",wordWrap:{width:200}}).setDepth(300).setOrigin(.5)}hideTooltip(){this.tooltipText&&(this.tooltipText.destroy(),this.tooltipText=null)}async create(){const e=this.scale.width,t=this.scale.height;this.cameras.main.setBackgroundColor("#fa821a");const n=JSON.parse(localStorage.getItem("currentUser")),r=null==n?void 0:n._id;if(!r)return void this.add.text(e/2,t/2,"User not logged in",{fontSize:"32px",color:"#000"}).setOrigin(.5);const s=.1*t,a=this.add.text(e/2,s,"Dashboard",{fontSize:"68px",color:"#fff",fontStyle:"bold",align:"center"}).setOrigin(.5).setDepth(100);this.add.image(a.x-226,s,"star").setOrigin(.5).setScale(.13).setDepth(101),this.add.image(a.x+226,s,"star").setOrigin(.5).setScale(.13).setDepth(101),this.add.rectangle(.25*e,.35*t,460,300,16777215).setStrokeStyle(2,13421772),this.add.text(.07*e,.18*t,"📈 Score & Hint Usage",{fontSize:"24px",color:"#000"}),this.add.rectangle(.07*e,.57*t,20,20,4966128),this.add.text(.07*e+30,.57*t,"Score",{fontSize:"18px",color:"#000"}),this.add.rectangle(.07*e+100,.57*t,20,20,16740721),this.add.text(.07*e+130,.57*t,"Hints Used",{fontSize:"18px",color:"#000"});let i=[];try{const e=await fetch(`${CP}/api/user/${r}/gameplay-history`);i=await e.json()}catch(DP){console.error("Gameplay history error:",DP)}const o=.07*e,l=.43*t;i.forEach(((e,t)=>{const n=o+40*t,r=e.score||0,s=e.hintUsed||0,a=Math.floor(e.avgTime||0);this.add.rectangle(n,l,30,3*-r,4966128).setOrigin(0,1),this.add.rectangle(n+15,l,15,10*-s,16740721).setOrigin(0,1),this.add.text(n,l+10,`${a}s`,{fontSize:"12px",color:"#000"}).setOrigin(0,0)})),this.add.rectangle(.75*e,.35*t,460,300,16777215).setStrokeStyle(2,13421772),this.add.text(.58*e,.18*t,"❌ Missed Words",{fontSize:"24px",color:"#000"});let u={};try{const e=await fetch(`${CP}/users/${r}`);u=await e.json()}catch(DP){console.error("User data error:",DP)}(u.weakness||[]).slice(0,12).forEach(((n,r)=>{const s=n.startsWith("TT")?"#FF5555":"#555555";this.add.text(.58*e,.22*t+22*r,`- ${n}`,{fontSize:"18px",color:s})})),this.add.text(e/2,.7*t,"📘 Chapter Roadmap",{fontSize:"28px",color:"#000"}).setOrigin(.5),[{type:"image",key:"Chapter1scene1",scene:"Chapter1Intro",desc:"Learn about the circulatory system basics."},{type:"video",key:"Chapter2scene1",scene:"Chapter2Intro",desc:"Explore the heart and blood vessels."},{type:"image",key:"Chapter3scene1",scene:"Chapter3Intro",desc:"Understand oxygen transport."},{type:"video",key:"Chapter4scene1",scene:"Chapter4Intro",desc:"Master the rhythm of the heartbeat."}].forEach(((n,r)=>{const s=.2*e+r*(.2*e),a=.78*t;if("image"===n.type){const e=this.add.image(s,a,n.key).setDisplaySize(160,90).setInteractive({useHandCursor:!0});e.on("pointerover",(()=>{e.setScale(1.05),this.showTooltip(n.desc,s,a-70)})),e.on("pointerout",(()=>{e.setScale(1),this.hideTooltip()})),e.on("pointerdown",(()=>this.scene.start(n.scene)))}else{const e=this.add.video(s,a,n.key).setDisplaySize(160,90).setInteractive({useHandCursor:!0});e.setLoop(!0).setMute(!0).play(!0),e.on("pointerover",(()=>{e.setScale(1.05),this.showTooltip(n.desc,s,a-70)})),e.on("pointerout",(()=>{e.setScale(1),this.hideTooltip()})),e.on("pointerdown",(()=>this.scene.start(n.scene)))}}));const c=this.add.rectangle(e-120,50,200,50,6318078).setInteractive({useHandCursor:!0});this.add.text(e-120,50,"🎮 Game Mode",{fontSize:"22px",color:"#fff"}).setOrigin(.5),c.on("pointerdown",(()=>this.scene.start("Mode")))}}const NP={type:Jt.AUTO,width:1024,height:768,parent:"game-container",backgroundColor:"#91e3ff",scene:[Zt,en,nn,Cr,lP,uP,cP,bP,yP,xP,vP,wP,kP,SP,IP,TP],physics:{default:"arcade",arcade:{debug:!1}}},EP=m.forwardRef((function({currentActiveScene:e},t){const n=m.useRef();return m.useLayoutEffect((()=>(void 0===n.current&&(n.current=new Jt.Game({...NP,parent:"game-container"}),null!==t&&(t.current={game:n.current,scene:null})),()=>{n.current&&(n.current.destroy(!0),n.current=void 0)})),[t]),m.useEffect((()=>(tn.on("current-scene-ready",(n=>{e instanceof Function&&e(n),t.current.scene=n})),()=>{tn.removeListener("current-scene-ready")})),[e,t]),h.jsx("div",{id:"game-container"})}));let $P=!1;function RP({onLogin:e}){return b.useEffect((()=>{(async()=>{if($P)return;$P=!0;const t=window.prompt("Enter your name:");if(!t)return void($P=!1);const n=window.prompt("Enter your email:");if(!n)return void($P=!1);const r=await fetch("https://cellvivor-backend.onrender.comapi/login",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:t,email:n})}),s=await r.json();s.success?(localStorage.setItem("currentUser",JSON.stringify(s.user)),localStorage.setItem("userId",s.user._id),e&&e(s.user),tn.emit("login-success")):window.alert(s.message||"Login failed"),$P=!1})()}),[]),null}let AP=!1;function _P({onSignin:e}){return b.useEffect((()=>{(async()=>{if(AP)return;AP=!0;const t=window.prompt("Enter your name:");if(!t)return void(AP=!1);const n=window.prompt("Enter your email:");if(!n)return void(AP=!1);const r=await fetch("https://cellvivor-backend.onrender.comapi/signin",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:t,email:n})}),s=await r.json();s.success?(localStorage.setItem("currentUser",JSON.stringify(s.user)),localStorage.setItem("userId",s.user._id),window.alert("Signin successful!"),e&&e(s.user),tn.emit("signin-success")):window.alert(s.message||"Signin failed"),AP=!1})()}),[]),null}function OP(){const[e,t]=m.useState(!0),[n,r]=m.useState({x:0,y:0}),s=m.useRef(),[a,i]=m.useState([]),[o,l]=m.useState(!1),[u,c]=m.useState(!1),d=JSON.parse(localStorage.getItem("currentUser")),p=m.useRef(null);return m.useEffect((()=>{Dt.get("users").then((e=>i(e.data))).catch((e=>console.error("Failed to load users:",e)))}),[]),m.useEffect((()=>{d&&(p.current=Sr("https://cellvivor-backend.onrender.com"),p.current.emit("registerUser",d.name))}),[d]),m.useEffect((()=>{const e=()=>l(!0),t=()=>c(!0);return tn.on("show-login",e),tn.on("show-signin",t),()=>{tn.off("show-login",e),tn.off("show-signin",t)}}),[]),h.jsxs("div",{id:"app",children:[h.jsx(EP,{ref:s,currentActiveScene:e=>{t("MainMenu"!==e.scene.key)}}),o&&h.jsx(RP,{onLogin:()=>l(!1)}),u&&h.jsx(_P,{onSignin:()=>c(!1)})]})}R.createRoot(document.getElementById("root")).render(h.jsx(b.StrictMode,{children:h.jsx(OP,{})}));
